<div dir="rtl">

# ماک‌ها و شکنندگی تست

این فصل شامل موارد زیر است:

- تفاوت بین ماک‌ها و استاب‌ها
- تعریف رفتار قابل مشاهده و جزئیات پیاده‌سازی
- درک رابطه بین ماک‌ها و شکنندگی تست
- استفاده از ماک‌ها بدون به خطر انداختن مقاومت در برابر بازسازی

فصل ۴ یک چارچوب مرجع معرفی کرد که می‌توانید از آن برای تحلیل تست‌های خاص و رویکردهای تست واحد استفاده کنید. در این فصل، این چارچوب مرجع را در عمل مشاهده خواهید کرد؛ ما از آن برای بررسی موضوع ماک‌ها استفاده خواهیم کرد.

استفاده از ماک‌ها در تست‌ها یک موضوع بحث‌برانگیز است. برخی افراد معتقدند که ماک‌ها ابزارهای فوق‌العاده‌ای هستند و در بیشتر تست‌های خود از آن‌ها استفاده می‌کنند. دیگران ادعا می‌کنند که ماک‌ها منجر به شکنندگی تست‌ها می‌شوند و سعی می‌کنند اصلاً از آن‌ها استفاده نکنند. همانطور که گفته می‌شود، حقیقت جایی در میان این دو قرار دارد. در این فصل، نشان خواهم داد که ماک‌ها اغلب منجر به تست‌های شکننده می‌شوند—تست‌هایی که فاقد معیار مقاومت در برابر بازسازی هستند. اما همچنان مواردی وجود دارد که ماک کردن قابل قبول و حتی ترجیحی است.

این فصل به شدت به بحث در مورد دو رویکرد لندن و کلاسیک در تست واحد که در فصل ۲ مطرح شده بود، متکی است. به طور خلاصه، اختلاف بین این دو رویکرد ناشی از دیدگاه‌های آن‌ها در مورد مسئله جداسازی تست‌ها است. رویکرد لندن معتقد است که باید قطعات کد تحت تست را از یکدیگر جدا کرد و از تست دوبل‌ها برای تمام وابستگی‌ها، به جز وابستگی‌های تغییرناپذیر، برای انجام این جداسازی استفاده کرد.

رویکرد کلاسیک بر جداسازی خود تست‌های واحد تأکید دارد تا این تست‌ها بتوانند به صورت موازی اجرا شوند. این رویکرد فقط برای وابستگی‌هایی که بین تست‌ها به اشتراک گذاشته می‌شوند از تست دوبل‌ها استفاده می‌کند.

بین ماک‌ها و شکنندگی تست‌ها ارتباط عمیق و تقریباً اجتناب‌ناپذیری وجود دارد. در بخش‌های بعدی، به تدریج پایه‌های لازم را برای شما فراهم خواهم کرد تا ببینید چرا این ارتباط وجود دارد. همچنین یاد خواهید گرفت که چگونه از ماک‌ها به گونه‌ای استفاده کنید که مقاومت تست‌ها در برابر بازسازی به خطر نیفتد.

# 5.1 تفاوت بین ماک‌ها و استاب‌ها
در فصل ۲، به‌طور مختصر ذکر کردم که ماک یک تست دوبل است که به شما اجازه می‌دهد تعاملات بین سیستم تحت تست (SUT) و همکارانش را بررسی کنید. نوع دیگری از تست دوبل وجود دارد به نام استاب. بیایید دقیق‌تر به این بپردازیم که ماک چیست و چگونه با استاب متفاوت است.

# 5.1.1 انواع تست دوبل‌ها
تست دوبل یک اصطلاح کلی است که برای توصیف انواع مختلف وابستگی‌های غیر آماده تولید و مصنوعی در تست‌ها استفاده می‌شود. این اصطلاح از مفهوم بدلکاری در فیلم‌ها گرفته شده است. کاربرد اصلی تست دوبل‌ها تسهیل تست کردن است؛ آن‌ها به جای وابستگی‌های واقعی که ممکن است سخت راه‌اندازی یا نگهداری شوند، به سیستم تحت تست پاس داده می‌شوند.

طبق گفته جرارد مسزاروس، پنج نوع مختلف از تست دوبل‌ها وجود دارد: داممی (Dummy)، استاب (Stub)، اسپای (Spy)، ماک (Mock)، و فیک (Fake). این تنوع ممکن است در ابتدا ترسناک به نظر برسد، اما در واقعیت، می‌توان آن‌ها را در دو دسته کلی تقسیم‌بندی کرد: ماک‌ها و استاب‌ها (شکل 5.1).

<p align="center">
    <img src="../Part 5/Images/figure-5.1.jpeg" />
</p>


تفاوت بین این دو نوع به نکات زیر برمی‌گردد:
- ماک‌ها به شبیه‌سازی و بررسی تعاملات خروجی کمک می‌کنند. این تعاملات شامل فراخوانی‌هایی هستند که SUT برای تغییر وضعیت وابستگی‌هایش انجام می‌دهد.
- استاب‌ها به شبیه‌سازی تعاملات ورودی کمک می‌کنند. این تعاملات شامل فراخوانی‌هایی هستند که SUT برای دریافت داده‌های ورودی از وابستگی‌هایش انجام می‌دهد (شکل 5.2).

<p align="center">
    <img src="../Part 2/Images/figure-2.1.jpeg" />
</p>

سایر تفاوت‌ها بین پنج نوع تست دوبل بیشتر جزئیات اجرایی بی‌اهمیت هستند. به عنوان مثال، اسپای‌ها همان نقشی را دارند که ماک‌ها ایفا می‌کنند. تفاوت در این است که اسپای‌ها به‌صورت دستی نوشته می‌شوند، در حالی که ماک‌ها با کمک یک فریم‌ورک ماکینگ ایجاد می‌شوند. گاهی اوقات مردم به اسپای‌ها به عنوان ماک‌های دست‌نویس اشاره می‌کنند.

از سوی دیگر، تفاوت بین یک استاب، داممی و فیک در میزان هوشمندی آن‌ها است. داممی یک مقدار ساده و هاردکد شده مانند مقدار null یا یک رشته ساختگی است. این مقدار برای تکمیل امضای متد SUT استفاده می‌شود و در تولید نتیجه نهایی نقشی ندارد. استاب پیچیده‌تر است. این نوع یک وابستگی کامل است که می‌توانید آن را برای بازگرداندن مقادیر مختلف در سناریوهای مختلف تنظیم کنید.

در نهایت، فیک از بسیاری جهات شبیه به استاب است. تفاوت در انگیزه ایجاد آن است: فیک معمولاً به عنوان جایگزینی برای وابستگی‌ای که هنوز وجود ندارد، پیاده‌سازی می‌شود.

به تفاوت بین ماک‌ها و استاب‌ها توجه کنید (جدا از تعاملات خروجی در مقابل تعاملات ورودی). ماک‌ها به شبیه‌سازی و بررسی تعاملات بین SUT و وابستگی‌هایش کمک می‌کنند، در حالی که استاب‌ها فقط به شبیه‌سازی آن تعاملات کمک می‌کنند. این یک تمایز مهم است. به زودی خواهید دید که چرا این تفاوت اهمیت دارد.


# 5.1.2 ماک (به عنوان ابزار) در مقابل ماک (به عنوان تست دوبل)
اصطلاح "ماک" چندین معنا دارد و ممکن است در شرایط مختلف به چیزهای متفاوتی اشاره کند.
در فصل ۲ اشاره کردم که مردم اغلب از اصطلاح "ماک" برای اشاره به هر نوع تست دوبل استفاده می‌کنند، در حالی که ماک‌ها تنها زیرمجموعه‌ای از تست دوبل‌ها هستند. اما معنای دیگری نیز برای اصطلاح "ماک" وجود دارد. می‌توان به کلاس‌های موجود در کتابخانه‌های ماکینگ نیز به عنوان ماک اشاره کرد. این کلاس‌ها به شما در ایجاد ماک‌های واقعی کمک می‌کنند، اما خودشان به‌تنهایی ماک نیستند. مثال زیر این موضوع را نشان می‌دهد.

```c#
    [Fact]
public void Sending_a_greetings_email()
{
var mock = new Mock<IEmailGateway>();
var sut = new Controller(mock.Object);
sut.GreetUser("user@email.com");
mock.Verify(
x => x.SendGreetingsEmail(
"user@email.com"),
Times.Once);
}
```
تست در مثال 5.1 از کلاس Mock از کتابخانه ماکینگ مورد نظر من (Moq) استفاده می‌کند. این کلاس ابزاری است که به شما امکان می‌دهد یک تست دوبل ایجاد کنید—یعنی یک ماک. به عبارت دیگر، کلاس Mock (یا Mock<IEmailGateway>) یک ماک (به عنوان ابزار) است، در حالی که نمونه‌ای از آن کلاس، mock، یک ماک (به عنوان تست دوبل) است. مهم است که ماک (به عنوان ابزار) را با ماک (به عنوان تست دوبل) اشتباه نگیرید، زیرا می‌توانید از ماک (به عنوان ابزار) برای ایجاد هر دو نوع تست دوبل استفاده کنید: ماک‌ها و استاب‌ها.

تست در مثال زیر نیز از کلاس Mock استفاده می‌کند، اما نمونه‌ای از آن کلاس یک ماک نیست؛ بلکه یک استاب است:

```c#
   [Fact]
public void Creating_a_report()
{
    var stub = new Mock<IDatabase>();
    stub.Setup(x => x.GetNumberOfUsers())
        .Returns(10);
    var sut = new Controller(stub.Object);
    Report report = sut.CreateReport();
    Assert.Equal(10, report.NumberOfUsers);
}

```
این تست دوبل یک تعامل ورودی را شبیه‌سازی می‌کند—یعنی یک فراخوانی که به SUT داده‌های ورودی می‌دهد. از سوی دیگر، در مثال قبلی (مثال 5.1)، فراخوانی SendGreetingsEmail() یک تعامل خروجی است. هدف اصلی آن ایجاد یک اثر جانبی است—ارسال یک ایمیل.


# 5.1.3 بررسی نکردن تعاملات با استاب‌ها
همان‌طور که در بخش 5.1.1 ذکر کردم، ماک‌ها به شبیه‌سازی و بررسی تعاملات خروجی بین SUT و وابستگی‌های آن کمک می‌کنند، در حالی که استاب‌ها فقط به شبیه‌سازی تعاملات ورودی کمک می‌کنند، نه بررسی آن‌ها. تفاوت بین این دو ناشی از این قاعده است که نباید تعاملات با استاب‌ها را بررسی کرد. فراخوانی SUT به یک استاب بخشی از نتیجه نهایی تولیدشده توسط SUT نیست. چنین فراخوانی فقط وسیله‌ای برای تولید نتیجه نهایی است: استاب داده‌های ورودی را فراهم می‌کند که SUT سپس از آن برای تولید خروجی استفاده می‌کند.

توجه: بررسی تعاملات با استاب‌ها یک الگوی ضد متداول است که منجر به شکنندگی تست‌ها می‌شود.

همان‌طور که احتمالاً از فصل 4 به خاطر دارید، تنها راه برای جلوگیری از نتایج مثبت کاذب و در نتیجه افزایش مقاومت تست‌ها در برابر بازسازی این است که این تست‌ها نتیجه نهایی را بررسی کنند (که باید به‌طور ایده‌آل برای یک غیر برنامه‌نویس هم معنادار باشد)، نه جزئیات پیاده‌سازی. در مثال 5.1، بررسی:


```c#
mock.Verify(x => x.SendGreetingsEmail("user@email.com"))

```
به یک نتیجه واقعی اشاره دارد، و آن نتیجه برای یک متخصص دامنه معنادار است: ارسال یک ایمیل خوش‌آمدگویی چیزی است که افراد تجاری ممکن است بخواهند سیستم انجام دهد. در عین حال، فراخوانی GetNumberOfUsers() در مثال 5.2 اصلاً یک نتیجه نیست. این یک جزئیات پیاده‌سازی داخلی است که نشان می‌دهد SUT چگونه داده‌های لازم برای ایجاد گزارش را جمع‌آوری می‌کند. بنابراین، بررسی این فراخوانی منجر به شکنندگی تست می‌شود: نباید مهم باشد که SUT چگونه نتیجه نهایی را تولید می‌کند، مادامی که آن نتیجه صحیح است. مثال زیر یک تست شکننده را نشان می‌دهد:

```c#
[Fact]
public void Creating_a_report()
{
    var stub = new Mock<IDatabase>();
    stub.Setup(x => x.GetNumberOfUsers()).Returns(10);
    var sut = new Controller(stub.Object);
    Report report = sut.CreateReport();
    Assert.Equal(10, report.NumberOfUsers);
    stub.Verify(
        x => x.GetNumberOfUsers(),
        Times.Once);
}

```
این شیوه‌ی بررسی مواردی که بخشی از نتیجه نهایی نیستند، همچنین به عنوان افراط در مشخصات شناخته می‌شود.

بیشترین موارد افراط در مشخصات زمانی اتفاق می‌افتد که تعاملات مورد بررسی قرار گیرند. بررسی تعاملات با استاب‌ها نقصی است که نسبتاً آسان می‌توان آن را شناسایی کرد، زیرا تست‌ها نباید هیچ تعاملی با استاب‌ها بررسی کنند. ماک‌ها موضوعی پیچیده‌تر هستند: استفاده از ماک‌ها همیشه منجر به شکنندگی تست نمی‌شود، اما بسیاری از آن‌ها چنین اثری دارند. در ادامه این فصل خواهید دید که چرا این‌طور است.

# 5.1.4 استفاده از ماک‌ها و استاب‌ها به‌طور همزمان
گاهی اوقات نیاز دارید تا یک تست دوبل ایجاد کنید که ویژگی‌های هر دو ماک و استاب را داشته باشد. به عنوان مثال، در اینجا تستی از فصل 2 وجود دارد که برای نشان دادن سبک لندن در تست واحد استفاده کردم.

```c#
[Fact]
public void Purchase_fails_when_not_enough_inventory()
{
    var storeMock = new Mock<IStore>();
    storeMock
        .Setup(x => x.HasEnoughInventory(Product.Shampoo, 5))
        .Returns(false);
    var sut = new Customer();
    bool success = sut.Purchase(storeMock.Object, Product.Shampoo, 5);
    Assert.False(success);
    storeMock.Verify(
        x => x.RemoveInventory(Product.Shampoo, 5),
        Times.Never);
}
```
این تست از storeMock برای دو هدف استفاده می‌کند: اولاً، یک پاسخ آماده را برمی‌گرداند و ثانیاً یک فراخوانی متد انجام شده توسط SUT را بررسی می‌کند. توجه داشته باشید که این‌ها دو متد متفاوت هستند: تست پاسخ از HasEnoughInventory() را تنظیم می‌کند اما سپس بررسی می‌کند که آیا فراخوانی به RemoveInventory() انجام شده است یا خیر. بنابراین، قاعده عدم بررسی تعاملات با استاب‌ها در اینجا نقض نمی‌شود.

زمانی که یک تست دوبل هم ماک و هم استاب است، همچنان به آن ماک گفته می‌شود، نه استاب. این عمدتاً به این دلیل است که باید یک نام را انتخاب کنیم، و همچنین به این دلیل که بودن به عنوان ماک، واقعیت مهم‌تری نسبت به بودن به عنوان استاب است.

# 5.1.5 ارتباط ماک‌ها و استاب‌ها با دستورات و پرس‌وجوها

<p align="center">
    <img src="../Part 5/Images/figure-5.3.jpeg" />
</p>

مفاهیم ماک‌ها و استاب‌ها با اصول تفکیک دستورات و پرس‌وجوها (CQS) مرتبط است. اصل CQS بیان می‌کند که هر متد باید یا یک دستور (command) باشد یا یک پرس‌وجو (query)، اما نه هر دو. همان‌طور که در شکل 5.3 نشان داده شده است، دستورات متدهایی هستند که اثرات جانبی تولید می‌کنند و هیچ مقداری برنمی‌گردانند (بازگشت void). مثال‌هایی از اثرات جانبی شامل تغییر وضعیت یک شی، تغییر یک فایل در سیستم فایل، و غیره است. پرس‌وجوها برعکس آن هستند—آن‌ها فاقد اثرات جانبی و مقداری را برمی‌گردانند.

برای پیروی از این اصل، اطمینان حاصل کنید که اگر یک متد اثر جانبی ایجاد می‌کند، نوع بازگشتی آن void باشد. و اگر متد مقداری را برمی‌گرداند، باید بدون اثر جانبی باقی بماند. به عبارت دیگر، پرسیدن یک سوال نباید پاسخ را تغییر دهد. کدی که این تفکیک واضح را حفظ می‌کند، خواناتر می‌شود. شما می‌توانید فقط با نگاه کردن به امضای متد بفهمید که آن متد چه کاری انجام می‌دهد، بدون نیاز به بررسی جزئیات پیاده‌سازی آن.

البته، همیشه امکان پیروی از اصل CQS وجود ندارد. همیشه متدهایی وجود دارند که منطقی است که هم اثر جانبی داشته باشند و هم مقداری را برگردانند. یک مثال کلاسیک از این مورد stack.Pop() است. این متد هم یک عنصر بالایی را از پشته حذف می‌کند و هم آن را به فراخواننده برمی‌گرداند. با این حال، پیروی از اصل CQS هر زمان که ممکن است، ایده خوبی است.

تست دوبل‌هایی که دستورات را جایگزین می‌کنند، ماک‌ها می‌شوند. به‌طور مشابه، تست دوبل‌هایی که پرس‌وجوها را جایگزین می‌کنند، استاب‌ها هستند. دوباره به دو تست از مثال‌های 5.1 و 5.2 نگاه کنید (قسمت‌های مربوطه آن‌ها را در اینجا نشان می‌دهم):

```c#
var mock = new Mock<IEmailGateway>();
mock.Verify(x => x.SendGreetingsEmail("user@email.com"));

var stub = new Mock<IDatabase>();
stub.Setup(x => x.GetNumberOfUsers()).Returns(10);
```
SendGreetingsEmail() یک دستور است که اثر جانبی آن ارسال ایمیل است. تست دوبلی که این دستور را جایگزین می‌کند، ماک است. از طرف دیگر، GetNumberOfUsers() یک پرس‌وجو است که مقداری را برمی‌گرداند و وضعیت پایگاه داده را تغییر نمی‌دهد. تست دوبل مربوط به آن، استاب است.

# 5.2 رفتار قابل مشاهده در برابر جزئیات پیاده‌سازی
بخش 5.1 توضیح داد که ماک چیست. مرحله بعدی در توضیح ارتباط بین ماک‌ها و شکنندگی تست، بررسی دلایل چنین شکنندگی است.

همان‌طور که ممکن است از فصل 4 به یاد داشته باشید، شکنندگی تست به ویژگی دوم یک تست واحد خوب اشاره دارد: مقاومت در برابر بازسازی. (به یادآوری، چهار ویژگی شامل حفاظت در برابر نواقص، مقاومت در برابر بازسازی، بازخورد سریع، و قابلیت نگهداری هستند.) معیار مقاومت در برابر بازسازی مهم‌ترین است زیرا آیا یک تست واحد این معیار را داراست یا نه، عموماً انتخابی دوتایی است. بنابراین، بهتر است این معیار را به حداکثر برسانید تا جایی که تست همچنان در دامنه تست واحد باقی بماند و به دسته تست‌های end-to-end منتقل نشود. تست‌های end-to-end، هرچند که در مقاومت در برابر بازسازی بهترین هستند، به طور کلی نگهداری آن‌ها بسیار دشوارتر است.

در فصل 4 همچنین مشاهده کردید که دلیل اصلی ارائه نتایج مثبت کاذب (و بنابراین شکست در مقاومت در برابر بازسازی) این است که تست‌ها به جزئیات پیاده‌سازی کد وابسته هستند. تنها راه برای جلوگیری از چنین وابستگی، بررسی نتیجه نهایی کد (رفتار قابل مشاهده آن) و دور نگه‌داشتن تست‌ها از جزئیات پیاده‌سازی به میزان ممکن است. به عبارت دیگر، تست‌ها باید بر روی "چی‌ها" تمرکز کنند، نه بر روی "چگونه‌ها". بنابراین، دقیقاً جزئیات پیاده‌سازی چیست و چگونه با رفتار قابل مشاهده متفاوت است؟

# 5.2.1 رفتار قابل مشاهده همان API عمومی نیست
تمام کدهای تولید شده را می‌توان در دو بعد دسته‌بندی کرد:

API عمومی در برابر API خصوصی (که API به معنای رابط برنامه‌نویسی کاربردی است)
رفتار قابل مشاهده در برابر جزئیات پیاده‌سازی
دسته‌بندی‌ها در این ابعاد تداخل ندارند. یک متد نمی‌تواند به طور همزمان بخشی از API عمومی و خصوصی باشد؛ یا یکی از آن‌ها است یا دیگری. به‌طور مشابه، کد یا جزئیات پیاده‌سازی داخلی است یا بخشی از رفتار قابل مشاهده سیستم است، اما نه هر دو.

بیشتر زبان‌های برنامه‌نویسی مکانیزم ساده‌ای برای تفاوت‌گذاری بین API‌های عمومی و خصوصی کد پایه فراهم می‌کنند. برای مثال، در C#، می‌توانید هر عضو در یک کلاس را با کلمه کلیدی private علامت‌گذاری کنید و آن عضو از کد مشتری پنهان می‌شود و به بخش API خصوصی کلاس تبدیل می‌شود. همین موضوع برای کلاس‌ها نیز صادق است: می‌توانید به راحتی آن‌ها را با استفاده از کلمه کلیدی private یا internal خصوصی کنید.

تفاوت بین رفتار قابل مشاهده و جزئیات پیاده‌سازی داخلی پیچیده‌تر است. برای اینکه یک قطعه کد بخشی از رفتار قابل مشاهده سیستم باشد، باید یکی از کارهای زیر را انجام دهد:

افشای یک عملیات که به مشتری کمک می‌کند تا یکی از اهداف خود را دستیابی کند. یک عملیات متدی است که محاسبه‌ای انجام می‌دهد یا اثر جانبی ایجاد می‌کند یا هر دو.
افشای یک وضعیت که به مشتری کمک می‌کند تا یکی از اهداف خود را دستیابی کند. وضعیت، وضعیت فعلی سیستم است.
هر کدی که هیچ‌یک از این دو کار را انجام ندهد، جزئیات پیاده‌سازی است.

توجه داشته باشید که اینکه آیا کد رفتار قابل مشاهده است یا خیر به مشتری آن و اهداف آن مشتری بستگی دارد.
برای اینکه کد بخشی از رفتار قابل مشاهده باشد، نیاز است که ارتباط فوری با حداقل یکی از این اهداف داشته باشد. واژه "مشتری" می‌تواند به چیزهای مختلفی اشاره داشته باشد بسته به جایی که کد قرار دارد. مثال‌های رایج شامل کد مشتری از همان پایگاه کد، یک برنامه خارجی، یا رابط کاربری است.

به‌طور ایده‌آل، سطح API عمومی سیستم باید با رفتار قابل مشاهده آن هم‌پوشانی داشته باشد و تمامی جزئیات پیاده‌سازی باید از دید مشتریان پنهان باشد. چنین سیستمی دارای API به‌خوبی طراحی‌شده است (شکل 5.4).

<p align="center">
    <img src="../Part 5/Images/figure-5.4.jpeg" />
</p>

برای اینکه کد بخشی از رفتار قابل مشاهده باشد، باید ارتباط فوری با حداقل یکی از این اهداف داشته باشد. واژه "مشتری" می‌تواند به چیزهای مختلفی اشاره داشته باشد بسته به جایی که کد قرار دارد. مثال‌های رایج شامل کد مشتری از همان پایگاه کد، یک برنامه خارجی، یا رابط کاربری است.

به‌طور ایده‌آل، سطح API عمومی سیستم باید با رفتار قابل مشاهده آن هم‌پوشانی داشته باشد و تمامی جزئیات پیاده‌سازی باید از دید مشتریان پنهان باشد. چنین سیستمی دارای API به‌خوبی طراحی‌شده است (شکل 5.4).

با این حال، اغلب سطح API عمومی سیستم فراتر از رفتار قابل مشاهده آن گسترش می‌یابد و شروع به افشای جزئیات پیاده‌سازی می‌کند. جزئیات پیاده‌سازی چنین سیستمی به سطح API عمومی آن نشت می‌کند (شکل 5.5).

<p align="center">
    <img src="../Part 5/Images/figure-5.5.jpeg" />
</p>

# 5.2.2 نشت جزئیات پیاده‌سازی: مثالی با یک عملیات
بیایید نگاهی به مثال‌هایی از کدی بیندازیم که جزئیات پیاده‌سازی آن به API عمومی نشت می‌کند. لیست 5.5 کلاسی به نام User را نشان می‌دهد که API عمومی آن شامل دو عضو است: یک خاصیت به نام Name و یک متد به نام NormalizeName() . این کلاس همچنین دارای یک invariant است: نام‌های کاربران نباید از 50 کاراکتر تجاوز کند و در غیر این صورت باید کوتاه شوند.


```c#
public class User
{
public string Name { get; set; }
public string NormalizeName(string name)
{
string result = (name ?? "").Trim();
if (result.Length > 50)
return result.Substring(0, 50);
return result;
}
}
public class UserController
{
public void RenameUser(int userId, string newName)
{
User user = GetUserFromDatabase(userId);
string normalizedName = user.NormalizeName(newName);
user.Name = normalizedName;
SaveUserToDatabase(user);
}
}
```
UserController یک کد مشتری است که از کلاس User در متد RenameUser خود استفاده می‌کند. هدف این متد، همان‌طور که احتمالاً حدس زده‌اید، تغییر نام یک کاربر است.
بنابراین، چرا API کلاس User به‌خوبی طراحی‌شده نیست؟ نگاهی دوباره به اعضای آن بیندازید: خاصیت Name و متد NormalizeName. هر دوی این‌ها عمومی هستند. بنابراین، برای اینکه API کلاس به‌خوبی طراحی‌شده باشد، این اعضا باید بخشی از رفتار قابل مشاهده باشند. این به نوبه خود نیاز دارد که آن‌ها یکی از دو کار زیر را انجام دهند (که برای سهولت تکرار می‌کنم):

افشای عملیاتی که به مشتری کمک می‌کند تا یکی از اهداف خود را برآورده سازد-
افشای وضعیتی که به مشتری کمک می‌کند تا یکی از اهداف خود را برآورده سازد-
تنها خاصیت Name این نیاز را برآورده می‌کند. این خاصیت دارای یک setter است که عملیاتی را فراهم می‌کند که به UserController اجازه می‌دهد هدف خود از تغییر نام کاربر را تحقق بخشد. متد NormalizeName نیز عملیاتی است، اما ارتباط فوری با هدف مشتری ندارد. تنها دلیلی که UserController این متد را فراخوانی می‌کند، برای برآورده کردن invariant کلاس User است. بنابراین، NormalizeName جزئیات پیاده‌سازی است که به API عمومی کلاس نشت می‌کند (شکل 5.6).

برای اصلاح وضعیت و طراحی درست API کلاس، User باید متد NormalizeName() را مخفی کند و آن را به‌طور داخلی به‌عنوان بخشی از setter خاصیت فراخوانی کند، بدون اینکه به کد مشتری وابسته باشد. لیست 5.6 این روش را نشان می‌دهد.


<p align="center">
    <img src="../Part 5/Images/figure-5.6.jpeg" />
</p>

```c#
public class User
{
private string _name;
public string Name
{
get => _name;
set => _name = NormalizeName(value);
}
private string NormalizeName(string name)
{
string result = (name ?? "").Trim();
if (result.Length > 50)
return result.Substring(0, 50);
return result;
}
}
public class UserController
{
public void RenameUser(int userId, string newName)
{
User user = GetUserFromDatabase(userId);
user.Name = newName;
SaveUserToDatabase(user);
}
}
```

در لیست 5.6، API کلاس User به‌خوبی طراحی شده است: تنها رفتار قابل مشاهده (خاصیت Name) عمومی شده است، در حالی که جزئیات پیاده‌سازی (متد NormalizeName) در پشت API خصوصی مخفی شده‌اند (شکل 5.7).

این رویکرد باعث می‌شود که کد تمیزتر، ساده‌تر و از نظر مقاومت در برابر تغییرات (refactoring) پایدارتر باشد. در واقع، با مخفی کردن جزئیات پیاده‌سازی و تنها ارائه رفتارهای قابل مشاهده به مشتریان، API کلاس انعطاف‌پذیرتر و استفاده از آن ساده‌تر می‌شود. این تغییرات همچنین خطر بروز اشکالات و مشکلات ناشی از وابستگی به جزئیات پیاده‌سازی را کاهش می‌دهد.


<p align="center">
    <img src="../Part 5/Images/figure-5.7.jpeg" />
</p>

در یادداشت (Note) آمده است که به طور دقیق‌تر، getter مربوط به خاصیت Name نیز باید خصوصی شود، زیرا در UserController استفاده نمی‌شود. اما در عمل، تقریباً همیشه نیاز دارید که تغییراتی که اعمال کرده‌اید را دوباره بررسی کنید. بنابراین، در یک پروژه واقعی، احتمالاً یک مورد استفاده دیگر وجود دارد که نیاز به مشاهده نام‌های فعلی کاربران از طریق getter خاصیت Name دارد.

در اینجا یک قاعده کلی مفید مطرح شده است که می‌تواند به شما کمک کند تشخیص دهید آیا یک کلاس جزئیات پیاده‌سازی خود را فاش می‌کند یا خیر. اگر تعداد عملیات‌هایی که مشتری (client) باید بر روی کلاس فراخوانی کند تا به یک هدف مشخص برسد بیش از یک باشد، احتمالاً آن کلاس جزئیات پیاده‌سازی خود را فاش می‌کند. به طور ایده‌آل، هر هدف خاص باید با یک عملیات واحد قابل دستیابی باشد. به عنوان مثال، در لیست 5.5، UserController باید دو عملیات از کلاس User را استفاده کند تا یک هدف خاص را محقق کند.

```c#
string normalizedName = user.NormalizeName(newName);
user.Name = normalizedName;
```
بعد از بازسازی (refactoring)، تعداد عملیات‌ها به یک کاهش یافته است:

این قاعده‌ی کلی در اکثر مواردی که منطق کسب‌وکار درگیر است، صادق است. البته ممکن است استثناهایی نیز وجود داشته باشد. با این حال، در هر موقعیتی که کد شما این قاعده را نقض می‌کند، حتماً آن را بررسی کنید تا از عدم نشت جزئیات پیاده‌سازی اطمینان حاصل کنید. این بررسی‌ها می‌توانند به شما کمک کنند تا کد تمیزتر و مقاوم‌تر در برابر تغییرات ایجاد کنید.


# 5.2.3 API با طراحی خوب و کپسوله‌سازی

حفظ یک API با طراحی خوب به مفهوم کپسوله‌سازی ارتباط دارد. همان‌طور که ممکن است از فصل ۳ به یاد داشته باشید، کپسوله‌سازی به معنای حفاظت از کد در برابر ناسازگاری‌ها یا همان نقض شرایطی است که باید همیشه درست باشند که به آن‌ها ناگذیر گفته می‌شود.

کلاس User در مثال قبلی یک ناگذیر داشت: هیچ کاربری نباید نامی داشته باشد که بیش از ۵۰ کاراکتر باشد. افشای جزئیات پیاده‌سازی معمولاً منجر به نقض ناگذیرها می‌شود—نسخه اصلی کلاس User نه تنها جزئیات پیاده‌سازی خود را افشا می‌کرد، بلکه کپسوله‌سازی صحیح را نیز حفظ نمی‌کرد. این امر به کد مشتری اجازه می‌داد تا ناگذیر را دور زده و نام جدیدی را به کاربر اختصاص دهد بدون اینکه ابتدا آن نام را نرمال‌سازی کند.

کپسوله‌سازی برای نگهداری کد در بلندمدت بسیار مهم است. دلیل آن پیچیدگی است. پیچیدگی کد یکی از بزرگترین چالش‌هایی است که در توسعه نرم‌افزار با آن مواجه می‌شوید. هرچه پایه کد پیچیده‌تر شود، کار با آن دشوارتر می‌شود، که به نوبه خود باعث کاهش سرعت توسعه و افزایش تعداد باگ‌ها می‌شود.

بدون کپسوله‌سازی، شما هیچ راهکار عملی برای مقابله با پیچیدگی روزافزون کد ندارید. وقتی که API کد شما راهنمایی لازم را در مورد آنچه مجاز است و آنچه مجاز نیست ارائه نمی‌دهد، شما باید اطلاعات زیادی را در ذهن خود نگه دارید تا مطمئن شوید که با تغییرات جدید کد ناسازگاری ایجاد نمی‌کنید. این امر باعث افزایش بار ذهنی در فرآیند برنامه‌نویسی می‌شود. تا جایی که ممکن است این بار را از دوش خود بردارید. نمی‌توانید همیشه به درستی کار کنید—پس امکان انجام کار اشتباه را به کلی حذف کنید. بهترین راه برای انجام این کار، حفظ کپسوله‌سازی مناسب است تا کد شما حتی گزینه‌ای برای انجام کار نادرست فراهم نکند.

در نهایت، کپسوله‌سازی هدفی مشابه با تست واحد دارد: این که امکان رشد پایدار پروژه نرم‌افزاری شما را فراهم کند.

اصلی مشابه وجود دارد: "بگو-نپرس". این اصل توسط مارتین فاولر مطرح شده است و به معنای ترکیب داده‌ها با توابعی است که بر روی آن داده‌ها عمل می‌کنند. می‌توانید این اصل را نتیجه‌ای از عمل کپسوله‌سازی بدانید. کپسوله‌سازی کد یک هدف است، در حالی که ترکیب داده‌ها و توابع با هم و همچنین پنهان کردن جزئیات پیاده‌سازی، وسیله‌ای برای دستیابی به آن هدف هستند:

پنهان کردن جزئیات پیاده‌سازی به شما کمک می‌کند که اجزای داخلی کلاس را از دید مشتریان آن خارج کنید، بنابراین خطر خرابی آن اجزا کمتر می‌شود.
ترکیب داده‌ها و عملیات‌ها کمک می‌کند تا مطمئن شوید این عملیات‌ها ناگذیرهای کلاس را نقض نمی‌کنند.

# 5.2.4 نشت جزئیات پیاده‌سازی: مثالی با وضعیت
مثالی که در فهرست ۵.۵ نشان داده شده، یک عملیات (متد NormalizeName) را به نمایش گذاشت که جزئیات پیاده‌سازی آن به طور نادرست به API عمومی افشا شده بود. حالا به یک مثال دیگر که شامل وضعیت است، توجه کنیم. فهرست زیر شامل کلاس MessageRenderer است که در فصل ۴ مشاهده کردید. این کلاس از مجموعه‌ای از زیررندرها استفاده می‌کند تا نمای HTML از پیامی که شامل سرصفحه، بدنه و پاورقی است، تولید کند.

```c#
public class MessageRenderer : IRenderer
{
public IReadOnlyList<IRenderer> SubRenderers { get; }
public MessageRenderer()
{
SubRenderers = new List<IRenderer>
{
new HeaderRenderer(),
new BodyRenderer(),
new FooterRenderer()
};
}
public string Render(Message message)
{
return SubRenderers
.Select(x => x.Render(message))
.Aggregate("", (str1, str2) => str1 + str2);
}
}

```
مجموعه زیررندرها عمومی است. اما آیا این جزئی از رفتار قابل مشاهده است؟ با فرض اینکه هدف مشتری رندر کردن یک پیام HTML باشد، پاسخ منفی است. تنها عضوی از کلاس که مشتری به آن نیاز دارد، خود متد Render است. بنابراین، SubRenderers نیز جزئی از جزئیات پیاده‌سازی است که به بیرون نشت کرده است.

دلیل اینکه این مثال را دوباره مطرح می‌کنم این است که، همان‌طور که ممکن است به یاد داشته باشید، از آن برای توضیح یک تست شکننده استفاده کردم. آن تست شکننده بود، زیرا به این جزئیات پیاده‌سازی متکی بود و به بررسی ترکیب مجموعه می‌پرداخت. شکنندگی با هدف‌گذاری دوباره تست بر روی متد Render برطرف شد. نسخه جدید تست نتیجه نهایی پیام را بررسی کرد—تنها خروجی‌ای که کد مشتری به آن اهمیت می‌داد، رفتار قابل مشاهده بود.

همان‌طور که مشاهده می‌کنید، ارتباط درونی بین تست‌های واحد خوب و API به‌خوبی طراحی شده وجود دارد. با خصوصی نگه‌داشتن تمامی جزئیات پیاده‌سازی، تست‌های شما هیچ گزینه‌ای جز بررسی رفتار قابل مشاهده کد نخواهند داشت که به طور خودکار مقاومت آن‌ها را در برابر تغییرات بهبود می‌بخشد.

نکته: طراحی خوب API به طور خودکار تست‌های واحد را بهبود می‌بخشد.

رهنمود دیگری از تعریف API به‌خوبی طراحی شده ناشی می‌شود: شما باید حداقل تعداد عملیات و وضعیت را در معرض دید قرار دهید. تنها کدی که به طور مستقیم به مشتریان در دستیابی به اهدافشان کمک می‌کند، باید عمومی باشد. همه چیزهای دیگر جزئیات پیاده‌سازی هستند و بنابراین باید پشت API خصوصی پنهان شوند.

توجه داشته باشید که مشکلی به نام نشت رفتار قابل مشاهده وجود ندارد که متقارن با مشکل نشت جزئیات پیاده‌سازی باشد. در حالی که می‌توانید یک جزئیات پیاده‌سازی (یک متد یا یک کلاس که قرار نیست توسط مشتری استفاده شود) را افشا کنید، نمی‌توانید یک رفتار قابل مشاهده را پنهان کنید. چنین متد یا کلاسی دیگر ارتباط مستقیمی با اهداف مشتری نخواهد داشت، زیرا مشتری قادر نخواهد بود به طور مستقیم از آن استفاده کند. بنابراین، به طور تعریف شده، این کد دیگر جزو رفتار قابل مشاهده نخواهد بود. جدول ۵.۱ خلاصه‌ای از این موضوع را ارائه می‌دهد.

جدول ۵.۱: رابطه بین عمومی بودن کد و هدف آن. از افشای جزئیات پیاده‌سازی خودداری کنید.



<p align="center">
    <img src="../Part 5/Images/figure-5-table.jpeg.png" />
</p>

# ۵.۳ رابطه بین موک‌ها و شکنندگی تست‌ها

بخش‌های قبلی یک موک را تعریف کردند و تفاوت بین رفتار قابل مشاهده و جزئیات پیاده‌سازی را نشان دادند. در این بخش، با معماری شش‌ضلعی، تفاوت بین ارتباطات داخلی و خارجی، و (بالاخره!) رابطه بین موک‌ها و شکنندگی تست‌ها آشنا خواهید شد.

# ۵.۳.۱ تعریف معماری شش‌ضلعی

یک برنامه معمولی از دو لایه تشکیل شده است: دامنه و خدمات برنامه، همان‌طور که در شکل ۵.۸ نشان داده شده است. لایه دامنه در وسط نمودار قرار دارد زیرا بخش مرکزی برنامه شماست. این لایه شامل منطق کسب‌وکار است: عملکرد اساسی که برنامه شما برای آن طراحی شده است. لایه دامنه و منطق کسب‌وکار آن، این برنامه را از دیگر برنامه‌ها متمایز می‌کند و مزیت رقابتی برای سازمان فراهم می‌آورد.


<p align="center">
    <img src="../Part 5/Images/figure-5.8.jpeg" />
</p>


ایه خدمات برنامه در بالای لایه دامنه قرار دارد و ارتباطات بین این لایه و دنیای خارجی را هماهنگ می‌کند. به عنوان مثال، اگر برنامه شما یک API RESTful باشد، تمامی درخواست‌ها ابتدا به لایه خدمات برنامه می‌رسند. این لایه سپس کار را بین کلاس‌های دامنه و وابستگی‌های خارج از فرآیند هماهنگ می‌کند. در اینجا یک مثال از چنین هماهنگی برای خدمات برنامه آورده شده است. این لایه انجام می‌دهد:

پرس و جو از پایگاه داده و استفاده از داده‌ها برای ایجاد یک نمونه از کلاس دامنه
فراخوانی یک عملیات روی آن نمونه
ذخیره نتایج مجدد به پایگاه داده
ترکیب لایه خدمات برنامه و لایه دامنه یک شش‌ضلعی را تشکیل می‌دهد که خود نمایانگر برنامه شماست. این شش‌ضلعی می‌تواند با برنامه‌های دیگر که با شش‌ضلعی‌های خودشان نمایان می‌شوند، تعامل داشته باشد (به شکل ۵.۹ مراجعه کنید). این برنامه‌های دیگر می‌توانند شامل خدمات SMTP، سیستم‌های شخص ثالث، یک بوس پیام و غیره باشند. مجموعه‌ای از شش‌ضلعی‌های متعامل، معماری شش‌ضلعی را تشکیل می‌دهد.

<p align="center">
    <img src="../Part 5/Images/figure-5.9.jpeg" />
</p>

اصطلاح معماری شش‌ضلعی توسط الیستیر کاکبورن معرفی شد. هدف آن تأکید بر سه راهنمایی مهم است:

تفکیک مسئولیت‌ها بین لایه‌های دامنه و خدمات برنامه: منطق کسب‌وکار مهم‌ترین بخش برنامه است. بنابراین، لایه دامنه باید تنها مسئول آن منطق کسب‌وکار باشد و از تمام مسئولیت‌های دیگر معاف گردد. این مسئولیت‌ها، مانند ارتباط با برنامه‌های خارجی و بازیابی داده‌ها از پایگاه داده، باید به خدمات برنامه اختصاص یابند. به طور معکوس، خدمات برنامه نباید هیچ منطق کسب‌وکار را شامل شوند. مسئولیت آن‌ها تطبیق لایه دامنه با ترجمه درخواست‌های ورودی به عملیات روی کلاس‌های دامنه و سپس ذخیره نتایج یا بازگرداندن آن‌ها به فراخواننده است. می‌توانید لایه دامنه را به عنوان مجموعه‌ای از دانش دامنه برنامه (چگونگی‌ها) و لایه خدمات برنامه را به عنوان مجموعه‌ای از موارد استفاده کسب‌وکار (چه‌کارهایی) در نظر بگیرید.

ارتباطات درون برنامه شما: معماری شش‌ضلعی جریان وابستگی‌های یک‌طرفه را تجویز می‌کند: از لایه خدمات برنامه به لایه دامنه. کلاس‌های موجود در لایه دامنه باید تنها به یکدیگر وابسته باشند و نباید به کلاس‌های لایه خدمات برنامه وابسته شوند. این راهنما از راهنمای قبلی ناشی می‌شود. تفکیک مسئولیت‌ها بین لایه خدمات برنامه و لایه دامنه به این معنی است که لایه خدمات برنامه از لایه دامنه آگاه است، اما برعکس صادق نیست. لایه دامنه باید به طور کامل از دنیای خارجی ایزوله شود.

ارتباطات بین برنامه‌ها: برنامه‌های خارجی از طریق یک رابط مشترک که توسط لایه خدمات برنامه حفظ می‌شود، به برنامه شما متصل می‌شوند. هیچ‌کسی به طور مستقیم به لایه دامنه دسترسی ندارد. هر طرف در یک شش‌ضلعی نمایانگر یک اتصال به داخل یا خارج از برنامه است. توجه داشته باشید که با اینکه یک شش‌ضلعی شش طرف دارد، این به معنای آن نیست که برنامه شما تنها می‌تواند به شش برنامه دیگر متصل شود. تعداد اتصالات دلخواه است. نکته این است که می‌تواند بسیاری از این اتصالات وجود داشته باشد.
هر لایه از برنامه شما رفتار قابل مشاهده‌ای را نشان می‌دهد و شامل مجموعه‌ای از جزئیات پیاده‌سازی است. به عنوان مثال، رفتار قابل مشاهده لایه دامنه، مجموع عملیات و وضعیت‌های این لایه است که به لایه خدمات برنامه کمک می‌کند تا به یکی از اهداف خود دست یابد. اصول یک API به‌خوبی طراحی شده دارای طبیعت فراکتالی هستند: این اصول به همان اندازه که به کل یک لایه اعمال می‌شوند، به یک کلاس واحد نیز اعمال می‌شوند.

هنگامی که API هر لایه به‌خوبی طراحی شده باشد (یعنی جزئیات پیاده‌سازی آن پنهان شده باشد)، تست‌های شما نیز شروع به داشتن ساختار فراکتالی می‌کنند؛ به این معنا که آن‌ها رفتارهایی را که به دستیابی به اهداف مشابه کمک می‌کنند اما در سطوح مختلف هستند، تأیید می‌کنند. یک تست که به خدمات برنامه می‌پردازد، بررسی می‌کند که چگونه این سرویس به هدف کلی و درشت‌مقیاس تعیین‌شده توسط مشتری خارجی می‌رسد. در عین حال، تستی که با یک کلاس دامنه کار می‌کند، یک زیرهدف که بخشی از آن هدف بزرگ‌تر است را تأیید می‌کند (شکل ۵.۱۰).

<p align="center">
    <img src="../Part 5/Images/figure-5.10.jpeg" />
</p>

ممکن است از فصل‌های قبلی به یاد داشته باشید که ذکر کردم باید قادر باشید هر تست را به یک نیاز کسب‌وکار خاص ردیابی کنید. هر تست باید داستانی را بازگو کند که برای یک متخصص دامنه معنا داشته باشد و اگر این‌گونه نباشد، این نشانه‌ای قوی است که تست به جزئیات پیاده‌سازی وابسته است و بنابراین شکننده است. امیدوارم اکنون بتوانید دلیل آن را مشاهده کنید.

رفتار قابل مشاهده از لایه‌های خارجی به سمت مرکز جریان دارد. هدف کلی که توسط مشتری خارجی مطرح می‌شود به زیراهداف تحقق‌یافته توسط کلاس‌های دامنه فردی ترجمه می‌شود. بنابراین، هر بخش از رفتار قابل مشاهده در لایه دامنه ارتباط خود را با یک مورد استفاده خاص کسب‌وکار حفظ می‌کند. می‌توانید این ارتباط را به صورت بازگشتی از لایه داخلی‌ترین (دامنه) به سمت لایه خدمات برنامه و سپس به نیازهای مشتری خارجی ردیابی کنید. این قابلیت ردیابی از تعریف رفتار قابل مشاهده ناشی می‌شود. برای اینکه یک قطعه کد بخشی از رفتار قابل مشاهده باشد، باید به مشتری در دستیابی به یکی از اهدافش کمک کند. برای یک کلاس دامنه، مشتری یک سرویس برنامه است؛ برای سرویس برنامه، خود مشتری خارجی است.

تست‌هایی که یک کد پایه با API به‌خوبی طراحی شده را تأیید می‌کنند، همچنین ارتباطی با نیازهای کسب‌وکار دارند، زیرا این تست‌ها تنها به رفتار قابل مشاهده مرتبط هستند. یک مثال خوب، کلاس‌های User و UserController از فهرست ۵.۶ است (کد را برای راحتی تکرار می‌کنم).

```c#
public class User
{
private string _name;
public string Name
{
get => _name;
set => _name = NormalizeName(value);
}
private string NormalizeName(string name)
{
/* Trim name down to 50 characters */
}
}
public class UserController
{
public void RenameUser(int userId, string newName)
{
User user = GetUserFromDatabase(userId);
user.Name = newName;
SaveUserToDatabase(user);
}
}
```
در این مثال، UserController یک سرویس برنامه است. با فرض اینکه مشتری خارجی هدف خاصی برای نرمال‌سازی نام‌های کاربری ندارد و همه نام‌ها صرفاً به دلیل محدودیت‌های خود برنامه نرمال‌سازی می‌شوند، متد NormalizeName در کلاس User نمی‌تواند به نیازهای مشتری ردیابی شود. بنابراین، این یک جزئیات پیاده‌سازی است و باید خصوصی شود (ما قبلاً این کار را در این فصل انجام داده‌ایم). علاوه بر این، تست‌ها نباید مستقیماً این متد را بررسی کنند. آن‌ها باید فقط به عنوان بخشی از رفتار قابل مشاهده کلاس—پراپرتی Name’s setter در این مثال—آن را تأیید کنند.

این راهنما مبنی بر همیشه ردیابی API عمومی کد پایه به نیازهای کسب‌وکار، به اکثریت قریب به اتفاق کلاس‌های دامنه و خدمات برنامه اعمال می‌شود، اما کمتر به کدهای ابزاری و زیرساختی. مشکلات فردی که این کدها حل می‌کنند اغلب بسیار سطح پایین و دقیق هستند و نمی‌توان آن‌ها را به یک مورد استفاده خاص کسب‌وکار ردیابی کرد.

# ۵.۳.۲ ارتباطات درون‌سیستمی در مقابل ارتباطات بین‌سیستمی

دو نوع ارتباط در یک برنامه معمولی وجود دارد: ارتباطات درون‌سیستمی و ارتباطات بین‌سیستمی. ارتباطات درون‌سیستمی ارتباطات بین کلاس‌ها درون برنامه شما هستند. ارتباطات بین‌سیستمی زمانی است که برنامه شما با برنامه‌های دیگر صحبت می‌کند (شکل ۵.۱۱).

نکته: ارتباطات درون‌سیستمی جزئیات پیاده‌سازی هستند؛ ارتباطات بین‌سیستمی نیستند.

ارتباطات درون‌سیستمی جزئیات پیاده‌سازی هستند زیرا همکاری‌هایی که کلاس‌های دامنه شما برای انجام یک عملیات انجام می‌دهند، بخشی از رفتار قابل مشاهده آن‌ها نیستند. این همکاری‌ها ارتباط مستقیمی با هدف مشتری ندارند. بنابراین، وابستگی به چنین همکاری‌هایی منجر به تست‌های شکننده می‌شود.

ارتباطات بین‌سیستمی موضوع متفاوتی است. برخلاف همکاری‌ها بین کلاس‌ها درون برنامه شما، نحوه‌ای که سیستم شما با دنیای خارجی صحبت می‌کند، رفتار قابل مشاهده کل سیستم را شکل می‌دهد. این بخشی از قرارداد است که برنامه شما باید در تمام زمان‌ها رعایت کند (شکل ۵.۱۲).

این ویژگی ارتباطات بین‌سیستمی ناشی از نحوه‌ای است که برنامه‌های جداگانه با هم تکامل می‌یابند. یکی از اصول اصلی چنین تکاملی حفظ سازگاری معکوس است. صرف نظر از تغییراتی که درون سیستم خود انجام می‌دهید، الگوی ارتباطی که برای صحبت با برنامه‌های خارجی استفاده می‌شود باید همیشه ثابت بماند، تا برنامه‌های خارجی بتوانند آن را درک کنند. به عنوان مثال، پیام‌هایی که برنامه شما در یک بوس منتشر می‌کند باید ساختار خود را حفظ کنند، فراخوانی‌هایی که به یک سرویس SMTP ارسال می‌شود باید همان تعداد و نوع پارامترها را داشته باشد، و غیره.

<p align="center">
    <img src="../Part 5/Images/figure-5.12.jpeg" />
</p>

استفاده از موک‌ها در هنگام بررسی الگوی ارتباطی بین سیستم شما و برنامه‌های خارجی مفید است. برعکس، استفاده از موک‌ها برای بررسی ارتباطات بین کلاس‌ها درون سیستم شما منجر به تست‌هایی می‌شود که به جزئیات پیاده‌سازی وابسته هستند و بنابراین در برابر تغییرات مقاومتی کمتری دارند.

# ۵.۳.۳ ارتباطات درون‌سیستمی در مقابل ارتباطات بین‌سیستمی: یک مثال

برای نمایش تفاوت بین ارتباطات درون‌سیستمی و ارتباطات بین‌سیستمی، مثال کلاس‌های Customer و Store که در فصل ۲ و همچنین در این فصل استفاده کردم را گسترش می‌دهم. فرض کنید مورد استفاده کسب‌وکار زیر وجود دارد:

یک مشتری تلاش می‌کند محصولی را از یک فروشگاه خریداری کند.
اگر میزان محصول در فروشگاه کافی باشد، سپس:
موجودی از فروشگاه کاهش می‌یابد.
یک رسید ایمیلی به مشتری ارسال می‌شود.
یک تأییدیه بازگردانده می‌شود.
همچنین فرض کنید که برنامه یک API بدون رابط کاربری است.

در فهرست زیر، کلاس CustomerController یک سرویس برنامه است که کار را بین کلاس‌های دامنه (Customer، Product، Store) و برنامه خارجی (EmailGateway، که یک پراکسی برای سرویس SMTP است) هماهنگ می‌کند.


```c#
public class CustomerController
{
public bool Purchase(int customerId, int productId, int quantity)
{
Customer customer = _customerRepository.GetById(customerId);
Product product = _productRepository.GetById(productId);
bool isSuccess = customer.Purchase(
_mainStore, product, quantity);
if (isSuccess)
{
_emailGateway.SendReceipt(
customer.Email, product.Name, quantity);
}
return isSuccess;
}
}
```
تأیید پارامترهای ورودی به خاطر اختصار حذف شده است. در متد Purchase، مشتری بررسی می‌کند که آیا موجودی در فروشگاه کافی است و اگر بله، مقدار محصول کاهش می‌یابد.

عمل خرید یک مورد استفاده کسب‌وکار است که شامل ارتباطات درون‌سیستمی و بین‌سیستمی است. ارتباطات بین‌سیستمی آن‌هایی هستند که بین سرویس برنامه CustomerController و دو سیستم خارجی صورت می‌گیرند: برنامه ثالث (که همچنین مشتری‌ای است که مورد استفاده را شروع می‌کند) و دروازه ایمیل. ارتباط درون‌سیستمی بین کلاس‌های دامنه Customer و Store است (شکل ۵.۱۳).

در این مثال، فراخوانی به سرویس SMTP یک اثر جانبی است که برای دنیای خارجی قابل مشاهده است و بنابراین رفتار قابل مشاهده کل برنامه را شکل می‌دهد.


<p align="center">
    <img src="../Part 5/Images/figure-5.13.jpeg" />
</p>



این همچنین ارتباط مستقیمی با اهداف مشتری دارد. مشتری برنامه سیستم ثالث است. هدف این سیستم انجام خرید است و انتظار دارد که مشتری یک ایمیل تأییدیه به عنوان بخشی از نتیجه موفق دریافت کند.

فراخوانی به سرویس SMTP دلیل مشروعی برای استفاده از موک‌ها است. این باعث شکنندگی تست نمی‌شود، زیرا شما می‌خواهید اطمینان حاصل کنید که این نوع ارتباط حتی پس از تغییرات در کد همچنان برقرار بماند. استفاده از موک‌ها به شما کمک می‌کند دقیقاً همین کار را انجام دهید.

فهرست بعدی مثالی از استفاده مشروع از موک‌ها را نشان می‌دهد.
```c#
[Fact]
public void Successful_purchase()
{
var mock = new Mock<IEmailGateway>();
var sut = new CustomerController(mock.Object);
bool isSuccess = sut.Purchase(
customerId: 1, productId: 2, quantity: 5);
Assert.True(isSuccess);
mock.Verify(
x => x.SendReceipt(
"customer@email.com", "Shampoo", 5),
Times.Once);
}
```
توجه داشته باشید که پرچم isSuccess نیز برای مشتری خارجی قابل مشاهده است و به تأیید نیاز دارد. با این حال، این پرچم نیازی به موک کردن ندارد؛ مقایسه ساده مقادیر کافی است.

اکنون به یک تست که ارتباط بین Customer و Store را موک می‌کند، نگاه کنیم.
```c#
[Fact]
public void Purchase_succeeds_when_enough_inventory()
{
var storeMock = new Mock<IStore>();
storeMock
.Setup(x => x.HasEnoughInventory(Product.Shampoo, 5))
.Returns(true);
var customer = new Customer();
bool success = customer.Purchase(
storeMock.Object, Product.Shampoo, 5);
Assert.True(success);
storeMock.Verify(
x => x.RemoveInventory(Product.Shampoo, 5),
Times.Once);
}
```
برخلاف ارتباط بین CustomerController و سرویس SMTP، فراخوانی متد RemoveInventory() از Customer به Store مرزهای برنامه را نمی‌شکند: هم فراخوان‌کننده و هم گیرنده درون برنامه قرار دارند. همچنین، این متد نه عملیاتی است و نه وضعیت که به مشتری کمک کند تا به اهدافش دست یابد.

مشتری این دو کلاس دامنه CustomerController است با هدف انجام خرید. تنها دو عضو که ارتباط مستقیمی با این هدف دارند، customer.Purchase() و store.GetInventory() هستند. متد Purchase() خرید را آغاز می‌کند و GetInventory() وضعیت سیستم را پس از تکمیل خرید نشان می‌دهد. فراخوانی متد RemoveInventory() یک مرحله میانی در مسیر رسیدن به هدف مشتری است—یک جزئیات پیاده‌سازی.

# ۵.۴ مدارس کلاسیک در مقابل مدارس لندن در تست واحد، مرور شده

برای یادآوری از فصل ۲ (جدول ۲.۱)، جدول ۵.۲ تفاوت‌های بین مدارس کلاسیک و مدارس لندن در تست واحد را خلاصه می‌کند.



<p align="center">
    <img src="../Part 5/Images/figure-5-6table.jpeg.png" />
</p>

در فصل ۲، اشاره کردم که من به مدرسه کلاسیک تست واحد نسبت به مدرسه لندن ترجیح می‌دهم. امیدوارم اکنون دلیل آن را درک کرده باشید. مدرسه لندن استفاده از موک‌ها را برای تمامی وابستگی‌ها به جز وابستگی‌های تغییرناپذیر تشویق می‌کند و تفاوتی بین ارتباطات درون‌سیستمی و بین‌سیستمی قائل نمی‌شود. در نتیجه، تست‌ها ارتباطات بین کلاس‌ها را به همان اندازه که ارتباطات بین برنامه شما و سیستم‌های خارجی را بررسی می‌کنند، بررسی می‌کنند.

این استفاده بی‌رحمانه از موک‌ها دلیل آن است که پیروی از مدرسه لندن اغلب منجر به تست‌هایی می‌شود که به جزئیات پیاده‌سازی وابسته هستند و بنابراین در برابر تغییرات مقاومتی ندارند. همانطور که ممکن است از فصل ۴ به یاد داشته باشید، معیار مقاومت در برابر تغییرات (برخلاف سه معیار دیگر) عمدتاً یک انتخاب باینری است: یک تست یا در برابر تغییرات مقاوم است یا نیست. سازش بر روی این معیار تست را تقریباً بی‌ارزش می‌کند.

مدرسه کلاسیک در این مسئله بسیار بهتر عمل می‌کند زیرا از جایگزینی تنها وابستگی‌هایی که بین تست‌ها مشترک هستند حمایت می‌کند، که تقریباً همیشه به معنای وابستگی‌های خارج از فرآیند مانند سرویس SMTP، بوس پیام و غیره است. اما مدرسه کلاسیک نیز در برخورد با ارتباطات بین‌سیستمی ایده‌آل نیست. این مدرسه همچنین استفاده بیش از حد از موک‌ها را تشویق می‌کند، هرچند به اندازه مدرسه لندن نیست.

۵.۴.۱ همه وابستگی‌های خارج از فرآیند نباید موک شوند

قبل از اینکه به وابستگی‌های خارج از فرآیند و موک کردن بپردازیم، اجازه دهید یک مرور سریع بر انواع وابستگی‌ها داشته باشیم (برای جزئیات بیشتر به فصل ۲ مراجعه کنید):

وابستگی مشترک—وابستگی‌ای که بین تست‌ها (نه کد تولید) به اشتراک گذاشته می‌شود.
وابستگی خارج از فرآیند—وابستگی‌ای که توسط فرآیندی غیر از فرآیند اجرایی برنامه میزبانی می‌شود (برای مثال، یک پایگاه داده، یک بوس پیام، یا یک سرویس SMTP).
وابستگی خصوصی—هر وابستگی که به اشتراک گذاشته نشده است.
مدرسه کلاسیک توصیه می‌کند که از وابستگی‌های مشترک اجتناب شود زیرا این وابستگی‌ها زمینه‌ای برای تداخل اجرای تست‌ها فراهم می‌کنند و بنابراین از اجرای همزمان آن‌ها جلوگیری می‌کنند. توانایی اجرای تست‌ها به صورت همزمان، به ترتیب، و به هر ترتیب، ایزولاسیون تست نامیده می‌شود.

اگر وابستگی مشترک خارج از فرآیند نباشد، سپس به راحتی می‌توان از تکرار آن در تست‌ها با ارائه یک نمونه جدید از آن در هر اجرای تست اجتناب کرد. در مواردی که وابستگی مشترک خارج از فرآیند است، تست کردن پیچیده‌تر می‌شود. شما نمی‌توانید یک پایگاه داده جدید ایجاد کنید یا یک بوس پیام جدید تأمین کنید پیش از هر اجرای تست؛ این کار به شدت سرعت مجموعه تست را کاهش می‌دهد. روش معمول این است که چنین وابستگی‌هایی را با دوپلیکیت‌های تستی—موک‌ها و استاب‌ها—جایگزین کنید.

با این حال، همه وابستگی‌های خارج از فرآیند نباید موک شوند. اگر وابستگی خارج از فرآیند تنها از طریق برنامه شما قابل دسترسی است، آنگاه ارتباطات با چنین وابستگی‌ای بخشی از رفتار قابل مشاهده سیستم شما نیست. یک وابستگی خارج از فرآیند که به طور خارجی قابل مشاهده نیست، در واقع به عنوان بخشی از برنامه شما عمل می‌کند (شکل ۵.۱۴).

به یاد داشته باشید، نیاز به حفظ الگوی ارتباطی بین برنامه شما و سیستم‌های خارجی از ضرورت حفظ سازگاری معکوس ناشی می‌شود.

<p align="center">
    <img src="../Part 5/Images/figure-5.14.jpeg" />
</p>

شما باید نحوه ارتباط برنامه خود با سیستم‌های خارجی را حفظ کنید. این به این دلیل است که نمی‌توانید این سیستم‌های خارجی را به طور همزمان با برنامه خود تغییر دهید؛ ممکن است آن‌ها دوره‌های انتشار متفاوتی داشته باشند یا ممکن است شما اصلاً کنترلی بر آن‌ها نداشته باشید.

اما زمانی که برنامه شما به عنوان یک پروکسی برای یک سیستم خارجی عمل می‌کند و هیچ کلاینتی نمی‌تواند به طور مستقیم به آن دسترسی پیدا کند، نیاز به سازگاری معکوس از بین می‌رود. اکنون می‌توانید برنامه خود را به همراه این سیستم خارجی منتشر کنید و این بر روی کلاینت‌ها تأثیری نخواهد گذاشت. الگوی ارتباطی با چنین سیستمی به یک جزئیات پیاده‌سازی تبدیل می‌شود.

یک مثال خوب در اینجا پایگاه داده برنامه است: پایگاه داده‌ای که تنها توسط برنامه شما استفاده می‌شود. هیچ سیستم خارجی به این پایگاه داده دسترسی ندارد. بنابراین، می‌توانید الگوی ارتباطی بین سیستم خود و پایگاه داده برنامه را به هر نحوی که بخواهید تغییر دهید، به شرط آنکه عملکرد موجود را خراب نکند. از آنجا که این پایگاه داده به طور کامل از دید کلاینت‌ها پنهان است، حتی می‌توانید آن را با یک مکانیزم ذخیره‌سازی کاملاً متفاوت جایگزین کنید و هیچ‌کس متوجه نخواهد شد.

استفاده از موک‌ها برای وابستگی‌های خارج از فرآیند که شما به طور کامل بر آن‌ها کنترل دارید نیز منجر به تست‌های شکننده می‌شود. شما نمی‌خواهید تست‌هایتان هر بار که یک جدول در پایگاه داده را تقسیم می‌کنید یا نوع یکی از پارامترها در یک رویه ذخیره‌سازی را تغییر می‌دهید، قرمز شود. پایگاه داده و برنامه شما باید به عنوان یک سیستم واحد در نظر گرفته شوند.

این مسئله به وضوح یک مشکل را مطرح می‌کند. چگونه می‌توانید کار با چنین وابستگی‌ای را بدون به خطر انداختن سرعت بازخورد، سومین ویژگی یک تست واحد خوب، تست کنید؟ شما این موضوع را در دو فصل بعد به طور کامل خواهید دید.

# ۵.۴.۲ استفاده از موک‌ها برای تأیید رفتار

موک‌ها اغلب به عنوان ابزاری برای تأیید رفتار گفته می‌شوند. در اکثر موارد، این‌گونه نیست. نحوه تعامل هر کلاس فردی با کلاس‌های همسایه به منظور دستیابی به هدفی، هیچ ارتباطی با رفتار قابل مشاهده ندارد؛ این یک جزئیات پیاده‌سازی است.

تأیید ارتباطات بین کلاس‌ها مشابه تلاش برای استخراج رفتار یک فرد با اندازه‌گیری سیگنال‌هایی است که نورون‌های مغز بین یکدیگر منتقل می‌کنند. این سطح از جزئیات بسیار ریز است. آنچه مهم است، رفتاری است که می‌تواند به اهداف کلاینت برگردد. کلاینت اهمیتی نمی‌دهد که چه نورون‌هایی در مغز شما روشن می‌شوند وقتی از شما درخواست کمک می‌کنند. تنها چیزی که اهمیت دارد، خود کمک است—که البته به صورت قابل اعتماد و حرفه‌ای ارائه شده است. موک‌ها تنها زمانی با رفتار مرتبط هستند که تعاملات را که مرز برنامه را عبور می‌کنند و تنها زمانی که اثرات جانبی این تعاملات برای دنیای خارجی قابل مشاهده است، تأیید کنند.

خلاصه

دوپلیکیت تست یک اصطلاح کلی است که تمام انواع وابستگی‌های غیرآماده تولید در تست‌ها را توصیف می‌کند. پنج نوع مختلف از دوپلیکیت‌های تست وجود دارد—دامی، استاب، اسپای، موک و فیک—که می‌توانند در دو نوع اصلی گروه‌بندی شوند: موک‌ها و استاب‌ها. اسپای‌ها از نظر عملکرد مشابه موک‌ها هستند؛ دامی‌ها و فیک‌ها نقش مشابهی به عنوان استاب‌ها دارند.

موک‌ها به شبیه‌سازی و بررسی تعاملات خروجی کمک می‌کنند: تماس‌های SUT با وابستگی‌هایش که وضعیت آن وابستگی‌ها را تغییر می‌دهند. استاب‌ها به شبیه‌سازی تعاملات ورودی کمک می‌کنند: تماس‌هایی که SUT با وابستگی‌هایش برای دریافت داده‌های ورودی انجام می‌دهد.

موک (ابزار) یک کلاس از کتابخانه موکینگ است که می‌توانید از آن برای ایجاد یک موک (دوپلیکیت تست) یا استاب استفاده کنید.
تأیید تعاملات با استاب‌ها منجر به تست‌های شکننده می‌شود. چنین تعاملاتی به نتیجه نهایی مربوط نمی‌شود؛ بلکه یک مرحله واسط در مسیر رسیدن به آن نتیجه است، یک جزئیات پیاده‌سازی.
اصل تفکیک فرمان و پرسش (CQS) بیان می‌کند که هر متد باید یا یک فرمان باشد یا یک پرسش، اما نه هر دو. دوپلیکیت‌های تستی که فرمان‌ها را جایگزین می‌کنند، موک‌ها هستند. دوپلیکیت‌های تستی که پرسش‌ها را جایگزین می‌کنند، استاب‌ها هستند.
تمامی کدهای تولید می‌توانند در دو بعد طبقه‌بندی شوند: API عمومی در مقابل API خصوصی و رفتار قابل مشاهده در مقابل جزئیات پیاده‌سازی. شهرت کد توسط اصلاح‌کننده‌های دسترسی، مانند کلیدواژه‌های private، public و internal کنترل می‌شود. کد بخشی از رفتار قابل مشاهده است زمانی که یکی از الزامات زیر را برآورده کند (هر کد دیگری جزئیات پیاده‌سازی است):
یک عملیات را افشا می‌کند که به کلاینت کمک می‌کند به یکی از اهدافش برسد. یک عملیات یک متد است که محاسبه‌ای انجام می‌دهد یا اثر جانبی به بار می‌آورد.
یک وضعیت را افشا می‌کند که به کلاینت کمک می‌کند به یکی از اهدافش برسد. وضعیت شرایط کنونی سیستم است.
کد خوب طراحی شده کدی است که رفتار قابل مشاهده آن با API عمومی هم‌راستا باشد و جزئیات پیاده‌سازی آن پشت API خصوصی پنهان شده باشد. کد جزئیات پیاده‌سازی را زمانی نشت می‌دهد که API عمومی آن فراتر از رفتار قابل مشاهده گسترش یابد.
محافظت‌سازی عمل محافظت از کد شما در برابر نقض‌های ثابت است. افشای جزئیات پیاده‌سازی اغلب به نقض محافظت‌سازی منجر می‌شود زیرا کلاینت‌ها می‌توانند از جزئیات پیاده‌سازی برای دور زدن invariants کد استفاده کنند.
معماری شش‌ضلعی مجموعه‌ای از برنامه‌های تعامل‌کننده است که به عنوان شش‌ضلعی‌ها نمایش داده می‌شوند. هر شش‌ضلعی شامل دو لایه است: دامنه و خدمات برنامه.
معماری شش‌ضلعی بر روی سه جنبه مهم تأکید می‌کند:
تفکیک نگرانی‌ها بین لایه‌های دامنه و خدمات برنامه. لایه دامنه باید مسئول منطق کسب و کار باشد، در حالی که خدمات برنامه باید کار را بین لایه دامنه و برنامه‌های خارجی هماهنگ کند.
جریان تک‌جهته وابستگی‌ها از لایه خدمات برنامه به لایه دامنه. کلاس‌های داخل لایه دامنه باید تنها به یکدیگر وابسته باشند؛ آن‌ها نباید به کلاس‌های لایه خدمات برنامه وابسته باشند.
برنامه‌های خارجی از طریق یک رابط مشترک که توسط لایه خدمات برنامه نگهداری می‌شود، به برنامه شما متصل می‌شوند. هیچ‌کس به لایه دامنه به طور مستقیم دسترسی ندارد.
هر لایه در یک شش‌ضلعی رفتار قابل مشاهده‌ای از خود نشان می‌دهد و شامل مجموعه‌ای از جزئیات پیاده‌سازی خود است.
دو نوع ارتباط در یک برنامه وجود دارد: ارتباطات درون‌سیستمی و ارتباطات بین‌سیستمی. ارتباطات درون‌سیستمی ارتباطات بین کلاس‌های داخل برنامه است. ارتباطات بین‌سیستمی زمانی است که برنامه با برنامه‌های خارجی صحبت می‌کند.

ارتباطات درون‌سیستمی جزئیات پیاده‌سازی هستند. ارتباطات بین‌سیستمی بخشی از رفتار قابل مشاهده هستند، به جز سیستم‌های خارجی که تنها از طریق برنامه شما قابل دسترسی هستند. تعاملات با چنین سیستم‌هایی نیز جزئیات پیاده‌سازی هستند، زیرا اثرات جانبی آن‌ها به صورت خارجی قابل مشاهده نیست.
استفاده از موک‌ها برای تأیید ارتباطات درون‌سیستمی منجر به تست‌های شکننده می‌شود. موکینگ تنها زمانی مشروع است که برای ارتباطات بین‌سیستمی—ارتباطاتی که مرز برنامه را عبور می‌کنند—استفاده شود و تنها زمانی که اثرات جانبی این ارتباطات برای دنیای خارجی قابل مشاهده باشد.





























</div>
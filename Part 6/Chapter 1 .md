<div dir='rtl'>

# انواع تست واحد

فصل چهارم به چهار ویژگی یک تست واحد خوب اشاره کرد: حفاظت در برابر بازگشت‌ها، مقاومت در برابر تغییرات ساختاری، بازخورد سریع و قابلیت نگهداری. این ویژگی‌ها چارچوبی را تشکیل می‌دهند که می‌توانید از آن برای تحلیل تست‌های خاص و رویکردهای تست واحد استفاده کنید. در فصل پنج، یکی از این رویکردها، استفاده از mock‌ها را تحلیل کردیم.
در این فصل، همان چارچوب را برای موضوع سبک‌های تست واحد به کار می‌برم. سه سبک تست وجود دارد: تست مبتنی بر خروجی، تست مبتنی بر حالت و تست مبتنی بر ارتباط. در میان این سه، سبک تست مبتنی بر خروجی بالاترین کیفیت تست‌ها را تولید می‌کند، تست مبتنی بر حالت انتخاب دوم بهترین است و تست مبتنی بر ارتباط تنها باید به ندرت استفاده شود.
متاسفانه، نمی‌توان از سبک تست مبتنی بر خروجی در همه جا استفاده کرد. این سبک تنها برای کدی قابل اجراست که به صورت کاملاً تابعی نوشته شده باشد. اما نگران نباشید؛ تکنیک‌هایی وجود دارند که می‌توانند به شما کمک کنند تا بیشتر تست‌های خود را به سبک مبتنی بر خروجی تبدیل کنید. برای این کار، نیاز خواهید داشت تا اصول برنامه‌نویسی تابعی را برای بازسازی کد زیرین به سمت یک معماری تابعی به کار بگیرید.
توجه داشته باشید که این فصل به موضوع برنامه‌نویسی تابعی به طور عمیق نمی‌پردازد. با این حال، امیدوارم تا پایان این فصل، درک شهودی از چگونگی ارتباط برنامه‌نویسی تابعی با تست مبتنی بر خروجی پیدا کنید. همچنین خواهید آموخت که چگونه تست‌های بیشتری را با استفاده از سبک مبتنی بر خروجی بنویسید و از محدودیت‌های برنامه‌نویسی تابعی و معماری تابعی آگاه شوید.

# سه سبک تست واحد

سه سبک تست واحد همان‌طور که در مقدمه فصل اشاره کردم، سه سبک تست واحد وجود دارد:

• تست مبتنی بر خروجی
• تست مبتنی بر حالت
• تست مبتنی بر ارتباط

می‌توانید یکی، دو یا حتی هر سه سبک را در یک تست به‌کار ببرید. این بخش، پایه‌ای برای کل فصل فراهم می‌کند و این سه سبک تست واحد را با مثال‌هایی تعریف می‌کند. در بخش بعدی، خواهید دید که این سبک‌ها چگونه نسبت به یکدیگر امتیاز می‌گیرند.

# تعریف سبک مبتنی بر خروجی

تعریف سبک مبتنی بر خروجی اولین سبک تست واحد، سبک مبتنی بر خروجی است، که در آن یک ورودی به سیستم تحت تست (SUT) داده می‌شود و خروجی تولید شده بررسی می‌شود (شکل 6.1). این سبک تست واحد تنها برای کدی قابل استفاده است که حالت داخلی یا جهانی را تغییر نمی‌دهد، بنابراین تنها مؤلفه‌ای که باید بررسی شود مقدار بازگشتی است.
لیست زیر نمونه‌ای از چنین کدی و یک تست پوشش‌دهنده آن را نشان می‌دهد. کلاس PriceEngine یک آرایه از محصولات را می‌پذیرد و تخفیف را محاسبه می‌کند.

<p align="center">
    <img src="../Part 6/figures/figure-6.1.png" />
</p>

هنوز ترجمه نشده

لیست زیر نمونه‌ای از چنین کدی و یک تست پوشش‌دهنده آن را نشان می‌دهد. کلاس PriceEngine یک آرایه از محصولات را می‌پذیرد و تخفیف را محاسبه می‌کند.

<div dir='ltr'>
  
```c#
public class PriceEngine
{
public decimal CalculateDiscount(params Product[] products)
{
decimal discount = products.Length * 0.01m;
return Math.Min(discount, 0.2m);
}
}
[Fact]
public void Discount_of_two_products()
{
var product1 = new Product("Hand wash");
var product2 = new Product("Shampoo");
var sut = new PriceEngine();
decimal discount = sut.CalculateDiscount(product1, product2);
Assert.Equal(0.02m, discount);
}
```

</div>

PriceEngine تعداد محصولات را در 1% ضرب می‌کند و نتیجه را در 20% محدود می‌کند. این کلاس هیچ عملکرد دیگری ندارد. محصولات را به هیچ مجموعه داخلی اضافه نمی‌کند و آنها را در یک پایگاه داده ذخیره نمی‌کند. تنها خروجی متد CalculateDiscount() تخفیفی است که بازمی‌گرداند: مقدار خروجی (شکل 6.2).

<p align="center">
    <img src="../Part 6/figures/figure-6.2.png" />
</p>

هنوز ترجمه نشده

سبک تست واحد مبتنی بر خروجی همچنین به عنوان تست تابعی شناخته می‌شود. این نام ریشه در برنامه‌نویسی تابعی دارد، روشی از برنامه‌نویسی که تأکید بر کد بدون اثر جانبی دارد. در ادامه این فصل بیشتر درباره برنامه‌نویسی تابعی و معماری تابعی صحبت خواهیم کرد.

# تعریف سبک مبتنی بر حالت

سبک مبتنی بر حالت به بررسی وضعیت سیستم پس از انجام عملیات می‌پردازد (شکل 6.3). اصطلاح حالت در این سبک تست می‌تواند به وضعیت سیستم تحت تست (SUT) خود، یکی از همکاران آن یا یک وابستگی خارجی مانند پایگاه داده یا سیستم فایل اشاره داشته باشد.

<p align="center">
    <img src="../Part 6/figures/figure-6.3.png" />
</p>

هنوز ترجمه نشده

مثال از تست مبتنی بر حالت کلاس Order به مشتری اجازه می‌دهد تا یک محصول جدید اضافه کند.

```c#
public class Order
{
private readonly List<Product> _products = new List<Product>();
public IReadOnlyList<Product> Products => _products.ToList();
public void AddProduct(Product product)
{
_products.Add(product);
}
}
[Fact]
public void Adding_a_product_to_an_order()
{
var product = new Product("Hand wash");
var sut = new Order();
sut.AddProduct(product);
Assert.Equal(1, sut.Products.Count);
Assert.Equal(product, sut.Products[0]);
}
```

تست، مجموعه Products را پس از تکمیل افزودن بررسی می‌کند. برخلاف مثال تست مبتنی بر خروجی در لیست 6.1، نتیجه AddProduct() تغییری است که در وضعیت سفارش ایجاد می‌شود.

# تعریف سبک مبتنی بر ارتباط

در نهایت، سبک سوم تست واحد، تست مبتنی بر ارتباط است. این سبک از mockها برای بررسی ارتباطات بین سیستم تحت تست و همکاران آن استفاده می‌کند (شکل 6.4).

<p align="center">
    <img src="../Part 6/figures/figure-6.4.png" />
</p>

هنوز ترجمه نشده

کد زیر یک مثال برای تست مبتنی بر حالت می‌باشد

```c#
[Fact]
public void Sending_a_greetings_email()
{
var emailGatewayMock = new Mock<IEmailGateway>();
var sut = new Controller(emailGatewayMock.Object);
sut.GreetUser("user@email.com");
emailGatewayMock.Verify(
x => x.SendGreetingsEmail("user@email.com"),
Times.Once);
}
```

# سبک‌ها و مکتب‌های تست واحد

مکتب کلاسیک تست واحد سبک مبتنی بر حالت را بر سبک مبتنی بر ارتباط ترجیح می‌دهد. مکتب لندن انتخاب مخالف را دارد. هر دو مکتب از تست مبتنی بر خروجی استفاده می‌کنند.

# مقایسه سه سبک تست واحد

تست‌های مبتنی بر خروجی، مبتنی بر حالت و مبتنی بر ارتباط چیز جدیدی نیستند. در واقع، قبلاً در این کتاب همه این سبک‌ها را دیده‌اید. نکته جالب، مقایسه آنها با یکدیگر با استفاده از چهار ویژگی یک تست واحد خوب است. این ویژگی‌ها عبارتند از:
• حفاظت در برابر بازگشت‌ها
• مقاومت در برابر تغییرات ساختاری
• بازخورد سریع
• قابلیت نگهداری

# مقایسه سبک‌ها با استفاده از معیارهای حفاظت در برابر بازگشت‌ها و سرعت بازخورد

ابتدا بیایید سه سبک را از نظر ویژگی‌های حفاظت در برابر بازگشت‌ها و سرعت بازخورد مقایسه کنیم، زیرا این ویژگی‌ها در این مقایسه خاص واضح‌تر هستند. معیار حفاظت در برابر بازگشت‌ها به سبک خاصی از تست وابسته نیست. این معیار حاصل سه ویژگی زیر است:
• مقدار کدی که در طول تست اجرا می‌شود
• پیچیدگی آن کد
• اهمیت حوزه آن
به طور کلی، می‌توانید تستی بنویسید که به اندازه دلخواه کد را اجرا کند؛ هیچ سبک خاصی در این زمینه مزیتی ندارد. همین موضوع برای پیچیدگی کد و اهمیت حوزه آن نیز صادق است. تنها استثنا سبک مبتنی بر ارتباط است: استفاده بیش از حد از آن می‌تواند به تست‌های سطحی منجر شود که تنها یک بخش کوچک از کد را بررسی می‌کنند و همه چیز دیگر را mock می‌کنند. این سطحی بودن، ویژگی قطعی تست مبتنی بر ارتباط نیست، بلکه یک مورد افراطی
از سوء استفاده از این تکنیک است.

# مقایسه سبک‌ها با استفاده از معیار مقاومت در برابر تغییرات ساختاری

در مورد معیار مقاومت در برابر بازسازی (Refactoring)، وضعیت متفاوت است. مقاومت در برابر بازسازی معیاری است برای سنجش تعداد مثبت‌های کاذب (آلارم‌های نادرست) که تست‌ها در طول بازسازی تولید می‌کنند. مثبت‌های کاذب به دلیل وابستگی تست‌ها به جزئیات پیاده‌سازی کد به جای رفتار قابل مشاهده، به وجود می‌آیند.

تست مبتنی بر خروجی بهترین محافظت را در برابر مثبت‌های کاذب ارائه می‌دهد، زیرا تست‌های نتیجه‌ای فقط به متدی که تحت تست است، وابسته هستند. تنها راهی که چنین تست‌هایی می‌توانند به جزئیات پیاده‌سازی وابسته شوند، این است که خود متدی که تحت تست است، یک جزئیات پیاده‌سازی باشد.

تست مبتنی بر حالت معمولاً بیشتر در معرض مثبت‌های کاذب قرار دارد. علاوه بر متدی که تحت تست است، چنین تست‌هایی با وضعیت (State) کلاس نیز کار می‌کنند. از نظر احتمالاتی، هرچه وابستگی بین تست و کد تولیدی بیشتر باشد، احتمال اینکه این تست به یک جزئیات پیاده‌سازی نشت کند، بیشتر است. تست‌های مبتنی بر حالت به سطح وسیع‌تری از API وابسته هستند و بنابراین احتمال وابستگی آنها به جزئیات پیاده‌سازی نیز بیشتر است.

تست مبتنی بر ارتباطات بیشتر از همه در معرض آلارم‌های نادرست قرار دارد. همانطور که از فصل ۵ به خاطر دارید، اکثریت تست‌هایی که تعاملات با جایگزین‌های تست (Test Doubles) را بررسی می‌کنند، شکننده هستند. این همیشه در مورد تعاملات با استاب‌ها صادق است - شما نباید هرگز چنین تعاملاتی را بررسی کنید. ماک‌ها (Mocks) فقط زمانی خوب هستند که تعاملاتی را که از مرزهای برنامه عبور می‌کنند و فقط زمانی که اثرات جانبی آن تعاملات برای دنیای خارج قابل مشاهده است، تأیید کنند. همانطور که می‌بینید، استفاده از تست مبتنی بر ارتباطات نیاز به دقت بیشتری دارد تا مقاومت مناسب در برابر بازسازی را حفظ کند.

اما همانند سطحی بودن، شکنندگی نیز ویژگی قطعی سبک تست مبتنی بر ارتباطات نیست. شما می‌توانید با حفظ پوشش مناسب و وابستگی تست‌ها به رفتار قابل مشاهده فقط، تعداد مثبت‌های کاذب را به حداقل برسانید. البته میزان دقت لازم بسته به سبک تست واحد، متفاوت است.

# مقایسه سبک‌ها با استفاده از معیار قابلیت نگهداری

در نهایت، معیار قابلیت نگهداری به شدت با سبک‌های تست واحد مرتبط است؛ اما برخلاف مقاومت در برابر بازسازی، کار زیادی برای کاهش آن نمی‌توانید انجام دهید. قابلیت نگهداری هزینه‌های نگهداری تست‌های واحد را ارزیابی می‌کند و با دو ویژگی زیر تعریف می‌شود:

میزان سختی درک تست، که تابعی از اندازه تست است.
میزان سختی اجرای تست، که تابعی از تعداد وابستگی‌های خارج از فرآیند است که تست به طور مستقیم با آنها کار می‌کند.
تست‌های بزرگ‌تر کمتر قابل نگهداری هستند زیرا درک یا تغییر آنها در صورت نیاز سخت‌تر است. به طور مشابه، تستی که به طور مستقیم با یک یا چند وابستگی خارج از فرآیند (مانند پایگاه داده) کار می‌کند، کمتر قابل نگهداری است زیرا نیاز به صرف زمان برای نگهداشتن آن وابستگی‌های خارج از فرآیند دارید: راه‌اندازی مجدد سرور پایگاه داده، حل مشکلات اتصال شبکه و غیره.

# قابلیت نگهداری تست‌های مبتنی بر خروجی

در مقایسه با دو نوع دیگر تست، تست مبتنی بر خروجی بیشترین قابلیت نگهداری را دارد. تست‌های حاصل تقریباً همیشه کوتاه و مختصر هستند و بنابراین نگهداری آنها آسان‌تر است. این مزیت سبک مبتنی بر خروجی از این واقعیت ناشی می‌شود که این سبک تنها به دو چیز نیاز دارد: ارائه یک ورودی به یک متد و تأیید خروجی آن، که اغلب می‌توان آن را با چند خط کد انجام داد.
از آنجا که کد زیرین در تست مبتنی بر خروجی نباید وضعیت جهانی یا داخلی را تغییر دهد، این تست‌ها با وابستگی‌های خارج از فرآیند سروکار ندارند. بنابراین، تست‌های مبتنی بر خروجی از نظر هر دو ویژگی قابلیت نگهداری بهترین هستند.

# قابلیت نگهداری تست‌های مبتنی بر حالت

تست‌های مبتنی بر حالت معمولاً کمتر از تست‌های مبتنی بر خروجی قابل نگهداری هستند. این به این دلیل است که تأیید حالت اغلب فضای بیشتری نسبت به تأیید خروجی می‌گیرد.

```c#
[Fact]
public void Adding_a_comment_to_an_article()
{
var sut = new Article();
var text = "Comment text";
var author = "John Doe";
var now = new DateTime(2019, 4, 1);
sut.AddComment(text, author, now);
Assert.Equal(1, sut.Comments.Count);
Assert.Equal(text, sut.Comments[0].Text);
Assert.Equal(author, sut.Comments[0].Author);
Assert.Equal(now, sut.Comments[0].DateCreated);
}
```

برای مثال، تستی که یک نظر را به یک مقاله اضافه می‌کند و سپس بررسی می‌کند که آیا نظر در لیست نظرات مقاله ظاهر می‌شود یا نه. هرچند این تست ساده شده است و تنها یک نظر دارد، قسمت تأییدیه آن در حال حاضر چهار خط را پوشش می‌دهد. تست‌های مبتنی بر حالت اغلب نیاز به تأیید داده‌های بیشتری دارند و بنابراین می‌توانند به طور قابل توجهی بزرگ شوند.

شما می‌توانید این مسئله را با معرفی متدهای کمکی که بیشتر کد را پنهان می‌کنند و در نتیجه تست را کوتاه‌تر می‌کنند، کاهش دهید، اما نوشتن و نگهداری این متدها نیاز به تلاش قابل توجهی دارد. این تلاش تنها زمانی موجه است که آن متدها قرار است در چندین تست استفاده شوند، که به ندرت اینگونه است.

```c#
[Fact]
public void Adding_a_comment_to_an_article()
{
var sut = new Article();
var text = "Comment text";
var author = "John Doe";
var now = new DateTime(2019, 4, 1);
sut.AddComment(text, author, now);
sut.ShouldContainNumberOfComments(1)
.WithComment(text, author, now);
}

```

روش دیگری برای کوتاه کردن تست مبتنی بر حالت، تعریف اعضای برابری در کلاسی است که در حال تأیید است. می‌توانید آن را به یک شیء مقدار (کلاسی که نمونه‌های آن بر اساس مقدار و نه مرجع مقایسه می‌شوند) تبدیل کنید؛ این کار نیز تست را ساده می‌کند، به ویژه اگر آن را با یک کتابخانه تأییدیه مانند Fluent Assertions ترکیب کنید.

```c#
[Fact]
public void Adding_a_comment_to_an_article()
{
var sut = new Article();
var comment = new Comment(
"Comment text",
"John Doe",
new DateTime(2019, 4, 1));
sut.AddComment(comment.Text, comment.Author, comment.DateCreated);
sut.Comments.Should().BeEquivalentTo(comment);
}

```

این تکنیک یک روش قدرتمند است، اما تنها زمانی کار می‌کند که کلاس ذاتاً یک مقدار باشد و بتوان آن را به یک شیء مقدار تبدیل کرد. در غیر این صورت، منجر به آلودگی کد می‌شود (آلودگی پایه کد تولید با کدی که تنها هدفش فعال‌سازی یا ساده‌سازی تست واحد است).

همانطور که می‌بینید، این دو تکنیک - استفاده از متدهای کمکی و تبدیل کلاس‌ها به اشیاء مقدار - تنها گاهی قابل اعمال هستند. و حتی زمانی که این تکنیک‌ها قابل اعمال باشند، تست‌های مبتنی بر حالت همچنان فضای بیشتری از تست‌های مبتنی بر خروجی می‌گیرند و بنابراین کمتر قابل نگهداری هستند.

# قابلیت نگهداری تست‌های مبتنی بر ارتباطات

تست‌های مبتنی بر ارتباطات از نظر قابلیت نگهداری نسبت به تست‌های مبتنی بر خروجی و حالت امتیاز کمتری می‌گیرند. تست‌های مبتنی بر ارتباطات نیاز به تنظیم جایگزین‌های تست و تأییدیه‌های تعامل دارند که فضای زیادی را اشغال می‌کند. تست‌ها حتی بزرگ‌تر و کمتر قابل نگهداری می‌شوند وقتی که زنجیره‌های ماک (ماک‌ها یا استاب‌هایی که ماک‌های دیگری را برمی‌گردانند و غیره) وجود دارند.

# مقایسه سبک‌ها: نتایج

بیایید اکنون سبک‌های تست واحد را با استفاده از ویژگی‌های یک تست واحد خوب مقایسه کنیم. تست‌های مبتنی بر خروجی بهترین نتایج را نشان می‌دهند. این سبک تست‌هایی تولید می‌کند که به ندرت به جزئیات پیاده‌سازی وابسته هستند و بنابراین نیازی به دقت زیادی برای حفظ مقاومت در برابر بازسازی ندارند. این تست‌ها نیز به دلیل کوتاهی و عدم وابستگی به فرآیندهای خارج از فرآیند، بیشترین قابلیت نگهداری را دارند.

<p align="center">
    <img src="../Part 6/figures/Table 6.1.png" />
</p>

هنوز ترجمه نشده

تست‌های مبتنی بر حالت و ارتباطات در هر دو معیار بدتر هستند. این تست‌ها بیشتر احتمال دارد که به جزئیات پیاده‌سازی نشت کنند و همچنین هزینه‌های نگهداری بیشتری به دلیل بزرگ‌تر بودن اندازه آنها دارند.

همیشه تست مبتنی بر خروجی را به هر چیز دیگری ترجیح دهید. متأسفانه، گفتن این کار آسان‌تر از انجام آن است. این سبک تست واحد تنها به کدی قابل اعمال است که به صورت تابعی نوشته شده باشد، که به ندرت در بیشتر زبان‌های برنامه‌نویسی شی‌گرا رخ می‌دهد. با این حال، تکنیک‌هایی وجود دارند که می‌توانید برای انتقال بیشتر تست‌های خود به سمت سبک مبتنی بر خروجی استفاده کنید.

بقیه این فصل نشان می‌دهد که چگونه می‌توان از تست مبتنی بر حالت و ارتباطات به تست مبتنی بر خروجی منتقل شد. این انتقال نیاز به کد تابعی‌تر دارد، که به نوبه خود امکان استفاده از تست‌های مبتنی بر خروجی را به جای تست‌های مبتنی بر حالت یا ارتباطات فراهم می‌کند.

# درک معماری تابعی

قبل از اینکه بتوانم نحوه انتقال را نشان دهم، نیاز به برخی پیش‌نیازها داریم. در این بخش، شما با برنامه‌نویسی تابعی و معماری تابعی آشنا خواهید شد و اینکه چگونه معماری تابعی به معماری شش‌ضلعی مرتبط است. در بخش 6.4، این انتقال با استفاده از یک مثال توضیح داده می‌شود.
توجه داشته باشید که این بخش، یک بررسی عمیق از موضوع برنامه‌نویسی تابعی نیست، بلکه توضیحی از اصول اولیه آن است. این اصول اولیه باید به اندازه‌ای کافی باشند که ارتباط بین برنامه‌نویسی تابعی و تست مبتنی بر خروجی را درک کنید. برای مطالعه بیشتر در مورد برنامه‌نویسی تابعی، به وب‌سایت و کتاب‌های Scott Wlaschin در https://fsharpforfunandprofit.com/books مراجعه کنید.

# برنامه‌نویسی تابعی چیست؟

همانطور که در بخش 6.1.1 اشاره کردم، سبک تست واحد مبتنی بر خروجی نیز به عنوان تست تابعی شناخته می‌شود. این به این دلیل است که این سبک تست نیاز دارد که کد تولیدی زیرساخت به صورت کاملاً تابعی نوشته شده باشد، با استفاده از برنامه‌نویسی تابعی. حال، برنامه‌نویسی تابعی چیست؟ برنامه‌نویسی تابعی، برنامه‌نویسی با استفاده از توابع ریاضی است. یک تابع ریاضی (که به عنوان تابع خالص نیز شناخته می‌شود)، تابعی (یا متد) است که هیچ ورودی یا خروجی پنهانی ندارد. تمام ورودی‌ها و خروجی‌های یک تابع ریاضی باید به‌صورت صریح در امضای متد (که شامل نام متد، آرگومان‌ها و نوع بازگشتی است) بیان شوند. یک تابع ریاضی برای یک ورودی معین، بدون توجه به اینکه چند بار فراخوانی شود، همیشه همان خروجی را تولید می‌کند.

بیایید متد CalculateDiscount() از فهرست 6.1 را به عنوان یک مثال در نظر بگیریم (برای سهولت آن را اینجا آورده‌ام):

```c#
 public decimal CalculateDiscount(Product[] products)
 {
 decimal discount = products.Length * 0.01m;
 return Math.Min(discount, 0.2m);
 }

```

این متد یک ورودی (یک آرایه از نوع Product) و یک خروجی (یک مقدار تخفیف از نوع decimal) دارد که هر دو به طور صریح در امضای متد بیان شده‌اند. هیچ ورودی یا خروجی پنهانی وجود ندارد. این ویژگی باعث می‌شود که متد CalculateDiscount() یک تابع ریاضی باشد (شکل 6.5).

<p align="center">
    <img src="../Part 6/figures/figure 6.5.png" />
</p>

متدهایی که هیچ ورودی و خروجی پنهانی ندارند به عنوان توابع ریاضی شناخته می‌شوند زیرا این متدها با تعریف تابع در ریاضیات همخوانی دارند.

تعریف: در ریاضیات، یک تابع یک رابطه بین دو مجموعه است که برای هر عنصر در مجموعه اول، دقیقاً یک عنصر در مجموعه دوم پیدا می‌کند. شکل 6.6 نشان می‌دهد که چگونه برای هر عدد ورودی
x، تابع𝑓(𝑥)=𝑥- 1

f(x)=x+1 یک عدد متناظر 𝑦
y را پیدا می‌کند. شکل 6.7 نیز متد CalculateDiscount() را با استفاده از همان نمادگذاری شکل 6.6 نمایش می‌دهد.

<p align="center">
    <img src="../Part 6/figures/figure 6.6.png" />
</p>

<p align="center">
    <img src="../Part 6/figures/figure 6.6.2.png" />
</p>

ورودی‌ها و خروجی‌های صریح، توابع ریاضی را بسیار قابل تست می‌کنند، زیرا تست‌های حاصل کوتاه، ساده، و به راحتی قابل فهم و نگهداری هستند. توابع ریاضی تنها نوع متدهایی هستند که می‌توان برای آنها از تست مبتنی بر خروجی استفاده کرد، که بهترین قابلیت نگهداری و کمترین احتمال ایجاد نتایج مثبت کاذب را دارد.

از سوی دیگر، ورودی‌ها و خروجی‌های پنهان باعث می‌شوند کد کمتر قابل تست باشد (و همچنین کمتر خوانا). انواع این ورودی‌ها و خروجی‌های پنهان شامل موارد زیر هستند:

عوارض جانبی: عوارض جانبی خروجی‌هایی هستند که در امضای متد بیان نشده‌اند و بنابراین پنهان هستند. یک عملیات زمانی عوارض جانبی ایجاد می‌کند که وضعیت یک نمونه کلاس را تغییر دهد، فایلی را روی دیسک به‌روزرسانی کند و غیره.
استثناء‌ها: وقتی یک متد استثناء‌ای را پرتاب می‌کند، یک مسیر در جریان برنامه ایجاد می‌کند که قرارداد تعیین‌شده توسط امضای متد را دور می‌زند. استثناء پرتاب شده می‌تواند در هر جایی از پشته فراخوانی گرفته شود و در نتیجه یک خروجی اضافی ایجاد می‌کند که در امضای متد نشان داده نشده است.
ارجاع به وضعیت داخلی یا خارجی: برای مثال، یک متد می‌تواند تاریخ و زمان فعلی را با استفاده از یک خاصیت ثابت مانند DateTime.Now دریافت کند. می‌تواند داده‌ها را از پایگاه داده واکشی کند، یا می‌تواند به یک فیلد قابل تغییر خصوصی ارجاع دهد. این‌ها همه ورودی‌هایی برای جریان اجرایی هستند که در امضای متد وجود ندارند و بنابراین پنهان هستند.
یک قاعده کلی برای تعیین اینکه آیا یک متد یک تابع ریاضی است یا خیر، این است که ببینید آیا می‌توانید فراخوانی آن متد را با مقدار بازگشتی آن جایگزین کنید بدون اینکه رفتار برنامه تغییر کند. قابلیت جایگزینی یک فراخوانی متد با مقدار متناظر آن به عنوان شفافیت ارجاعی شناخته می‌شود. به مثال زیر نگاه کنید:

```c#
 public int Increment(int x)
 {
 return x + 1;
 }

```

این متد یک تابع ریاضی است. این دو عبارت با هم معادل هستند:

```c#
 int y = Increment(4);
 int y = 5;

```

ز سوی دیگر، متد زیر یک تابع ریاضی نیست. شما نمی‌توانید آن را با مقدار بازگشتی جایگزین کنید، زیرا آن مقدار بازگشتی همه خروجی‌های متد را نمایندگی نمی‌کند. در این مثال، خروجی پنهان تغییر در فیلد x است (یک عارضه جانبی):

```c#
 int x = 0;
 public int Increment()
 {
 x++;
 return x;
 }

```

عارضه‌های جانبی رایج‌ترین نوع خروجی‌های پنهان هستند. فهرست زیر متدی به نام AddComment را نشان می‌دهد که در ظاهر شبیه به یک تابع ریاضی است اما در واقع اینگونه نیست. شکل 6.8 این متد را به صورت گرافیکی نمایش می‌دهد.

<p align="center">
    <img src="../Part 6/figures/figure 6.8.png" />
</p>

# معماری تابعی چیست؟

البته شما نمی‌توانید یک برنامه‌ای بسازید که به هیچ وجه عوارض جانبی ایجاد نکند. چنین برنامه‌ای غیرعملی خواهد بود. در نهایت، عوارض جانبی چیزی است که شما تمام برنامه‌ها را برای آن‌ها می‌سازید: به‌روزرسانی اطلاعات کاربر، اضافه کردن یک خط سفارش جدید به سبد خرید، و غیره.

هدف برنامه‌نویسی تابعی حذف کامل عوارض جانبی نیست، بلکه هدف آن جداسازی کدهایی است که با منطق کسب‌وکار سروکار دارند از کدهایی که عوارض جانبی ایجاد می‌کنند. این دو مسئولیت به خودی خود به اندازه کافی پیچیده هستند؛ ترکیب آن‌ها باعث افزایش پیچیدگی می‌شود و در درازمدت قابلیت نگهداری کد را کاهش می‌دهد. در اینجا است که معماری تابعی وارد عمل می‌شود. معماری تابعی منطق کسب‌وکار را از عوارض جانبی جدا می‌کند و این عوارض جانبی را به حاشیه‌های عملیات کسب‌وکار می‌راند.

تعریف: معماری تابعی حداکثر کد ممکن را به صورت کاملاً تابعی (تغییرناپذیر) می‌نویسد و در عین حال کدی که با عوارض جانبی سروکار دارد را به حداقل می‌رساند. تغییرناپذیر به معنای غیرقابل تغییر است: وقتی یک شیء ایجاد می‌شود، وضعیت آن نمی‌تواند تغییر کند. این برخلاف یک شیء تغییرپذیر (شیء قابل تغییر) است که پس از ایجاد می‌تواند تغییر کند.

جداسازی بین منطق کسب‌وکار و عوارض جانبی با تفکیک دو نوع کد انجام می‌شود:

کدی که تصمیم‌گیری می‌کند: این کد نیازی به عوارض جانبی ندارد و بنابراین می‌تواند با استفاده از توابع ریاضی نوشته شود.
کدی که بر اساس آن تصمیمات عمل می‌کند: این کد تمام تصمیمات گرفته‌شده توسط توابع ریاضی را به موارد قابل مشاهده مانند تغییرات در پایگاه داده یا پیام‌هایی که به یک اتوبوس (bus) ارسال می‌شوند، تبدیل می‌کند.
کدی که تصمیم‌گیری می‌کند، اغلب به عنوان هسته تابعی (همچنین به عنوان هسته تغییرناپذیر شناخته می‌شود) نامیده می‌شود. کدی که بر اساس آن تصمیمات عمل می‌کند، یک پوسته تغییرپذیر است (شکل 6.9).

<p align="center">
    <img src="../Part 6/figures/figure 6.9.png" />
</p>

همکاری هسته تابعی و پوسته قابل تغییر به این صورت است:

پوسته قابل تغییر تمام ورودی‌ها را جمع‌آوری می‌کند.
هسته تابعی تصمیم‌ها را تولید می‌کند.
پوسته این تصمیم‌ها را به عوارض جانبی تبدیل می‌کند.

برای حفظ جداسازی صحیح بین این دو لایه، باید مطمئن شوید که کلاس‌هایی که تصمیم‌ها را نمایندگی می‌کنند، اطلاعات کافی را برای پوسته قابل تغییر فراهم می‌کنند تا بدون نیاز به تصمیم‌گیری اضافی، بتواند بر اساس آن‌ها عمل کند. به عبارت دیگر، پوسته قابل تغییر باید تا حد امکان ساده و کم‌هوش باشد. هدف این است که هسته تابعی را با تست‌های مبتنی بر خروجی به طور گسترده پوشش دهید و پوسته قابل تغییر را به تعداد بسیار کمتری از تست‌های یکپارچه‌سازی محدود کنید.

کپسوله‌سازی و تغییرناپذیری
مانند کپسوله‌سازی، معماری تابعی (به طور کلی) و تغییرناپذیری (به طور خاص) همان هدف واحد تست را دنبال می‌کنند: امکان رشد پایدار پروژه نرم‌افزاری شما. در واقع، ارتباط عمیقی بین مفاهیم کپسوله‌سازی و تغییرناپذیری وجود دارد.

همان‌طور که از فصل ۵ به خاطر دارید، کپسوله‌سازی به معنای محافظت از کد شما در برابر ناسازگاری‌ها است. کپسوله‌سازی، بخش‌های داخلی کلاس را از فساد محافظت می‌کند، با:

کاهش سطح API که اجازه تغییر داده‌ها را می‌دهد.
قرار دادن API‌های باقی‌مانده تحت نظارت دقیق.
تغییرناپذیری این مسئله را از زاویه‌ای دیگر مورد بررسی قرار می‌دهد. با کلاس‌های تغییرناپذیر، شما نیازی به نگرانی درباره فساد وضعیت ندارید، زیرا چیزی که نمی‌توان آن را تغییر داد، امکان فساد ندارد. در نتیجه، در برنامه‌نویسی تابعی نیازی به کپسوله‌سازی نیست. شما فقط باید وضعیت کلاس را یک‌بار، زمانی که یک نمونه از آن ایجاد می‌کنید، اعتبارسنجی کنید. پس از آن، می‌توانید به راحتی این نمونه را منتقل کنید. زمانی که تمام داده‌های شما تغییرناپذیر هستند، تمام مسائل مربوط به نبود کپسوله‌سازی به سادگی ناپدید می‌شوند.

یک نقل‌قول عالی از مایکل فدرز در این زمینه وجود دارد: «برنامه‌نویسی شی‌گرا، کد را با کپسوله‌سازی اجزای متحرک قابل فهم می‌کند. برنامه‌نویسی تابعی، کد را با به حداقل رساندن اجزای متحرک قابل فهم می‌کند.»

# مقایسه معماری تابعی و معماری شش‌ضلعی

شباهت‌های زیادی بین معماری تابعی و معماری شش‌ضلعی وجود دارد. هر دوی آن‌ها بر اساس ایده جداسازی وظایف ساخته شده‌اند، اما جزئیات این جداسازی متفاوت است.

همانطور که در فصل 5 به خاطر دارید، معماری شش‌ضلعی بین لایه دامنه و لایه خدمات کاربردی تمایز قائل می‌شود (شکل 6.10). لایه دامنه مسئول منطق کسب‌وکار است در حالی که لایه خدمات کاربردی برای ارتباط با برنامه‌های خارجی مانند پایگاه داده یا سرویس SMTP استفاده می‌شود. این مشابه معماری تابعی است که در آن جداسازی تصمیمات و اقدامات معرفی می‌شود.

شباهت دیگر، جریان یک‌طرفه وابستگی‌ها است. در معماری شش‌ضلعی، کلاس‌های درون لایه دامنه باید فقط به یکدیگر وابسته باشند و نباید به کلاس‌های لایه خدمات کاربردی وابسته باشند. به همین ترتیب، هسته تغییرناپذیر در معماری تابعی به پوسته قابل تغییر وابسته نیست. این هسته خودکفا است و می‌تواند به صورت مستقل از لایه‌های خارجی عمل کند. این ویژگی باعث می‌شود که معماری تابعی بسیار قابل تست باشد: شما می‌توانید هسته تغییرناپذیر را به طور کامل از پوسته قابل تغییر جدا کنید و ورودی‌هایی که پوسته فراهم می‌کند را با مقادیر ساده شبیه‌سازی کنید.

تفاوت بین این دو معماری در نحوه برخورد آن‌ها با عوارض جانبی است. معماری تابعی تمام عوارض جانبی را از هسته تغییرناپذیر به لبه‌های عملیات کسب‌وکار منتقل می‌کند. این لبه‌ها توسط پوسته قابل تغییر مدیریت می‌شوند. از سوی دیگر، معماری شش‌ضلعی مشکلی با عوارض جانبی ایجاد شده توسط لایه دامنه ندارد، تا زمانی که این عوارض به همان لایه دامنه محدود شوند. تمام تغییرات در معماری شش‌ضلعی باید در داخل لایه دامنه باقی بمانند و از مرز این لایه عبور نکنند. برای مثال، یک نمونه کلاس دامنه نمی‌تواند مستقیماً چیزی را در پایگاه داده ذخیره کند، اما می‌تواند وضعیت خود را تغییر دهد. سپس یک سرویس کاربردی این تغییر را برداشته و آن را به پایگاه داده اعمال می‌کند.

نکته: معماری تابعی یک زیرمجموعه از معماری شش‌ضلعی است. شما می‌توانید معماری تابعی را به عنوان معماری شش‌ضلعی در حالت افراطی در نظر بگیرید.

<p align="center">
    <img src="../Part 6/figures/figure 6.10.png" />
</p>

# گذار به معماری تابعی و تست مبتنی بر خروجی

در این بخش، یک برنامه نمونه را انتخاب کرده و آن را به سمت معماری تابعی بازسازی می‌کنیم. شما دو مرحله بازسازی را مشاهده خواهید کرد:

انتقال از استفاده از وابستگی‌های خارج از فرآیند به استفاده از ماک‌ها (Mocks)
انتقال از استفاده از ماک‌ها به استفاده از معماری تابعی
این گذار بر کدهای تست نیز تأثیر خواهد گذاشت! ما تست‌های مبتنی بر وضعیت و ارتباط را به سبک تست واحد مبتنی بر خروجی بازسازی خواهیم کرد. قبل از شروع بازسازی، بیایید به بررسی پروژه نمونه و تست‌های مربوط به آن بپردازیم.

# معرفی یک سیستم حسابرسی

پروژه نمونه یک سیستم حسابرسی است که تمامی بازدیدکنندگان یک سازمان را پیگیری می‌کند. این سیستم از فایل‌های متنی ساده به عنوان ذخیره‌سازی اصلی استفاده می‌کند که ساختار آن در شکل 6.11 نشان داده شده است. سیستم نام بازدیدکننده و زمان بازدید او را به انتهای آخرین فایل اضافه می‌کند. زمانی که حداکثر تعداد ورودی‌های مجاز در هر فایل به دست می‌آید، یک فایل جدید با یک شاخص افزایشی ایجاد می‌شود.

<p align="center">
      <img src="../Part 6/figures/figure 6.11.png" />
" />
</p>

```c#
 public class AuditManager
 {
 private readonly int _maxEntriesPerFile;
 private readonly string _directoryName;
 public AuditManager(int maxEntriesPerFile, string directoryName)
 {
 _maxEntriesPerFile = maxEntriesPerFile;
 _directoryName = directoryName;
 }
 public void AddRecord(string visitorName, DateTime timeOfVisit)
 {
 string[] filePaths = Directory.GetFiles(_directoryName);
 (int index, string path)[] sorted = SortByIndex(filePaths);
 string newRecord = visitorName + ';' + timeOfVisit;
 if (sorted.Length == 0)
 {
 string newFile = Path.Combine(_directoryName, "audit_1.txt");
 File.WriteAllText(newFile, newRecord);
 return;
 }
 (int currentFileIndex, string currentFilePath) = sorted.Last();
 List<string> lines = File.ReadAllLines(currentFilePath).ToList();
 if (lines.Count < _maxEntriesPerFile)
 {
 lines.Add(newRecord);
 string newContent = string.Join("\r\n", lines);
 File.WriteAllText(currentFilePath, newContent);
 }
 else
 {
 int newIndex = currentFileIndex + 1;
 string newName = $"audit_{newIndex}.txt";
 string newFile = Path.Combine(_directoryName, newName);
 File.WriteAllText(newFile, newRecord);
 }
 }
 }

```

کد ممکن است کمی بزرگ به نظر برسد، اما در واقع بسیار ساده است. کلاس اصلی در این برنامه، AuditManager نام دارد. سازنده‌ی این کلاس، حداکثر تعداد ورودی‌ها در هر فایل و دایرکتوری کاری را به عنوان پارامترهای پیکربندی دریافت می‌کند. تنها متد عمومی در این کلاس AddRecord است که تمامی کارهای مربوط به سیستم حسابرسی را انجام می‌دهد:

لیست کامل فایل‌ها را از دایرکتوری کاری بازیابی می‌کند.
آن‌ها را بر اساس شاخص مرتب می‌کند (همه‌ی نام فایل‌ها از الگوی مشابهی پیروی می‌کنند: audit\_{index}.txt، مثلاً audit_1.txt).
اگر هنوز فایل‌های حسابرسی وجود نداشته باشد، یک فایل اولیه با یک رکورد ایجاد می‌کند.
اگر فایل‌های حسابرسی وجود داشته باشند، جدیدترین فایل را دریافت کرده و بسته به اینکه آیا تعداد ورودی‌های آن فایل به حد مجاز رسیده است یا نه، رکورد جدید را به آن اضافه می‌کند یا یک فایل جدید ایجاد می‌کند.
کلاس AuditManager به‌صورتی که هست، سخت برای تست‌نویسی است، زیرا به شدت به سیستم فایل وابسته است. قبل از انجام تست، باید فایل‌ها را در محل درست قرار دهید و بعد از اتمام تست، آن‌ها را بخوانید، محتوایشان را بررسی کنید و آن‌ها را پاک کنید (شکل 6.12).

<p align="center">
    <img src="../Part 6/figures/figure 6.12.png" />
</p>

امکان موازی‌سازی چنین تست‌هایی وجود نخواهد داشت—حداقل نه بدون تلاش اضافی که هزینه‌های نگهداری را به‌طور قابل‌توجهی افزایش می‌دهد. گلوگاه این موضوع سیستم فایل است: این یک وابستگی مشترک است که از طریق آن تست‌ها می‌توانند بر جریان اجرای یکدیگر تأثیر بگذارند.

سیستم فایل همچنین باعث کندی تست‌ها می‌شود. نگهداری نیز آسیب می‌بیند، زیرا شما باید اطمینان حاصل کنید که دایرکتوری کاری وجود دارد و برای تست‌ها قابل دسترسی است—هم در ماشین محلی شما و هم در سرور ساخت. جدول 6.2 خلاصه‌ای از امتیازات را ارائه می‌دهد.

<p align="center">
    <img src="../Part 6/figures/table 6.2.png" />
</p>

لازم به ذکر است که تست‌هایی که مستقیماً با سیستم فایل کار می‌کنند، در تعریف تست واحد قرار نمی‌گیرند. آن‌ها با دومین و سومین ویژگی تست واحد مطابقت ندارند، و در نتیجه در دسته‌ی تست‌های یکپارچه‌سازی قرار می‌گیرند (برای جزئیات بیشتر به فصل 2 مراجعه کنید):

یک تست واحد یک واحد رفتار را بررسی می‌کند،
این کار را سریع انجام می‌دهد،
و این کار را به‌صورت جدا از دیگر تست‌ها انجام می‌دهد.

# استفاده از Mockها برای جدا کردن تست‌ها از سیستم فایل

راه‌حل معمول برای مشکل تست‌های به‌شدت متصل، استفاده از Mock برای سیستم فایل است. شما می‌توانید تمامی عملیات روی فایل‌ها را به یک کلاس جداگانه (به‌عنوان مثال IFileSystem) منتقل کرده و این کلاس را از طریق سازنده به AuditManager تزریق کنید. سپس در تست‌ها، این کلاس Mock می‌شود و نوشتن‌های سیستم حسابرسی به فایل‌ها را ثبت می‌کند (شکل 6.13).

<p align="center">
    <img src="../Part 6/figures/figure 6.13.png" />
</p>

لیست زیر نشان می‌دهد که چگونه سیستم فایل به AuditManager تزریق می‌شود.

```c#
 public class AuditManager
 {
 private readonly int _maxEntriesPerFile;
 private readonly string _directoryName;
 private readonly IFileSystem _fileSystem;
public AuditManager(
 int maxEntriesPerFile,
 string directoryName,
 IFileSystem fileSystem)
 {
 _maxEntriesPerFile = maxEntriesPerFile;
 _directoryName = directoryName;
 _fileSystem = fileSystem;
}
 }

```

سپس متد AddRecord می‌آید.

```c#
 public void AddRecord(string visitorName, DateTime timeOfVisit)
 {
 string[] filePaths = _fileSystem
.GetFiles(_directoryName);
(int index, string path)[] sorted = SortByIndex(filePaths);

 string newRecord = visitorName + ';' + timeOfVisit;
 if (sorted.Length == 0)
 {
 string newFile = Path.Combine(_directoryName, "audit_1.txt");
 _fileSystem.WriteAllText(
newFile, newRecord);
return;
 }

 (int currentFileIndex, string currentFilePath) = sorted.Last();
 List<string> lines = _fileSystem
.ReadAllLines(currentFilePath);
if (lines.Count < _maxEntriesPerFile)
 {
 lines.Add(newRecord);
 string newContent = string.Join("\r\n", lines);
 _fileSystem.WriteAllText(
currentFilePath, newContent);
}
 else
 {
 int newIndex = currentFileIndex + 1;
 string newName = $"audit_{newIndex}.txt";
 string newFile = Path.Combine(_directoryName, newName);
 _fileSystem.WriteAllText(
newFile, newRecord);
}
 }

```

در لیست 6.10، IFileSystem یک رابط سفارشی جدید است که کار با سیستم فایل را کپسوله می‌کند

```c#
 public interface IFileSystem
 {
 string[] GetFiles(string directoryName);
 void WriteAllText(string filePath, string content);
 List<string> ReadAllLines(string filePath);
 }

```

حالا که AuditManager از سیستم فایل جدا شده است، وابستگی مشترک از بین رفته و تست‌ها می‌توانند به‌صورت مستقل از یکدیگر اجرا شوند. در اینجا یکی از این تست‌ها آمده است.

```c#
 [Fact]
 public void A_new_file_is_created_when_the_current_file_overflows()
 {
 var fileSystemMock = new Mock<IFileSystem>();
 fileSystemMock
 .Setup(x => x.GetFiles("audits"))
 .Returns(new string[]
 {
 @"audits\audit_1.txt",
 @"audits\audit_2.txt"
 });
 fileSystemMock
 .Setup(x => x.ReadAllLines(@"audits\audit_2.txt"))
 .Returns(new List<string>
 {
 "Peter; 2019-04-06T16:30:00",
 "Jane; 2019-04-06T16:40:00",

  "Jack; 2019-04-06T17:00:00"
 });
 var sut = new AuditManager(3, "audits", fileSystemMock.Object);
 sut.AddRecord("Alice", DateTime.Parse("2019-04-06T18:00:00"));
 fileSystemMock.Verify(x => x.WriteAllText(
 @"audits\audit_3.txt",
 "Alice;2019-04-06T18:00:00"));
 }
```

ین تست بررسی می‌کند که وقتی تعداد ورودی‌ها در فایل جاری به حد مجاز (در این مثال 3) می‌رسد، یک فایل جدید با یک ورودی حسابرسی ایجاد می‌شود. توجه داشته باشید که این یک استفاده قانونی از Mockهاست. برنامه فایل‌هایی ایجاد می‌کند که برای کاربران نهایی قابل مشاهده است (با فرض اینکه آن کاربران از برنامه دیگری برای خواندن فایل‌ها استفاده می‌کنند، خواه یک نرم‌افزار تخصصی باشد یا یک برنامه ساده مثل notepad.exe). بنابراین، ارتباطات با سیستم فایل و تأثیرات جانبی این ارتباطات (یعنی تغییرات در فایل‌ها) بخشی از رفتار قابل مشاهده برنامه است. همان‌طور که ممکن است از فصل 5 به یاد داشته باشید، این تنها مورد استفاده قانونی از Mockهاست.

این پیاده‌سازی جایگزین نسبت به نسخه اولیه بهبود یافته است. از آنجایی که تست‌ها دیگر به سیستم فایل دسترسی ندارند، سریع‌تر اجرا می‌شوند. و چون دیگر نیازی به مراقبت از سیستم فایل برای راضی نگه‌داشتن تست‌ها ندارید، هزینه‌های نگهداری نیز کاهش می‌یابد. حفاظت در برابر رگرسیون و مقاومت در برابر بازسازی نیز از این بازسازی آسیب ندیده است. جدول 6.3 تفاوت‌های بین دو نسخه را نشان می‌دهد.

<p align="center">
    <img src="../Part 6/figures/Table 6.3.png" />
</p>

با این حال، ما هنوز می‌توانیم بهتر عمل کنیم. تست در لیست 6.11 شامل تنظیمات پیچیده‌ای است که از نظر هزینه‌های نگهداری ایده‌آل نیست. کتابخانه‌های Mock تمام تلاش خود را می‌کنند که کمک‌کننده باشند، اما تست‌های حاصل همچنان به اندازه تست‌هایی که بر اساس ورودی و خروجی ساده تکیه دارند، خوانا نیستند.

# بازسازی به سوی معماری تابعی

به جای پنهان کردن اثرات جانبی پشت یک رابط و تزریق آن رابط به AuditManager، می‌توانید این اثرات جانبی را کاملاً از کلاس خارج کنید. در این حالت، AuditManager تنها مسئول تصمیم‌گیری در مورد نحوه کار با فایل‌ها خواهد بود. یک کلاس جدید به نام Persister این تصمیم را اعمال کرده و به‌روزرسانی‌هایی را به سیستم فایل وارد می‌کند (شکل 6.14).

<p align="center">
    <img src="../Part 6/figures/figure 6.14.png" />
</p>

در این سناریو، Persister به عنوان یک پوسته قابل تغییر عمل می‌کند، در حالی که AuditManager به هسته تابعی (غیرقابل تغییر) تبدیل می‌شود. لیست زیر AuditManager را پس از بازسازی نشان می‌دهد

```c#
 public class AuditManager
 {
 private readonly int _maxEntriesPerFile;
 public AuditManager(int maxEntriesPerFile)
 {
 _maxEntriesPerFile = maxEntriesPerFile;
 }
 public FileUpdate AddRecord(
 FileContent[] files,
 string visitorName,
 DateTime timeOfVisit)
 {
 (int index, FileContent file)[] sorted = SortByIndex(files);
 string newRecord = visitorName + ';' + timeOfVisit;
 if (sorted.Length == 0)
 {
 return new FileUpdate(
"audit_1.txt", newRecord);
}
 Returns an update
instruction
 (int currentFileIndex, FileContent currentFile) = sorted.Last();
 List<string> lines = currentFile.Lines.ToList();
 if (lines.Count < _maxEntriesPerFile)
 {
 lines.Add(newRecord);
 string newContent = string.Join("\r\n", lines);
 return new FileUpdate(
currentFile.FileName, newContent);
}
 else
 {
 int newIndex = currentFileIndex + 1;
 string newName = $"audit_{newIndex}.txt";
 return new FileUpdate(
newName, newRecord);
}
 }
 }

```

به جای مسیر دایرکتوری کاری، AuditManager اکنون یک آرایه از FileContent را دریافت می‌کند. این کلاس شامل تمامی اطلاعاتی است که AuditManager نیاز دارد تا در مورد سیستم فایل تصمیم‌گیری کند:

```c#
 public class FileContent
 {
 public readonly string FileName;
 public readonly string[] Lines;
 public FileContent(string fileName, string[] lines)
 {
 FileName = fileName;
 Lines = lines;
 }
 }
```

و به جای تغییر فایل‌ها در دایرکتوری کاری، AuditManager اکنون یک دستورالعمل برای اثر جانبی که می‌خواهد انجام دهد، برمی‌گرداند:

```c#
 public class FileUpdate
 {
 public readonly string FileName;
 public readonly string NewContent;
 public FileUpdate(string fileName, string newContent)
 {
 FileName = fileName;
 NewContent = newContent;
 }
 }
```

لیست زیر کلاس Persister را نشان می‌دهد.

```c#
 public class Persister
 {
 public FileContent[] ReadDirectory(string directoryName)
 {
 return Directory
 .GetFiles(directoryName)
 .Select(x => new FileContent(
 Path.GetFileName(x),
 File.ReadAllLines(x)))
 .ToArray();
 }
 public void ApplyUpdate(string directoryName, FileUpdate update)
 {
 string filePath = Path.Combine(directoryName, update.FileName);
 File.WriteAllText(filePath, update.NewContent);
 }
 }
```

توجه کنید که این کلاس چقدر ساده است. تنها کاری که انجام می‌دهد این است که محتوا را از دایرکتوری کاری می‌خواند و به‌روزرسانی‌هایی را که از AuditManager دریافت می‌کند، به دایرکتوری کاری اعمال می‌کند. هیچ نوع branching (شامل دستورات if) وجود ندارد؛ تمام پیچیدگی در کلاس AuditManager قرار دارد. این همان تفکیک بین منطق تجاری و اثرات جانبی است که در عمل مشاهده می‌شود.

برای حفظ چنین تفکیکی، باید رابط‌های FileContent و FileUpdate را تا حد ممکن نزدیک به دستورات داخلی فایل‌سازی چارچوب نگه‌دارید. تمام تجزیه و آماده‌سازی باید در هسته تابعی انجام شود تا کد خارج از آن هسته ساده باقی بماند. به عنوان مثال، اگر .NET شامل متد داخلی File.ReadAllLines() که محتویات فایل را به صورت آرایه‌ای از خطوط برمی‌گرداند نبود و فقط File.ReadAllText() وجود داشت که یک رشته واحد برمی‌گرداند، باید خصوصیت Lines در FileContent را با یک رشته جایگزین کرده و تجزیه را در AuditManager انجام دهید:

```c#
 public class FileContent
 {
 public readonly string FileName;
 public readonly string Text; // previously, string[] Lines;
 }
```

برای پیوند دادن AuditManager و Persister، به یک کلاس دیگر نیاز دارید: یک سرویس کاربردی در طبقه‌بندی معماری شش‌ضلعی، که در لیست زیر نشان داده شده است.

```c#
public class ApplicationService
 {
 private readonly string _directoryName;
 private readonly AuditManager _auditManager;
 private readonly Persister _persister;
  public ApplicationService(
 string directoryName, int maxEntriesPerFile)
 {
 _directoryName = directoryName;
 _auditManager = new AuditManager(maxEntriesPerFile);
 _persister = new Persister();
 }
 public void AddRecord(string visitorName, DateTime timeOfVisit)
 {
 FileContent[] files = _persister.ReadDirectory(_directoryName);
 FileUpdate update = _auditManager.AddRecord(
 files, visitorName, timeOfVisit);
 _persister.ApplyUpdate(_directoryName, update);
 }
 }

```

همراه با پیوند دادن هسته تابعی با پوسته قابل تغییر، سرویس کاربردی همچنین یک نقطه ورود به سیستم برای مشتریان خارجی فراهم می‌کند (شکل 6.15). با این پیاده‌سازی، بررسی رفتار سیستم حسابرسی بسیار ساده می‌شود. تمام تست‌ها اکنون به تأمین حالت فرضی دایرکتوری کاری و تأیید تصمیمی که AuditManager می‌سازد، کاهش می‌یابند.

<p align="center">
    <img src="../Part 6/figures/figure 6.15.png" />
</p>

```c#
 [Fact]
 public void A_new_file_is_created_when_the_current_file_overflows()
 {
 var sut = new AuditManager(3);
 var files = new FileContent[]
 {
 new FileContent("audit_1.txt", new string[0]),

  new FileContent("audit_2.txt", new string[]
 {
 "Peter; 2019-04-06T16:30:00",
 "Jane; 2019-04-06T16:40:00",
 "Jack; 2019-04-06T17:00:00"
 })
 };
 FileUpdate update = sut.AddRecord(
 files, "Alice", DateTime.Parse("2019-04-06T18:00:00"));
 Assert.Equal("audit_3.txt", update.FileName);
 Assert.Equal("Alice;2019-04-06T18:00:00", update.NewContent);
 }

```

این تست بهبودهایی را که تست با Mock نسبت به نسخه اولیه ارائه داد (بازخورد سریع) حفظ می‌کند، اما همچنین معیار نگهداری را بیشتر بهبود می‌بخشد. دیگر نیازی به تنظیمات پیچیده Mock نیست، تنها ورودی‌ها و خروجی‌های ساده وجود دارد که خوانایی تست را به طور قابل توجهی کمک می‌کند. جدول 6.4 مقایسه‌ای بین تست مبتنی بر خروجی با نسخه اولیه و نسخه با Mockها ارائه می‌دهد.

<p align="center">
    <img src="../Part 6/figures/Table 6.4.png" />
</p>

توجه داشته باشید که دستورالعمل‌های تولید شده توسط هسته تابعی همیشه یک مقدار یا مجموعه‌ای از مقادیر هستند. دو نمونه از چنین مقداری به شرطی که محتوای آن‌ها مطابقت داشته باشد، قابل تعویض هستند. می‌توانید از این واقعیت بهره ببرید و خوانایی تست را حتی بیشتر با تبدیل FileUpdate به یک شیء مقداری (value object) بهبود بخشید. برای انجام این کار در .NET، باید یا کلاس را به یک struct تبدیل کنید یا اعضای برابری سفارشی تعریف کنید. این کار مقایسه بر اساس مقدار را فراهم می‌کند، برخلاف مقایسه بر اساس مرجع که رفتار پیش‌فرض برای کلاس‌ها در C# است. مقایسه بر اساس مقدار همچنین به شما امکان می‌دهد که دو اثبات از لیست 6.15 را به یک اثبات فشرده کنید.

```c#
 Assert.Equal(
 new FileUpdate("audit_3.txt", "Alice;2019-04-06T18:00:00"),
 update);

  update.Should().Be(
 new FileUpdate("audit_3.txt", "Alice;2019-04-06T18:00:00"));
```

# نگاهی به توسعه‌های آتی

بیایید برای یک لحظه از پروژه نمونه‌ای که به شما نشان دادم، فاصله بگیریم و به توسعه‌های آتی احتمالی آن بپردازیم. سیستم حسابرسی که نشان دادم، نسبتاً ساده است و تنها شامل سه شاخه است:

ایجاد یک فایل جدید در صورت خالی بودن دایرکتوری کاری
افزودن یک رکورد جدید به یک فایل موجود
ایجاد یک فایل جدید وقتی که تعداد ورودی‌ها در فایل فعلی از حد مجاز فراتر می‌رود
همچنین، فقط یک مورد استفاده وجود دارد: افزودن یک ورودی جدید به لاگ حسابرسی. حالا اگر مورد استفاده دیگری وجود داشته باشد، مانند حذف تمام اشاره‌ها به یک بازدیدکننده خاص چه؟ و اگر سیستم نیاز به انجام اعتبارسنجی (مثلاً برای حداکثر طول نام بازدیدکننده) داشته باشد، چه؟ حذف تمام اشاره‌ها به یک بازدیدکننده خاص می‌تواند چندین فایل را تحت تأثیر قرار دهد، بنابراین متد جدید باید چندین دستور فایل را برگرداند:

```c#
public FileUpdate[] DeleteAllMentions(FileContent[] files, string visitorName)

```

علاوه بر این، ممکن است مدیران کسب‌وکار بخواهند که فایل‌های خالی را در دایرکتوری کاری نگهداری نکنید. اگر ورودی حذف شده آخرین ورودی در یک فایل حسابرسی بود، باید آن فایل را به‌طور کامل حذف کنید. برای پیاده‌سازی این نیاز، می‌توانید FileUpdate را به FileAction تغییر نام داده و یک فیلد اضافی از نوع ActionType برای نشان دادن اینکه عمل به‌روزرسانی یا حذف است، معرفی کنید.

مدیریت خطاها نیز با معماری تابعی ساده‌تر و واضح‌تر می‌شود. می‌توانید خطاها را در امضای متد گنجانید، یا در کلاس FileUpdate یا به‌عنوان یک جزء جداگانه:

```c#
public (FileUpdate update, Error error) AddRecord(
    FileContent[] files,
    string visitorName,
    DateTime timeOfVisit)

```

سرویس برنامه سپس برای این خطا بررسی می‌کند. اگر خطا وجود داشت، سرویس دستور به‌روزرسانی را به ذخیره‌کننده ارسال نمی‌کند و به‌جای آن پیام خطا را به کاربر منتقل می‌کند.

# بررسی معایب معماری تابعی

متأسفانه، معماری تابعی همیشه قابل دستیابی نیست. و حتی زمانی که قابل دستیابی است، مزایای نگهداری کد اغلب با تأثیر بر عملکرد و افزایش اندازه کد متعادل می‌شود. در این بخش، هزینه‌ها و trade-off‌های مربوط به معماری تابعی را بررسی خواهیم کرد.

# قابلیت اعمال معماری تابعی

معماری تابعی برای سیستم حسابرسی ما کار کرد زیرا این سیستم می‌توانست تمام ورودی‌ها را پیشاپیش جمع‌آوری کند، پیش از اتخاذ تصمیم. اما اغلب، جریان اجرای کد کمتر قابل پیش‌بینی است. ممکن است نیاز به پرسش داده‌های اضافی از یک وابستگی بیرونی، بر اساس نتیجه میانی از فرآیند تصمیم‌گیری داشته باشید.

برای مثال، فرض کنید که سیستم حسابرسی نیاز به بررسی سطح دسترسی بازدیدکننده داشته باشد اگر تعداد دفعات بازدید آن‌ها در ۲۴ ساعت گذشته از یک آستانه خاص تجاوز کند. و فرض کنید که همه سطوح دسترسی بازدیدکنندگان در یک پایگاه داده ذخیره شده‌اند. شما نمی‌توانید یک نمونه IDatabase را به AuditManager به این صورت منتقل کنید:

```c#
public void AddRecord(FileContent[] files, string visitorName, DateTime timeOfVisit, IDatabase database)

```

چنین نمونه‌ای ورودی پنهانی به متد AddRecord() معرفی می‌کند. این متد بنابراین دیگر یک تابع ریاضی نخواهد بود، که به این معناست که نمی‌توانید تست‌های مبتنی بر خروجی را به‌طور کامل اعمال کنید.

<p align="center">
    <img src="../Part 6/figures/figure 6.16.png" />
</p>

دو راه‌حل در چنین وضعیتی وجود دارد:

می‌توانید سطح دسترسی بازدیدکننده را از قبل در سرویس برنامه جمع‌آوری کنید، همراه با محتوای دایرکتوری.
می‌توانید متدی جدید مانند IsAccessLevelCheckRequired() در AuditManager معرفی کنید. سرویس برنامه قبل از AddRecord() این متد را فراخوانی می‌کند و اگر true برگشت، سرویس سطح دسترسی را از پایگاه داده می‌گیرد و به AddRecord() منتقل می‌کند.
هر دو رویکرد دارای معایب هستند. رویکرد اول به عملکرد آسیب می‌زند—به‌طور غیرمشروط پایگاه داده را حتی در مواردی که سطح دسترسی لازم نیست، جستجو می‌کند. اما این رویکرد جداسازی منطق کسب‌وکار و ارتباط با سیستم‌های خارجی را کاملاً حفظ می‌کند: تمام تصمیم‌گیری‌ها در AuditManager انجام می‌شود. رویکرد دوم برای بهبود عملکرد، به جداسازی درجه‌ای از آن آسیب می‌زند: تصمیم به فراخوانی پایگاه داده اکنون به سرویس برنامه منتقل می‌شود، نه به AuditManager.

همکاران در برابر مقادیر
شاید متوجه شده‌اید که متد AddRecord() در AuditManager وابستگی‌ای دارد که در امضای آن وجود ندارد: فیلد \_maxEntriesPerFile. مدیر حسابرسی به این فیلد برای تصمیم‌گیری در مورد اینکه آیا باید یک فایل موجود را به‌روزرسانی کند یا یک فایل جدید ایجاد کند، اشاره می‌کند.

این وابستگی که در میان پارامترهای متد وجود ندارد، پنهان نیست. می‌توان آن را از امضای سازنده کلاس به‌دست آورد. و چون فیلد \_maxEntriesPerFile غیرقابل تغییر است، بین نمونه‌سازی کلاس و فراخوانی AddRecord() ثابت می‌ماند. به عبارت دیگر، این فیلد یک مقدار است.

وضعیت با وابستگی IDatabase متفاوت است، زیرا یک همکار است، نه یک مقدار مانند \_maxEntriesPerFile`. همان‌طور که در فصل ۲ یادآوری شد، یک همکار یک وابستگی است که یکی از موارد زیر است:

تغییرپذیر (اجازه تغییر وضعیت آن را می‌دهد)
یک نماینده برای داده‌هایی که هنوز در حافظه نیستند (وابستگی مشترک)
نمونه IDatabase به دسته دوم تعلق دارد و بنابراین یک همکار است. نیاز به تماس اضافی با وابستگی بیرونی دارد و بنابراین استفاده از تست‌های مبتنی بر خروجی را غیرممکن می‌سازد.

توجه: یک کلاس از هسته تابعی نباید با یک همکار کار کند، بلکه باید با محصول کار خود، یعنی یک مقدار، کار کند.

# معایب عملکرد

تأثیر عملکرد بر کل سیستم، یک استدلال رایج در برابر معماری تابعی است. توجه داشته باشید که این تأثیر به عملکرد تست‌ها مربوط نمی‌شود. تست‌های مبتنی بر خروجی که در نهایت به آن‌ها رسیدیم، به اندازه تست‌های با mocks سریع هستند. بلکه این است که سیستم خود اکنون باید تماس‌های بیشتری به وابستگی‌های بیرونی انجام دهد و از نظر عملکرد کمتر موثر است. نسخه اولیه سیستم حسابرسی تمام فایل‌ها را از دایرکتوری کاری نمی‌خواند، و نسخه با mocks نیز همین‌طور بود. اما نسخه نهایی این کار را انجام می‌دهد تا با رویکرد "خواندن-تصمیم‌گیری-عمل" سازگار شود.

انتخاب بین معماری تابعی و معماری سنتی‌تر یک trade-off بین عملکرد و نگهداری کد (هم کد تولید و هم کد تست) است. در برخی سیستم‌ها که تأثیر عملکرد قابل توجه نیست، بهتر است با معماری تابعی برای دستیابی به مزایای اضافی در نگهداری کد بروید. در دیگر موارد، ممکن است نیاز به انتخاب معکوس داشته باشید. هیچ راه‌حل یکسانی برای همه وجود ندارد.

# افزایش اندازه کد

این موضوع در مورد اندازه کد نیز صادق است. معماری تابعی نیاز به جداسازی واضح بین هسته تابعی (غیرقابل تغییر) و پوسته قابل تغییر دارد. این امر نیاز به کدنویسی اضافی در ابتدا دارد، هرچند که در نهایت منجر به کاهش پیچیدگی کد و افزایش نگهداری آن می‌شود.

تمام پروژه‌ها میزان پیچیدگی بالایی ندارند که چنین سرمایه‌گذاری اولیه‌ای توجیه‌پذیر باشد. برخی کدها از نظر کسب‌وکار آن‌قدر مهم نیستند یا به سادگی خیلی ساده هستند. استفاده از معماری تابعی در چنین پروژه‌هایی منطقی نیست، زیرا سرمایه‌گذاری اولیه هرگز جبران نخواهد شد. همیشه معماری تابعی را به‌صورت استراتژیک اعمال کنید و پیچیدگی و اهمیت سیستم خود را در نظر بگیرید.

در نهایت، به دنبال خلوص کامل رویکرد تابعی نباشید اگر این خلوص هزینه زیادی به همراه داشته باشد. در بیشتر پروژه‌ها، نمی‌توانید مدل دامنه را به‌طور کامل غیرقابل تغییر کنید و بنابراین نمی‌توانید به‌طور کامل به تست‌های مبتنی بر خروجی تکیه کنید، حداقل نه زمانی که از زبان‌های شی‌گرا مانند C# یا Java استفاده می‌کنید.در بیشتر موارد، شما ترکیبی از سبک‌های مبتنی بر خروجی و مبتنی بر حالت را خواهید داشت، با کمی تست‌های مبتنی بر ارتباط، و این کاملاً مناسب است. هدف این فصل این نیست که شما را به انتقال تمام تست‌هایتان به سبک مبتنی بر خروجی ترغیب کند؛ هدف این است که هر چه بیشتر از آن‌ها را به این سبک منتقل کنید که به‌طور منطقی امکان‌پذیر است. تفاوت این موضوع جزئی اما مهم است.

# خلاصه

تست‌های مبتنی بر خروجی: این سبک تست به این صورت است که ورودی را به سیستم تحت تست (SUT) می‌دهید و خروجی‌ای که تولید می‌شود را بررسی می‌کنید. این سبک تست فرض می‌کند که ورودی‌ها و خروجی‌های پنهانی وجود ندارد و تنها نتیجه کار SUT، مقداری است که بازمی‌گرداند.

تست‌های مبتنی بر حالت: این نوع تست، وضعیت سیستم را پس از انجام یک عملیات بررسی می‌کند.

تست‌های مبتنی بر ارتباط: در این تست‌ها، از mocks استفاده می‌شود تا ارتباطات بین سیستم تحت تست و همکاران آن را بررسی کنید.

مدرسه کلاسیک تست واحد: این مدرسه بیشتر به سبک تست مبتنی بر حالت ترجیح می‌دهد. در حالی که مدرسه لندن برعکس آن را ترجیح می‌دهد. هر دو مدرسه از تست‌های مبتنی بر خروجی استفاده می‌کنند.

کیفیت تست‌های مبتنی بر خروجی: این تست‌ها معمولاً کیفیت بالایی دارند و به جزئیات پیاده‌سازی وابسته نیستند، بنابراین در برابر تغییرات مقاوم هستند. آن‌ها همچنین کوچک و مختصرند و بنابراین نگهداری‌شان راحت‌تر است.

تست‌های مبتنی بر حالت: این تست‌ها نیاز به دقت بیشتری دارند تا از شکنندگی جلوگیری شود. باید مطمئن شوید که وضعیت خصوصی را برای تست واحد افشا نمی‌کنید. چون تست‌های مبتنی بر حالت معمولاً بزرگ‌تر از تست‌های مبتنی بر خروجی هستند، نگهداری آنها نیز سخت‌تر است. مشکلات نگهداری را می‌توان با استفاده از متدهای کمکی و اشیاء ارزش کاهش داد، اما به‌طور کامل برطرف نمی‌شود.

تست‌های مبتنی بر ارتباط: این تست‌ها نیز نیاز به دقت بیشتری دارند تا از شکنندگی جلوگیری شود. فقط باید ارتباطاتی که از مرزهای برنامه عبور می‌کنند و تأثیرات جانبی آن‌ها به دنیای بیرون قابل مشاهده است، بررسی کنید. نگهداری تست‌های مبتنی بر ارتباط بدتر از تست‌های مبتنی بر خروجی و حالت است. mocks معمولاً فضای زیادی را اشغال می‌کنند که باعث می‌شود تست‌ها کمتر قابل خواندن باشند.

برنامه‌نویسی تابعی: برنامه‌نویسی با استفاده از توابع ریاضی است.

توابع ریاضی: تابعی است که هیچ ورودی یا خروجی پنهانی ندارد. تأثیرات جانبی و استثناها خروجی‌های پنهان هستند. ارجاع به وضعیت داخلی یا خارجی ورودی پنهان است. توابع ریاضی صریح هستند که آن‌ها را بسیار قابل تست می‌کند.

هدف برنامه‌نویسی تابعی: معرفی جداسازی بین منطق کسب‌وکار و تأثیرات جانبی است.

معماری تابعی: این معماری به دستیابی به جداسازی با انتقال تأثیرات جانبی به لبه‌های یک عملیات تجاری کمک می‌کند. این رویکرد مقدار کد نوشته شده به صورت کاملاً تابعی را به حداکثر می‌رساند و در عین حال کد مربوط به تأثیرات جانبی را به حداقل می‌رساند.

تقسیم کد در معماری تابعی: معماری تابعی همه کدها را به دو دسته تقسیم می‌کند: هسته تابعی و پوسته قابل تغییر. هسته تابعی تصمیمات را اتخاذ می‌کند. پوسته قابل تغییر داده‌های ورودی را به هسته تابعی تأمین می‌کند و تصمیمات هسته را به تأثیرات جانبی تبدیل می‌کند.

تفاوت بین معماری تابعی و هگزagonal: تفاوت در نحوه برخورد با تأثیرات جانبی است. معماری تابعی تمام تأثیرات جانبی را از لایه دامنه خارج می‌کند. در مقابل، معماری هگزagonal با تأثیرات جانبی که توسط لایه دامنه انجام می‌شود، مشکلی ندارد، به شرطی که این تأثیرات محدود به همان لایه دامنه باشد. معماری تابعی، معماری هگزagonal را به شدت بیشتری می‌برد.

انتخاب بین معماری تابعی و سنتی‌تر: این انتخاب یک trade-off بین عملکرد و نگهداری کد است. معماری تابعی برای مزایای نگهداری به هزینه عملکرد تن می‌دهد.

قابلیت تبدیل کد به معماری تابعی: تمام کدها ارزش تبدیل به معماری تابعی را ندارند. معماری تابعی را به صورت استراتژیک اعمال کنید. پیچیدگی و اهمیت سیستم خود را در نظر بگیرید. در کدهایی که ساده یا از نظر کسب‌وکار اهمیت زیادی ندارند، سرمایه‌گذاری اولیه برای معماری تابعی توجیه‌پذیر نخواهد بود.

</div>

<div dir='rtl'>

# انواع تست واحد

فصل چهارم به چهار ویژگی یک تست واحد خوب اشاره کرد: حفاظت در برابر بازگشت‌ها، مقاومت در برابر تغییرات ساختاری، بازخورد سریع و قابلیت نگهداری. این ویژگی‌ها چارچوبی را تشکیل می‌دهند که می‌توانید از آن برای تحلیل تست‌های خاص و رویکردهای تست واحد استفاده کنید. در فصل پنج، یکی از این رویکردها، استفاده از mock‌ها را تحلیل کردیم.
در این فصل، همان چارچوب را برای موضوع سبک‌های تست واحد به کار می‌برم. سه سبک تست وجود دارد: تست مبتنی بر خروجی، تست مبتنی بر حالت و تست مبتنی بر ارتباط. در میان این سه، سبک تست مبتنی بر خروجی بالاترین کیفیت تست‌ها را تولید می‌کند، تست مبتنی بر حالت انتخاب دوم بهترین است و تست مبتنی بر ارتباط تنها باید به ندرت استفاده شود.
متاسفانه، نمی‌توان از سبک تست مبتنی بر خروجی در همه جا استفاده کرد. این سبک تنها برای کدی قابل اجراست که به صورت کاملاً تابعی نوشته شده باشد. اما نگران نباشید؛ تکنیک‌هایی وجود دارند که می‌توانند به شما کمک کنند تا بیشتر تست‌های خود را به سبک مبتنی بر خروجی تبدیل کنید. برای این کار، نیاز خواهید داشت تا اصول برنامه‌نویسی تابعی را برای بازسازی کد زیرین به سمت یک معماری تابعی به کار بگیرید.
توجه داشته باشید که این فصل به موضوع برنامه‌نویسی تابعی به طور عمیق نمی‌پردازد. با این حال، امیدوارم تا پایان این فصل، درک شهودی از چگونگی ارتباط برنامه‌نویسی تابعی با تست مبتنی بر خروجی پیدا کنید. همچنین خواهید آموخت که چگونه تست‌های بیشتری را با استفاده از سبک مبتنی بر خروجی بنویسید و از محدودیت‌های برنامه‌نویسی تابعی و معماری تابعی آگاه شوید.

# سه سبک تست واحد

سه سبک تست واحد همان‌طور که در مقدمه فصل اشاره کردم، سه سبک تست واحد وجود دارد:

• تست مبتنی بر خروجی
• تست مبتنی بر حالت
• تست مبتنی بر ارتباط

می‌توانید یکی، دو یا حتی هر سه سبک را در یک تست به‌کار ببرید. این بخش، پایه‌ای برای کل فصل فراهم می‌کند و این سه سبک تست واحد را با مثال‌هایی تعریف می‌کند. در بخش بعدی، خواهید دید که این سبک‌ها چگونه نسبت به یکدیگر امتیاز می‌گیرند.

# تعریف سبک مبتنی بر خروجی

تعریف سبک مبتنی بر خروجی اولین سبک تست واحد، سبک مبتنی بر خروجی است، که در آن یک ورودی به سیستم تحت تست (SUT) داده می‌شود و خروجی تولید شده بررسی می‌شود (شکل 6.1). این سبک تست واحد تنها برای کدی قابل استفاده است که حالت داخلی یا جهانی را تغییر نمی‌دهد، بنابراین تنها مؤلفه‌ای که باید بررسی شود مقدار بازگشتی است.
لیست زیر نمونه‌ای از چنین کدی و یک تست پوشش‌دهنده آن را نشان می‌دهد. کلاس PriceEngine یک آرایه از محصولات را می‌پذیرد و تخفیف را محاسبه می‌کند.

<p align="center">
    <img src="../Part 6/figures/figure-6.1.png" />
</p>

هنوز ترجمه نشده

لیست زیر نمونه‌ای از چنین کدی و یک تست پوشش‌دهنده آن را نشان می‌دهد. کلاس PriceEngine یک آرایه از محصولات را می‌پذیرد و تخفیف را محاسبه می‌کند.

<div dir='ltr'>
  
```c#
public class PriceEngine
{
public decimal CalculateDiscount(params Product[] products)
{
decimal discount = products.Length * 0.01m;
return Math.Min(discount, 0.2m);
}
}
[Fact]
public void Discount_of_two_products()
{
var product1 = new Product("Hand wash");
var product2 = new Product("Shampoo");
var sut = new PriceEngine();
decimal discount = sut.CalculateDiscount(product1, product2);
Assert.Equal(0.02m, discount);
}
```

</div>

PriceEngine تعداد محصولات را در 1% ضرب می‌کند و نتیجه را در 20% محدود می‌کند. این کلاس هیچ عملکرد دیگری ندارد. محصولات را به هیچ مجموعه داخلی اضافه نمی‌کند و آنها را در یک پایگاه داده ذخیره نمی‌کند. تنها خروجی متد CalculateDiscount() تخفیفی است که بازمی‌گرداند: مقدار خروجی (شکل 6.2).

<p align="center">
    <img src="../Part 6/figures/figure-6.2.png" />
</p>

هنوز ترجمه نشده

سبک تست واحد مبتنی بر خروجی همچنین به عنوان تست تابعی شناخته می‌شود. این نام ریشه در برنامه‌نویسی تابعی دارد، روشی از برنامه‌نویسی که تأکید بر کد بدون اثر جانبی دارد. در ادامه این فصل بیشتر درباره برنامه‌نویسی تابعی و معماری تابعی صحبت خواهیم کرد.

# تعریف سبک مبتنی بر حالت

سبک مبتنی بر حالت به بررسی وضعیت سیستم پس از انجام عملیات می‌پردازد (شکل 6.3). اصطلاح حالت در این سبک تست می‌تواند به وضعیت سیستم تحت تست (SUT) خود، یکی از همکاران آن یا یک وابستگی خارجی مانند پایگاه داده یا سیستم فایل اشاره داشته باشد.

<p align="center">
    <img src="../Part 6/figures/figure-6.3.png" />
</p>

هنوز ترجمه نشده

مثال از تست مبتنی بر حالت کلاس Order به مشتری اجازه می‌دهد تا یک محصول جدید اضافه کند.

```c#
public class Order
{
private readonly List<Product> _products = new List<Product>();
public IReadOnlyList<Product> Products => _products.ToList();
public void AddProduct(Product product)
{
_products.Add(product);
}
}
[Fact]
public void Adding_a_product_to_an_order()
{
var product = new Product("Hand wash");
var sut = new Order();
sut.AddProduct(product);
Assert.Equal(1, sut.Products.Count);
Assert.Equal(product, sut.Products[0]);
}
```

تست، مجموعه Products را پس از تکمیل افزودن بررسی می‌کند. برخلاف مثال تست مبتنی بر خروجی در لیست 6.1، نتیجه AddProduct() تغییری است که در وضعیت سفارش ایجاد می‌شود.

# تعریف سبک مبتنی بر ارتباط

در نهایت، سبک سوم تست واحد، تست مبتنی بر ارتباط است. این سبک از mockها برای بررسی ارتباطات بین سیستم تحت تست و همکاران آن استفاده می‌کند (شکل 6.4).

<p align="center">
    <img src="../Part 6/figures/figure-6.4.png" />
</p>

هنوز ترجمه نشده

کد زیر یک مثال برای تست مبتنی بر حالت می‌باشد

```c#
[Fact]
public void Sending_a_greetings_email()
{
var emailGatewayMock = new Mock<IEmailGateway>();
var sut = new Controller(emailGatewayMock.Object);
sut.GreetUser("user@email.com");
emailGatewayMock.Verify(
x => x.SendGreetingsEmail("user@email.com"),
Times.Once);
}
```

# سبک‌ها و مکتب‌های تست واحد

مکتب کلاسیک تست واحد سبک مبتنی بر حالت را بر سبک مبتنی بر ارتباط ترجیح می‌دهد. مکتب لندن انتخاب مخالف را دارد. هر دو مکتب از تست مبتنی بر خروجی استفاده می‌کنند.

# مقایسه سه سبک تست واحد

تست‌های مبتنی بر خروجی، مبتنی بر حالت و مبتنی بر ارتباط چیز جدیدی نیستند. در واقع، قبلاً در این کتاب همه این سبک‌ها را دیده‌اید. نکته جالب، مقایسه آنها با یکدیگر با استفاده از چهار ویژگی یک تست واحد خوب است. این ویژگی‌ها عبارتند از:
• حفاظت در برابر بازگشت‌ها
• مقاومت در برابر تغییرات ساختاری
• بازخورد سریع
• قابلیت نگهداری

# مقایسه سبک‌ها با استفاده از معیارهای حفاظت در برابر بازگشت‌ها و سرعت بازخورد

ابتدا بیایید سه سبک را از نظر ویژگی‌های حفاظت در برابر بازگشت‌ها و سرعت بازخورد مقایسه کنیم، زیرا این ویژگی‌ها در این مقایسه خاص واضح‌تر هستند. معیار حفاظت در برابر بازگشت‌ها به سبک خاصی از تست وابسته نیست. این معیار حاصل سه ویژگی زیر است:
• مقدار کدی که در طول تست اجرا می‌شود
• پیچیدگی آن کد
• اهمیت حوزه آن
به طور کلی، می‌توانید تستی بنویسید که به اندازه دلخواه کد را اجرا کند؛ هیچ سبک خاصی در این زمینه مزیتی ندارد. همین موضوع برای پیچیدگی کد و اهمیت حوزه آن نیز صادق است. تنها استثنا سبک مبتنی بر ارتباط است: استفاده بیش از حد از آن می‌تواند به تست‌های سطحی منجر شود که تنها یک بخش کوچک از کد را بررسی می‌کنند و همه چیز دیگر را mock می‌کنند. این سطحی بودن، ویژگی قطعی تست مبتنی بر ارتباط نیست، بلکه یک مورد افراطی
از سوء استفاده از این تکنیک است.

# مقایسه سبک‌ها با استفاده از معیار مقاومت در برابر تغییرات ساختاری

در مورد معیار مقاومت در برابر بازسازی (Refactoring)، وضعیت متفاوت است. مقاومت در برابر بازسازی معیاری است برای سنجش تعداد مثبت‌های کاذب (آلارم‌های نادرست) که تست‌ها در طول بازسازی تولید می‌کنند. مثبت‌های کاذب به دلیل وابستگی تست‌ها به جزئیات پیاده‌سازی کد به جای رفتار قابل مشاهده، به وجود می‌آیند.

تست مبتنی بر خروجی بهترین محافظت را در برابر مثبت‌های کاذب ارائه می‌دهد، زیرا تست‌های نتیجه‌ای فقط به متدی که تحت تست است، وابسته هستند. تنها راهی که چنین تست‌هایی می‌توانند به جزئیات پیاده‌سازی وابسته شوند، این است که خود متدی که تحت تست است، یک جزئیات پیاده‌سازی باشد.

تست مبتنی بر حالت معمولاً بیشتر در معرض مثبت‌های کاذب قرار دارد. علاوه بر متدی که تحت تست است، چنین تست‌هایی با وضعیت (State) کلاس نیز کار می‌کنند. از نظر احتمالاتی، هرچه وابستگی بین تست و کد تولیدی بیشتر باشد، احتمال اینکه این تست به یک جزئیات پیاده‌سازی نشت کند، بیشتر است. تست‌های مبتنی بر حالت به سطح وسیع‌تری از API وابسته هستند و بنابراین احتمال وابستگی آنها به جزئیات پیاده‌سازی نیز بیشتر است.

تست مبتنی بر ارتباطات بیشتر از همه در معرض آلارم‌های نادرست قرار دارد. همانطور که از فصل ۵ به خاطر دارید، اکثریت تست‌هایی که تعاملات با جایگزین‌های تست (Test Doubles) را بررسی می‌کنند، شکننده هستند. این همیشه در مورد تعاملات با استاب‌ها صادق است - شما نباید هرگز چنین تعاملاتی را بررسی کنید. ماک‌ها (Mocks) فقط زمانی خوب هستند که تعاملاتی را که از مرزهای برنامه عبور می‌کنند و فقط زمانی که اثرات جانبی آن تعاملات برای دنیای خارج قابل مشاهده است، تأیید کنند. همانطور که می‌بینید، استفاده از تست مبتنی بر ارتباطات نیاز به دقت بیشتری دارد تا مقاومت مناسب در برابر بازسازی را حفظ کند.

اما همانند سطحی بودن، شکنندگی نیز ویژگی قطعی سبک تست مبتنی بر ارتباطات نیست. شما می‌توانید با حفظ پوشش مناسب و وابستگی تست‌ها به رفتار قابل مشاهده فقط، تعداد مثبت‌های کاذب را به حداقل برسانید. البته میزان دقت لازم بسته به سبک تست واحد، متفاوت است.

# مقایسه سبک‌ها با استفاده از معیار قابلیت نگهداری

در نهایت، معیار قابلیت نگهداری به شدت با سبک‌های تست واحد مرتبط است؛ اما برخلاف مقاومت در برابر بازسازی، کار زیادی برای کاهش آن نمی‌توانید انجام دهید. قابلیت نگهداری هزینه‌های نگهداری تست‌های واحد را ارزیابی می‌کند و با دو ویژگی زیر تعریف می‌شود:

میزان سختی درک تست، که تابعی از اندازه تست است.
میزان سختی اجرای تست، که تابعی از تعداد وابستگی‌های خارج از فرآیند است که تست به طور مستقیم با آنها کار می‌کند.
تست‌های بزرگ‌تر کمتر قابل نگهداری هستند زیرا درک یا تغییر آنها در صورت نیاز سخت‌تر است. به طور مشابه، تستی که به طور مستقیم با یک یا چند وابستگی خارج از فرآیند (مانند پایگاه داده) کار می‌کند، کمتر قابل نگهداری است زیرا نیاز به صرف زمان برای نگهداشتن آن وابستگی‌های خارج از فرآیند دارید: راه‌اندازی مجدد سرور پایگاه داده، حل مشکلات اتصال شبکه و غیره.

# قابلیت نگهداری تست‌های مبتنی بر خروجی

در مقایسه با دو نوع دیگر تست، تست مبتنی بر خروجی بیشترین قابلیت نگهداری را دارد. تست‌های حاصل تقریباً همیشه کوتاه و مختصر هستند و بنابراین نگهداری آنها آسان‌تر است. این مزیت سبک مبتنی بر خروجی از این واقعیت ناشی می‌شود که این سبک تنها به دو چیز نیاز دارد: ارائه یک ورودی به یک متد و تأیید خروجی آن، که اغلب می‌توان آن را با چند خط کد انجام داد.
از آنجا که کد زیرین در تست مبتنی بر خروجی نباید وضعیت جهانی یا داخلی را تغییر دهد، این تست‌ها با وابستگی‌های خارج از فرآیند سروکار ندارند. بنابراین، تست‌های مبتنی بر خروجی از نظر هر دو ویژگی قابلیت نگهداری بهترین هستند.

# قابلیت نگهداری تست‌های مبتنی بر حالت

تست‌های مبتنی بر حالت معمولاً کمتر از تست‌های مبتنی بر خروجی قابل نگهداری هستند. این به این دلیل است که تأیید حالت اغلب فضای بیشتری نسبت به تأیید خروجی می‌گیرد.

```c#
[Fact]
public void Adding_a_comment_to_an_article()
{
var sut = new Article();
var text = "Comment text";
var author = "John Doe";
var now = new DateTime(2019, 4, 1);
sut.AddComment(text, author, now);
Assert.Equal(1, sut.Comments.Count);
Assert.Equal(text, sut.Comments[0].Text);
Assert.Equal(author, sut.Comments[0].Author);
Assert.Equal(now, sut.Comments[0].DateCreated);
}
```

برای مثال، تستی که یک نظر را به یک مقاله اضافه می‌کند و سپس بررسی می‌کند که آیا نظر در لیست نظرات مقاله ظاهر می‌شود یا نه. هرچند این تست ساده شده است و تنها یک نظر دارد، قسمت تأییدیه آن در حال حاضر چهار خط را پوشش می‌دهد. تست‌های مبتنی بر حالت اغلب نیاز به تأیید داده‌های بیشتری دارند و بنابراین می‌توانند به طور قابل توجهی بزرگ شوند.

شما می‌توانید این مسئله را با معرفی متدهای کمکی که بیشتر کد را پنهان می‌کنند و در نتیجه تست را کوتاه‌تر می‌کنند، کاهش دهید، اما نوشتن و نگهداری این متدها نیاز به تلاش قابل توجهی دارد. این تلاش تنها زمانی موجه است که آن متدها قرار است در چندین تست استفاده شوند، که به ندرت اینگونه است.

```c#
[Fact]
public void Adding_a_comment_to_an_article()
{
var sut = new Article();
var text = "Comment text";
var author = "John Doe";
var now = new DateTime(2019, 4, 1);
sut.AddComment(text, author, now);
sut.ShouldContainNumberOfComments(1)
.WithComment(text, author, now);
}

```

روش دیگری برای کوتاه کردن تست مبتنی بر حالت، تعریف اعضای برابری در کلاسی است که در حال تأیید است. می‌توانید آن را به یک شیء مقدار (کلاسی که نمونه‌های آن بر اساس مقدار و نه مرجع مقایسه می‌شوند) تبدیل کنید؛ این کار نیز تست را ساده می‌کند، به ویژه اگر آن را با یک کتابخانه تأییدیه مانند Fluent Assertions ترکیب کنید.

```c#
[Fact]
public void Adding_a_comment_to_an_article()
{
var sut = new Article();
var comment = new Comment(
"Comment text",
"John Doe",
new DateTime(2019, 4, 1));
sut.AddComment(comment.Text, comment.Author, comment.DateCreated);
sut.Comments.Should().BeEquivalentTo(comment);
}

```

این تکنیک یک روش قدرتمند است، اما تنها زمانی کار می‌کند که کلاس ذاتاً یک مقدار باشد و بتوان آن را به یک شیء مقدار تبدیل کرد. در غیر این صورت، منجر به آلودگی کد می‌شود (آلودگی پایه کد تولید با کدی که تنها هدفش فعال‌سازی یا ساده‌سازی تست واحد است).

همانطور که می‌بینید، این دو تکنیک - استفاده از متدهای کمکی و تبدیل کلاس‌ها به اشیاء مقدار - تنها گاهی قابل اعمال هستند. و حتی زمانی که این تکنیک‌ها قابل اعمال باشند، تست‌های مبتنی بر حالت همچنان فضای بیشتری از تست‌های مبتنی بر خروجی می‌گیرند و بنابراین کمتر قابل نگهداری هستند.

# قابلیت نگهداری تست‌های مبتنی بر ارتباطات

تست‌های مبتنی بر ارتباطات از نظر قابلیت نگهداری نسبت به تست‌های مبتنی بر خروجی و حالت امتیاز کمتری می‌گیرند. تست‌های مبتنی بر ارتباطات نیاز به تنظیم جایگزین‌های تست و تأییدیه‌های تعامل دارند که فضای زیادی را اشغال می‌کند. تست‌ها حتی بزرگ‌تر و کمتر قابل نگهداری می‌شوند وقتی که زنجیره‌های ماک (ماک‌ها یا استاب‌هایی که ماک‌های دیگری را برمی‌گردانند و غیره) وجود دارند.

# مقایسه سبک‌ها: نتایج

بیایید اکنون سبک‌های تست واحد را با استفاده از ویژگی‌های یک تست واحد خوب مقایسه کنیم. تست‌های مبتنی بر خروجی بهترین نتایج را نشان می‌دهند. این سبک تست‌هایی تولید می‌کند که به ندرت به جزئیات پیاده‌سازی وابسته هستند و بنابراین نیازی به دقت زیادی برای حفظ مقاومت در برابر بازسازی ندارند. این تست‌ها نیز به دلیل کوتاهی و عدم وابستگی به فرآیندهای خارج از فرآیند، بیشترین قابلیت نگهداری را دارند.

<p align="center">
    <img src="../Part 6/figures/Table 6.1.png" />
</p>

هنوز ترجمه نشده

تست‌های مبتنی بر حالت و ارتباطات در هر دو معیار بدتر هستند. این تست‌ها بیشتر احتمال دارد که به جزئیات پیاده‌سازی نشت کنند و همچنین هزینه‌های نگهداری بیشتری به دلیل بزرگ‌تر بودن اندازه آنها دارند.

همیشه تست مبتنی بر خروجی را به هر چیز دیگری ترجیح دهید. متأسفانه، گفتن این کار آسان‌تر از انجام آن است. این سبک تست واحد تنها به کدی قابل اعمال است که به صورت تابعی نوشته شده باشد، که به ندرت در بیشتر زبان‌های برنامه‌نویسی شی‌گرا رخ می‌دهد. با این حال، تکنیک‌هایی وجود دارند که می‌توانید برای انتقال بیشتر تست‌های خود به سمت سبک مبتنی بر خروجی استفاده کنید.

بقیه این فصل نشان می‌دهد که چگونه می‌توان از تست مبتنی بر حالت و ارتباطات به تست مبتنی بر خروجی منتقل شد. این انتقال نیاز به کد تابعی‌تر دارد، که به نوبه خود امکان استفاده از تست‌های مبتنی بر خروجی را به جای تست‌های مبتنی بر حالت یا ارتباطات فراهم می‌کند.

</div>

<div dir="rtl">

# یونیت تست چیست؟

همونطور که در فصل یک اشاره شد، تعداد شگفت‌انگیزی از تفاوت‌‌های ریز در تعریف یونیت تست وجود دارد. این تفاوت‌ها از آنچه تصور می‌کنید اهمیت بیشتری دارند. به قدری که تفاوت در تفسیر آن‌‌ها به دو دیدگاه متمایز در مورد نحوه انجام یونیت تست منجر شده است.

این دیدگاه‌ها به عنوان سبک کلاسیک (classical schools) و سبک لندن (London school) شناخته می‌شوند. سبک کلاسیک به این دلیل کلاسیک نامیده می‌شود که این روش همان روشی است که همه ابتدا یونیت تست و توسعه تست محور را انجام می‌دادند.
سبک لندن در جامعه برنامه‌نویسی لندن ریشه دارد. بحث در این فصل درباره تفاوت‌های بین سبک‌های کلاسیک و لندن پایه‌گذار فصل ۵ است، جایی که موضوع شبیه‌سازی و شکنندگی تست‌ها را به تفصیل بررسی می‌کنم.

بیایید با تعریف یونیت تست شروع کنیم.

## ۲.۱ تعریف یونیت تست
تعاریف زیادی از یونیت تست وجود دارد. با حذف قسمت‌های غیر ضرروری، این تعاریف همگی دارای سه ویژگی مهم هستند.

- یک بخش کوچک از کد (که به عنوان یک واحد نیز شناخته می‌شود) را تایید می‌کند
- این کار را به سرعت انجام می‌دهد
- این کار را به صورت مجزا انجام می‌دهد
  دو ویژگی اول اینجا کاملا غیرقابل بحث هستند. ممکن است اختلاف نظرهایی در مورد اینکه دقیقا چه چیزی یک یونیت تست سریع را تشکیل می‌دهد وجود داشته باشید، زیرا این یک اندازه‌گیری بسیار ذهنی است. اما به طور کلی، این مهم نیست، اگر زمان اجرای مجموعه تست شما برای شما مناسب است، به این معناست که تست‌های شما به اندازه کافی سریع هستند.

آنچه مردم دیدگاه‌های متفاوتی درباره آن دارند ویژگی سوم است. مسئله جداسازی ریشه تفاوت بین سبک کلاسیک و لندن است. همانطور که در بخش بعدی مشاهده خواهید کرد، تمام تفاوت‌های دیگر بین دو سبک به طور طبیعی از اختلاف واحد در مورد اینکه دقیقا جداسازی چیست، جریان می‌یابد. من سبک کلاسیک را به دلایلی که در بخش ۲.۳ توضیح می‌دهم، ترجیح می‌دهم.

رویکرد کلاسیک به عنوان رویکرد دیترویت و گاهی اوقات به عنوان رویکرد کلاسیک نیز نامیده می‌شود. احتمالاً کتاب کنونیکال‌ترین درباره سبک کلاسیک کتاب کنت بک: توسعه تست محور: با مثال (Addison-Wesley Professional, 2002) است.

سبک لندن گاهی اوقات به عنوان شبیه‌ساز (mockist) نامیده می‌شود. با اینکه اصطلاح شبیه‌ساز گسترده است، افرادی که به این سبک تست واحد پایبند هستند معمولاً آن را دوست ندارند، بنابراین در تمام این کتاب آن را سبک لندن می‌نامم. برجسته‌ترین حامیان این رویکرد استیو فریمن و نت پرایس هستند. من کتاب آنها، رشد نرم‌افزار شی‌گرا، هدایت‌شده توسط تست‌ها (Addison-Wesley Professional, 2009) را به عنوان منبع خوبی در این موضوع توصیه می‌کنم.


## ۲.۱.۱ مسئله جداسازی: دیدگاه لندن
جداسازی یک بخش کد یا یک یونیت تست به صورت مجزا به چه معناست؟ سبک  لندن آن را به عنوان جدا‏ ‏سازی سیستم تحت تست (system under test) از بقیه توصیف می‌کند. این به این معنی است که اگر یک کلاس وابستگی به کلاس دیگری یا چندین کلاس دارد، باید تمام این وابستگی‌ها را با test double جایگزین کنید. به این ترتیب، می‌توانید با جداسازی رفتار آن از هر تاثیر خارجی، روی کلاس تحت تست تمرکز کنید.

### تعریف یک تست دابل

یک test double شئ‌ای است که مانند خود کلاس به نظر می‌رسد و رفتار می‌کند اما در واقع نسخه ساده‌شده‌ای است که پیچیدگی را کاهش داده و تست را تسهیل می‌کند. این اصطلاح توسط جرارد مسزاروس در کتابش "الگوهای تست xUnit: بازسازی کد تست" (Addison-Wesley, 2007) معرفی شد. نام خود از مفهوم دوبل بدلکار در فیلم‌ها می‌آید.

شکل 2.1 نشان می‌دهد که چگونه معمولاً جداسازی انجام می‌شود. یک تست واحد که در غیر این صورت سیستم تحت تست را همراه با تمام وابستگی‌هایش بررسی می‌کند، اکنون می‌تواند این کار را به طور جداگانه از آن وابستگی‌ها انجام دهد.

<p align="center">
    <img src="../Part 2/Images/figure-2.1.jpeg" />
</p>

یکی از مزایای این روش این است که اگر تست شکست بخورد، شما مطمئن هستید که کدام بخش از کد پایه خراب است: سیستم تحت تست. نمی‌تواند گزینه دیگری باشد، زیرا همه کلاس‌های وابسته با کلاس با test double جایگزین شده‌اند.

مزیت دیگر توانایی تقسیم نمودار شیء – شبکه‌ای از کلاس‌های ارتباطی که همان مشکل را حل می‌کنند – است. این شبکه ممکن است بسیار پیچیده شود: هر کلاس در آن ممکن است چندین وابستگی فوری داشته باشد، که هر یک به وابستگی‌های خاص خود متکی هستند، و به همین ترتیب. کلاس‌ها حتی ممکن است وابستگی‌های دایره‌ای ایجاد کنند، جایی که زنجیره وابستگی در نهایت به جایی که شروع شده بود باز می‌گردد.

تلاش برای تست چنین کد پایه‌ای به هم پیوسته بدون test double سخت است. تقریباً تنها انتخابی که باقی می‌ماند، بازسازی نمودار کامل شیء در تست است، که ممکن است اگر تعداد‌ کلاس‌های آن بسیار زیاد باشد این کار امکان پذیر نباشد.

با test double، می‌توانید به این مسئله پایان دهید. می‌توانید وابستگی‌های فوری یک کلاس را جایگزین کنید؛ و به طور گسترده‌تر، نیازی به مقابله با وابستگی‌های آن وابستگی‌ها و به همین ترتیب در مسیر بازگشتی ندارید. شما عملاً نمودار را شکسته‌اید – و این می‌تواند به طور قابل توجهی مقدار آماده‌سازی‌هایی را که باید در یک تست واحد انجام دهید کاهش دهد.

و فراموش نکنیم یک مزیت کوچک اما دلپذیر دیگر این روش برای جداسازی تست واحد: این روش به شما امکان می‌دهد تا یک راهنمای پروژه وسیع برای تست یک کلاس در هر زمان معرفی کنید، که یک ساختار ساده در کل مجموعه تست واحد ایجاد می‌کند. دیگر نیازی نیست زیاد به این فکر کنید که چگونه کد پایه خود را با تست‌ها پوشش دهید. کلاسی دارید؟ یک کلاس متناظر با تست واحدها ایجاد کنید! شکل 2.2 نشان می‌دهد که معمولاً چگونه به نظر می‌رسد.

<p align="center">
    <img src="../Part 2/Images/figure-2.2.jpeg" />
</p>

حالا بیایید به چند مثال نگاه کنیم. از آنجایی که سبک کلاسیک احتمالاً برای اکثر مردم آشناتر به نظر می‌رسد، ابتدا تست‌های نمونه نوشته شده در آن سبک را نشان می‌دهم و سپس آنها را با استفاده از رویکرد لندن بازنویسی می‌کنم.

فرض کنید که ما یک فروشگاه آنلاین را اداره می‌کنیم. تنها یک مورد استفاده ساده در مثال ما وجود دارد: مشتری می‌تواند محصولی را خریداری کند. وقتی که موجودی کافی در فروشگاه وجود داشته باشد، خرید موفقیت‌آمیز تلقی می‌شود و مقدار محصول در فروشگاه به میزان خرید کاهش می‌یابد. اگر محصول کافی وجود نداشته باشد، خرید موفقیت‌آمیز نیست و هیچ اتفاقی در فروشگاه نمی‌افتد.

فهرست 2.1 دو تست را نشان می‌دهد که بررسی می‌کنند خرید تنها زمانی موفقیت‌آمیز است که موجودی کافی در فروشگاه وجود داشته باشد. تست‌ها به سبک کلاسیک نوشته شده‌اند و از توالی سه فازی معمول: ترتیب‌دهی، عمل، و تأیید (AAA برای کوتاه - در فصل 3 بیشتر در مورد این توالی صحبت می‌کنم) استفاده می‌کنند.
```c#
    [Fact]  
    public void Purchase_succeeds_when_enough_inventory()  
    {  
        // Arrange  
      var store = new Store();  
        store.AddInventory(Product.Shampoo, 10);  
        var customer = new Customer();  
        // Act  
      bool success = customer.Purchase(store, Product.Shampoo, 5);  
        // Assert  
      Assert.True(success);  
        Assert.Equal(5, store.GetInventory(Product.Shampoo));   
    }  
    [Fact]  
    public void Purchase_fails_when_not_enough_inventory()  
    {  
        // Arrange  
      var store = new Store();  
        store.AddInventory(Product.Shampoo, 10);  
        var customer = new Customer();  
        // Act  
      bool success = customer.Purchase(store, Product.Shampoo, 15);  
        // Assert  
      Assert.False(success);  
        Assert.Equal(10, store.GetInventory(Product.Shampoo));   
    }  
    public enum Product  
    {  
        Shampoo,  
        Book  
    }
```

همانطور که مشاهده می‌کنید، قسمت ترتیب‌دهی جایی است که تست‌ها تمام وابستگی‌ها و سیستم تحت تست (SUT) را آماده می‌کنند. فراخوانی customer.Purchase() فاز عمل است، جایی که رفتاری که می‌خواهید بررسی کنید را اجرا می‌کنید. عبارات تأیید، مرحله تأیید هستند، جایی که بررسی می‌کنید که آیا رفتار به نتایج مورد انتظار منجر شده است یا خیر.

در طول مرحله ترتیب‌دهی، تست‌ها دو نوع شیء را با هم قرار می‌دهند: سیستم تحت تست (SUT) و یک وابستگی. در این مورد، Customer سیستم تحت تست است و Store وابستگی است. ما به وابستگی به دو دلیل نیاز داریم:

-   برای کامپایل شدن روش تحت تست، زیرا customer.Purchase() نیاز به یک نمونه از Store به عنوان آرگومان دارد.
-   برای مرحله تأیید، زیرا یکی از نتایج customer.Purchase() کاهش احتمالی در مقدار محصول در فروشگاه است.

Product.Shampoo و اعداد 5 و 15 مقدار‌های ثابت هستند.

### تعریف متد تحت تست (MUT)

تعریف: متد تحت تست (MUT) روشی است که در سیستم تحت تست (SUT) توسط تست فراخوانی می‌شود. اصطلاحات MUT و SUT اغلب به عنوان مترادف استفاده می‌شوند، اما معمولاً MUT به یک متد اشاره دارد در حالی که SUT به کل کلاس اشاره می‌کند.

### این کد مثالی از سبک کلاسیک تست واحد است

این کد مثالی از سبک کلاسیک تست واحد است: تست، وابستگی (کلاس Store) را جایگزین نمی‌کند بلکه از یک نمونه آماده تولید آن استفاده می‌کند. یکی از نتایج طبیعی این سبک این است که تست اکنون به طور مؤثر هم Customer و هم Store را تأیید می‌کند، نه فقط Customer. هر باگی در کارکرد داخلی Store که بر Customer تأثیر بگذارد منجر به شکست این تست‌های واحد می‌شود، حتی اگر Customer همچنان به درستی کار کند. این دو کلاس در تست‌ها از یکدیگر جدا نشده‌اند.

بیایید حالا همان دو تست را در سبک لندن بازنویسی کنیم. در اینجا از یک کتابخانه mocking برای جایگزینی کلاس Store با یک test double استفاده می‌کنیم. این کار را با استفاده از Moq، یکی از محبوب‌ترین فریمورک‌های mocking در اکوسیستم دات‌نت انجام می‌دهیم:

```c#
    [Fact]
    public void Purchase_succeeds_when_enough_inventory()
    {
        // Arrange
        var store = new Mock<IStore>();
        store.Setup(x => x.HasEnoughInventory(Product.Shampoo, 5)).Returns(true);
        var customer = new Customer();
    
        // Act
        bool success = customer.Purchase(store.Object, Product.Shampoo, 5);
    
        // Assert
        Assert.True(success);
        store.Verify(x => x.RemoveInventory(Product.Shampoo, 5), Times.Once);
    }
    
    [Fact]
    public void Purchase_fails_when_not_enough_inventory()
    {
        // Arrange
        var store = new Mock<IStore>();
        store.Setup(x => x.HasEnoughInventory(Product.Shampoo, 15)).Returns(false);
        var customer = new Customer();
    
        // Act
        bool success = customer.Purchase(store.Object, Product.Shampoo, 15);
    
        // Assert
        Assert.False(success);
        store.Verify(x => x.RemoveInventory(Product.Shampoo, It.IsAny<int>()), Times.Never);
    }
```

توجه کنید که این تست‌ها چقدر با تست‌های نوشته شده در سبک کلاسیک متفاوت هستند. در مرحله ترتیب، تست‌ها دیگر یک نمونه آماده تولید از Store را نمونه‌سازی نمی‌کنند، بلکه به جای آن یک جایگزین برای آن ایجاد می‌کنند، با استفاده از کلاس داخلی Mock<T> از Moq.

علاوه بر این، به جای تغییر وضعیت Store با اضافه کردن موجودی شامپو به آن، ما مستقیماً به mock می‌گوییم که چگونه به فراخوانی‌های HasEnoughInventory() پاسخ دهد. mock به این درخواست به روشی که تست‌ها نیاز دارند واکنش نشان می‌دهد، صرف نظر از وضعیت واقعی Store. در واقع، تست‌ها دیگر از Store استفاده نمی‌کنند - ما یک اینترفیس به نام IStore معرفی کرده‌ایم و به جای کلاس Store آن اینترفیس را mock کرده‌ایم.

در فصل 8، به تفصیل درباره کار با اینترفیس‌ها می‌نویسم. فعلاً فقط توجه کنید که اینترفیس‌ها برای جداسازی سیستم تحت تست از وابستگی‌هایش ضروری هستند. (همچنین می‌توانید یک کلاس مشخص را mock کنید، اما این یک الگوی ضد است؛ من این موضوع را در فصل 11 پوشش می‌دهم.)

مرحله تأیید نیز تغییر کرده است و اینجا است که تفاوت کلیدی وجود دارد. ما هنوز خروجی customer.Purchase را همانند قبل بررسی می‌کنیم، اما روش تأیید اینکه مشتری کار درست را در فروشگاه انجام داده است متفاوت است. قبلاً این کار را با تأیید وضعیت فروشگاه انجام می‌دادیم. اکنون، ما تعاملات بین Customer و Store را بررسی می‌کنیم: تست‌ها بررسی می‌کنند که آیا مشتری فراخوانی درستی روی فروشگاه انجام داده است یا نه.

این کار را با ارسال متدی که مشتری باید روی فروشگاه فراخوانی کند (x.RemoveInventory) و همچنین تعداد دفعاتی که باید این کار را انجام دهد، انجام می‌دهیم. اگر خرید موفق شود، مشتری باید این متد را یک بار فراخوانی کند (Times.Once). اگر خرید شکست بخورد، مشتری نباید آن را اصلاً فراخوانی کند (Times.Never).

### 2.1.2 مسئله جداسازی: برداشت کلاسیک

برای تأکید، سبک لندن به نیاز جداسازی با تفکیک بخش کد تحت تست از وابستگی‌هایش با استفاده از test double‌ها: به طور خاص، mocks، نزدیک می‌شود. جالب است بدانید که این دیدگاه همچنین بر دیدگاه شما در مورد اینکه چه چیزی یک بخش کوچک از کد (یک واحد) را تشکیل می‌دهد، تأثیر می‌گذارد. در اینجا دوباره تمام ویژگی‌های یک تست واحد آورده شده است:

-   یک تست واحد یک بخش کوچک از کد (یک واحد) را تأیید می‌کند،
-   این کار را به سرعت انجام می‌دهد،
-   و این کار را به صورت مجزا انجام می‌دهد.

علاوه بر اینکه ویژگی سوم جای تفسیر دارد، در تفسیرهای ممکن از ویژگی اول نیز مقداری جای تفسیر وجود دارد. یک بخش کوچک از کد چقدر باید کوچک باشد؟ همانطور که از بخش قبلی دیدید، اگر موضع جداسازی هر کلاس فردی را اتخاذ کنید، پس طبیعی است که بپذیرید که بخش کد تحت تست نیز باید یک کلاس منفرد یا یک متد داخل آن کلاس باشد. نمی‌تواند بیشتر از این باشد به دلیل روشی که به مسئله جداسازی نزدیک می‌شوید. در برخی موارد، ممکن است چند کلاس را همزمان تست کنید؛ اما به طور کلی، همیشه به حفظ این راهنما که هر بار یک کلاس را تست کنید، تلاش خواهید کرد.

همانطور که قبلاً ذکر کردم، راه دیگری برای تفسیر ویژگی جداسازی وجود دارد - راه کلاسیک. در رویکرد کلاسیک، این کد نیست که باید به صورت مجزا تست شود. در عوض، تست‌های واحد باید به صورت مجزا از یکدیگر اجرا شوند. به این ترتیب، می‌توانید تست‌ها را به صورت موازی، متوالی و به هر ترتیبی که برای شما مناسب باشد اجرا کنید و هنوز هم بر نتایج یکدیگر تأثیر نخواهند گذاشت.

جداسازی تست‌ها از یکدیگر به این معناست که اشکالی ندارد که چندین کلاس را همزمان تست کنید، تا زمانی که همه آنها در حافظه قرار داشته باشند و به یک وضعیت مشترک دسترسی پیدا نکنند، از طریق آن تست‌ها بتوانند با یکدیگر ارتباط برقرار کنند و بر زمینه اجرای یکدیگر تأثیر بگذارند. نمونه‌های معمول چنین وضعیت مشترکی وابستگی‌های خارج از فرآیند هستند - پایگاه داده، سیستم فایل و غیره.

برای مثال، یک تست می‌تواند در مرحله ترتیب خود یک مشتری را در پایگاه داده ایجاد کند، و تست دیگر می‌تواند آن را به عنوان بخشی از مرحله ترتیب خود حذف کند، قبل از اینکه تست اول اجرای خود را کامل کند. اگر این دو تست را به صورت موازی اجرا کنید، تست اول شکست خواهد خورد، نه به این دلیل که کد تولیدی خراب است، بلکه به دلیل تداخل از تست دوم.

### وابستگی‌های مشترک، خصوصی، و خارج از فرآیند

یک وابستگی مشترک وابستگی‌ای است که بین تست‌ها به اشتراک گذاشته می‌شود و امکان تأثیرگذاری تست‌ها بر نتایج یکدیگر را فراهم می‌کند. مثال معمولی از وابستگی‌های مشترک، یک فیلد استاتیک قابل تغییر است. تغییر در چنین فیلدی در تمام تست‌های واحدی که در یک فرآیند مشابه اجرا می‌شوند، قابل مشاهده است. یک پایگاه داده نیز مثال معمولی دیگری از وابستگی مشترک است.

یک وابستگی خصوصی وابستگی‌ای است که به اشتراک گذاشته نمی‌شود.

یک وابستگی خارج از فرآیند وابستگی‌ای است که خارج از فرآیند اجرای برنامه اجرا می‌شود؛ این وابستگی به داده‌ای که هنوز در حافظه نیست پروکسی می‌دهد. در اکثر موارد، یک وابستگی خارج از فرآیند به یک وابستگی مشترک مربوط می‌شود، اما نه همیشه. به عنوان مثال، یک پایگاه داده هم خارج از فرآیند است و هم مشترک. اما اگر آن پایگاه داده را در یک کانتینر Docker قبل از هر اجرای تست راه‌اندازی کنید، این وابستگی خارج از فرآیند خواهد بود ولی مشترک نخواهد بود، زیرا تست‌ها دیگر با همان نمونه از آن کار نمی‌کنند. به طور مشابه، یک پایگاه داده فقط خواندنی نیز خارج از فرآیند است اما مشترک نیست، حتی اگر توسط تست‌ها مجدداً استفاده شود. تست‌ها نمی‌توانند داده‌ها را در چنین پایگاه داده‌ای تغییر دهند و بنابراین نمی‌توانند بر نتایج یکدیگر تأثیر بگذارند.

این برداشت از مسئله جداسازی، دیدگاه بسیار متواضع‌تری نسبت به استفاده از mock‌ها و سایر test double‌ها در بر دارد. شما هنوز هم می‌توانید از آنها استفاده کنید، اما معمولاً این کار را فقط برای آن دسته از وابستگی‌ها انجام می‌دهید که یک وضعیت مشترک بین تست‌ها معرفی می‌کنند. شکل 2.3 نشان می‌دهد که چگونه به نظر می‌رسد.

<p align="center">
    <img src="../Part 2/Images/figure-2.3.jpeg" />
</p>

توجه داشته باشید که وابستگی‌های مشترک بین تست‌های واحد به اشتراک گذاشته می‌شوند، نه بین کلاس‌های تحت تست (واحدها). از این نظر، یک وابستگی singleton تا زمانی که بتوانید در هر تست یک نمونه جدید از آن ایجاد کنید، مشترک نیست. در حالی که تنها یک نمونه از singleton در کد تولید وجود دارد، تست‌ها ممکن است این الگو را دنبال نکنند و آن singleton را مجدداً استفاده نکنند. بنابراین، چنین وابستگی خصوصی خواهد بود.

به عنوان مثال، معمولاً تنها یک نمونه از کلاس پیکربندی وجود دارد که در تمام کد تولید استفاده می‌شود. اما اگر این وابستگی به همان روشی که سایر وابستگی‌ها به سیستم تحت تست تزریق می‌شوند، یعنی از طریق سازنده، تزریق شود، می‌توانید یک نمونه جدید از آن در هر تست ایجاد کنید؛ نیازی به حفظ یک نمونه واحد در کل مجموعه تست‌ها نیست. با این حال، نمی‌توانید یک سیستم فایل یا پایگاه داده جدید ایجاد کنید؛ آنها باید بین تست‌ها به اشتراک گذاشته شوند یا با test double‌ها جایگزین شوند.

### وابستگی‌های مشترک در مقابل وابستگی‌های متغیر

اصطلاح دیگری وجود دارد که معنای مشابهی دارد، اما نه کاملاً یکسان: وابستگی متغیر. من کتاب "تزریق وابستگی: اصول، شیوه‌ها، الگوها" نوشته Steven van Deursen و Mark Seemann (مؤسسه Manning Publications، 2018) را به عنوان کتابی مرجع در موضوع مدیریت وابستگی‌ها توصیه می‌کنم.

یک وابستگی متغیر وابستگی‌ای است که یکی از ویژگی‌های زیر را نشان می‌دهد:

-   نیاز به راه‌اندازی و پیکربندی محیط اجرا علاوه بر آنچه به طور پیش‌فرض روی دستگاه توسعه‌دهنده نصب شده است را معرفی می‌کند. پایگاه‌های داده و سرویس‌های API نمونه‌های خوبی در اینجا هستند. آنها نیاز به راه‌اندازی اضافی دارند و به طور پیش‌فرض روی دستگاه‌های سازمان شما نصب نمی‌شوند.
-   رفتار غیرقابل پیش‌بینی دارد. مثالی از این مورد یک تولید کننده اعداد تصادفی یا کلاسی است که تاریخ و زمان فعلی را باز می‌گرداند. این وابستگی‌ها غیرقابل پیش‌بینی هستند زیرا در هر فراخوانی نتایج متفاوتی ارائه می‌دهند.

همانطور که می‌بینید، همپوشانی بین مفاهیم وابستگی‌های مشترک و وابستگی‌های متغیر وجود دارد. به عنوان مثال، یک وابستگی به پایگاه داده هم مشترک است و هم متغیر. اما این موضوع برای سیستم فایل صادق نیست. سیستم فایل متغیر نیست زیرا روی هر دستگاه توسعه‌دهنده نصب شده است و در اکثر موارد به صورت تعیین‌پذیر رفتار می‌کند. با این حال، سیستم فایل امکان تداخل تست‌های واحد با زمینه اجرای یکدیگر را معرفی می‌کند؛ بنابراین مشترک است. به طور مشابه، یک تولید کننده اعداد تصادفی متغیر است، اما چون می‌توانید یک نمونه جداگانه از آن به هر تست ارائه دهید، مشترک نیست.

دلیل دیگری برای جایگزینی وابستگی‌های مشترک، افزایش سرعت اجرای تست است. وابستگی‌های مشترک تقریباً همیشه خارج از فرآیند اجرا قرار دارند، در حالی که وابستگی‌های خصوصی معمولاً از این مرز عبور نمی‌کنند. به همین دلیل، فراخوانی‌ها به وابستگی‌های مشترک، مانند پایگاه داده یا سیستم فایل، بیشتر از فراخوانی‌ها به وابستگی‌های خصوصی زمان می‌برند. و از آنجا که ضرورت اجرای سریع دومین ویژگی تعریف تست واحد است، چنین فراخوانی‌هایی تست‌هایی را که دارای وابستگی‌های مشترک هستند، از حوزه تست واحد خارج کرده و به حوزه تست یکپارچه‌سازی می‌برند. من بیشتر درباره تست یکپارچه‌سازی در ادامه این فصل صحبت می‌کنم.

این دیدگاه جایگزین از جداسازی همچنین منجر به دیدگاه متفاوتی در مورد اینکه چه چیزی یک واحد (یک بخش کوچک از کد) را تشکیل می‌دهد، می‌شود. یک واحد لزوماً محدود به یک کلاس نیست. شما می‌توانید به همان اندازه یک گروه از کلاس‌ها را تست واحد کنید، تا زمانی که هیچ کدام از آنها یک وابستگی مشترک نباشند.

### 2.2 سبک‌های کلاسیک و لندن در تست واحد

همانطور که می‌بینید، ریشه تفاوت‌های بین سبک لندن و کلاسیک ویژگی جداسازی است. سبک لندن آن را به عنوان جداسازی سیستم تحت تست از وابستگی‌هایش می‌بیند، در حالی که سبک کلاسیک آن را به عنوان جداسازی تست‌های واحد از یکدیگر می‌بیند. این تفاوت ظاهراً کوچک منجر به اختلافات گسترده‌ای در مورد نحوه انجام تست واحد شده است که همانطور که می‌دانید، به دو مدرسه فکری منجر شده است. به طور کلی، اختلاف بین این دو سبک سه موضوع اصلی را در بر می‌گیرد:

-   نیاز به جداسازی
-   چه چیزی یک بخش کد تحت تست (یک واحد) را تشکیل می‌دهد
-   مدیریت وابستگی‌ها

جدول 2.1 خلاصه‌ای از همه این موارد است.

### 2.2.1 نحوه مدیریت وابستگی‌ها در سبک‌های کلاسیک و لندن

توجه داشته باشید که با وجود استفاده گسترده از test double‌ها، سبک لندن همچنان اجازه می‌دهد که برخی از وابستگی‌ها در تست‌ها به همان صورت استفاده شوند. آزمون اصلی اینجا این است که آیا یک وابستگی قابل تغییر است یا خیر. اگر اشیایی که هرگز تغییر نمی‌کنند - اشیای ثابت - باشد، نیازی به جایگزینی آنها نیست.

همانطور که در مثال‌های قبلی دیدید، زمانی که تست‌ها را به سمت سبک لندن بازسازی کردم، نمونه‌های Product را با mock‌ها جایگزین نکردم بلکه از اشیای واقعی استفاده کردم، همانطور که در کد زیر نشان داده شده است (برای راحتی شما از لیست 2.2 تکرار شده است):

```c#
    [Fact]
    public void Purchase_fails_when_not_enough_inventory()
    {
        // Arrange
        var storeMock = new Mock<IStore>();
        storeMock
        .Setup(x => x.HasEnoughInventory(Product.Shampoo, 5))
        .Returns(false);
        var customer = new Customer();

        // Act
        bool success = customer.Purchase(storeMock.Object, Product.Shampoo, 5);
    
        // Assert
        Assert.False(success);
        storeMock.Verify(
        x => x.RemoveInventory(Product.Shampoo, 5),
        Times.Never);
    }
```

از دو وابستگی Customer، فقط Store دارای یک وضعیت داخلی است که می‌تواند با گذشت زمان تغییر کند. نمونه‌های Product ثابت هستند (خود Product یک enum در سی‌شارپ است). بنابراین من فقط نمونه Store را جایگزین کردم.

اگر در مورد آن فکر کنید، منطقی است. شما از یک test double برای عدد 5 در تست قبلی استفاده نمی‌کنید، درست است؟ این به این دلیل است که عدد نیز ثابت است - شما نمی‌توانید این عدد را تغییر دهید. توجه داشته باشید که من در مورد یک متغیر حاوی عدد صحبت نمی‌کنم، بلکه خود عدد. در عبارت RemoveInventory(Product.Shampoo, 5)، ما حتی از یک متغیر استفاده نمی‌کنیم؛ عدد 5 مستقیماً اعلام شده است. همین امر برای Product.Shampoo صادق است.

این اشیای ثابت ارزش‌ها یا value object نامیده می‌شوند. ویژگی اصلی آنها این است که هویت فردی ندارند؛ آنها تنها بر اساس محتوایشان شناسایی می‌شوند. به عنوان نتیجه، اگر دو شیء چنین محتوای یکسانی داشته باشند، مهم نیست با کدام یک کار می‌کنید: این نمونه‌ها قابل تعویض هستند. برای مثال، اگر دو عدد 5 دارید، می‌توانید آنها را به جای یکدیگر استفاده کنید. همین امر برای محصولات در مورد ما صدق می‌کند: شما می‌توانید از یک نمونه Product.Shampoo استفاده مجدد کنید یا چندین نمونه از آن اعلام کنید - هیچ تفاوتی نخواهد داشت. این نمونه‌ها محتوای یکسانی دارند و بنابراین می‌توانند به طور متقابل استفاده شوند.

توجه داشته باشید که مفهوم یک value object مستقل از زبان است و نیاز به زبان برنامه‌نویسی یا فریمورک خاصی ندارد. شما می‌توانید بیشتر درباره value object‌ها در مقاله من "Entity vs. Value Object: The ultimate list of differences" در [این لینک](http://mng.bz/KE9O) بخوانید.

<p align="center">
    <img src="../Part 2/Images/figure-2.4.jpeg" />
</p>

شکل 2.4 دسته‌بندی وابستگی‌ها و نحوه برخورد هر دو سبک تست واحد با آنها را نشان می‌دهد. یک وابستگی می‌تواند یا مشترک یا خصوصی باشد. یک وابستگی خصوصی به نوبه خود می‌تواند قابل تغییر یا ثابت باشد. در حالت دوم، به آن value object گفته می‌شود. به عنوان مثال، یک پایگاه داده یک وابستگی مشترک است - وضعیت داخلی آن بین همه تست‌های خودکار به اشتراک گذاشته می‌شود (که آن را با یک test double جایگزین نمی‌کنند). یک نمونه Store یک وابستگی خصوصی قابل تغییر است. و یک نمونه Product (یا یک نمونه از عدد 5) مثالی از یک وابستگی خصوصی ثابت - یک value object است. همه وابستگی‌های مشترک قابل تغییر هستند، اما برای اینکه یک وابستگی قابل تغییر مشترک باشد، باید توسط تست‌ها استفاده مجدد شود.

### وابستگی در مقابل همکار

یک همکار وابستگی‌ای است که یا مشترک است یا قابل تغییر. به عنوان مثال، کلاسی که دسترسی به پایگاه داده را فراهم می‌کند یک همکار است زیرا پایگاه داده یک وابستگی مشترک است. Store نیز یک همکار است، زیرا وضعیت آن می‌تواند با گذشت زمان تغییر کند. Product و عدد 5 نیز وابستگی هستند، اما همکار نیستند. آنها value یا value object هستند.

یک کلاس معمولی ممکن است با وابستگی‌های هر دو نوع کار کند: همکارها و valueها. به این متد فراخوانی نگاه کنید:

    customer.Purchase(store, Product.Shampoo, 5)
اینجا ما سه وابستگی داریم. یکی از آنها (store) یک همکار است و دو تای دیگر (Product.Shampoo، 5) نیستند.

و اجازه دهید یک نکته را درباره انواع وابستگی‌ها دوباره بیان کنم. همه وابستگی‌های خارج از فرآیند در دسته وابستگی‌های مشترک قرار نمی‌گیرند. یک وابستگی مشترک تقریباً همیشه خارج از فرآیند برنامه قرار دارد، اما عکس آن درست نیست (به شکل 2.5 نگاه کنید). برای اینکه یک وابستگی خارج از فرآیند مشترک باشد، باید امکان ارتباط تست‌های واحد با یکدیگر را فراهم کند. این ارتباط از طریق تغییرات در وضعیت داخلی وابستگی انجام می‌شود. از این نظر، یک وابستگی خارج از فرآیند ثابت چنین امکانی را فراهم نمی‌کند. تست‌ها نمی‌توانند چیزی در آن را تغییر دهند و بنابراین نمی‌توانند با زمینه اجرای یکدیگر تداخل داشته باشند.

<p align="center">
    <img src="../Part 2/Images/figure-2.5.jpeg" />
</p>

به عنوان مثال، اگر یک API وجود دارد که کاتالوگی از تمام محصولات سازمان را برمی‌گرداند، این یک وابستگی مشترک نیست تا زمانی که API عملکردی برای تغییر کاتالوگ ارائه ندهد. درست است که چنین وابستگی‌ای متغیر است و خارج از محدوده برنامه قرار دارد، اما از آنجا که تست‌ها نمی‌توانند داده‌هایی که برمی‌گرداند را تغییر دهند، مشترک نیست. این به این معنا نیست که شما باید چنین وابستگی‌ای را در دامنه تست قرار دهید. در بیشتر موارد، هنوز هم باید آن را با یک test double جایگزین کنید تا تست سریع بماند. اما اگر وابستگی خارج از فرآیند به اندازه کافی سریع باشد و ارتباط با آن پایدار باشد، می‌توانید دلیل خوبی برای استفاده از آن به همان صورت در تست‌ها بیاورید.

با این حال، در این کتاب، من از اصطلاحات وابستگی مشترک و وابستگی خارج از فرآیند به طور متناوب استفاده می‌کنم مگر اینکه صریحاً غیر از این بگویم. در پروژه‌های دنیای واقعی، شما به ندرت وابستگی مشترکی دارید که خارج از فرآیند نباشد. اگر یک وابستگی در فرآیند باشد، می‌توانید به راحتی یک نمونه جداگانه از آن را به هر تست ارائه دهید؛ نیازی به اشتراک‌گذاری آن بین تست‌ها نیست. به طور مشابه، معمولاً با یک وابستگی خارج از فرآیند که مشترک نباشد روبرو نمی‌شوید. بیشتر چنین وابستگی‌هایی قابل تغییر هستند و بنابراین توسط تست‌ها قابل تغییر می‌باشند.

### 2.3 مقایسه سبک‌های کلاسیک و لندن در تست واحد

برای تأکید مجدد، تفاوت اصلی بین سبک‌های کلاسیک و لندن در نحوه برخورد آنها با مسئله جداسازی در تعریف تست واحد است. این موضوع به نوبه خود به برخورد با واحد - چیزی که باید تحت تست قرار گیرد - و رویکرد مدیریت وابستگی‌ها منجر می‌شود.

همانطور که قبلاً اشاره کردم، من سبک کلاسیک تست واحد را ترجیح می‌دهم. این سبک تمایل دارد تست‌های با کیفیت‌تری تولید کند و بنابراین برای دستیابی به هدف نهایی تست واحد، که رشد پایدار پروژه شماست، مناسب‌تر است. دلیل این موضوع شکنندگی است: تست‌هایی که از mocks استفاده می‌کنند تمایل به شکننده‌تر بودن نسبت به تست‌های کلاسیک دارند (بیشتر در این مورد در فصل 5 صحبت می‌کنم). فعلاً، بیایید نکات اصلی فروش سبک لندن را یکی یکی ارزیابی کنیم.

رویکرد سبک لندن مزایای زیر را فراهم می‌کند:

-   **جزئیات بهتر**. تست‌ها دقیق هستند و فقط یک کلاس را در یک زمان بررسی می‌کنند.
-   **آسان‌تر شدن تست واحد یک گراف بزرگ از کلاس‌های متصل**. از آنجا که همه وابستگی‌ها با test double‌ها جایگزین شده‌اند، در زمان نوشتن تست نیازی به نگرانی درباره آنها ندارید.
-   **اگر تست شکست بخورد، مطمئن هستید که کدام عملکرد شکست خورده است**. بدون وابستگی‌های کلاس، نمی‌تواند مشکوک دیگری جز کلاس تحت تست باشد. البته، هنوز ممکن است موقعیت‌هایی وجود داشته باشد که سیستم تحت تست از یک value object استفاده می‌کند و این تغییر در این value object باعث شکست تست می‌شود. اما این موارد چندان مکرر نیستند زیرا تمام وابستگی‌های دیگر در تست‌ها حذف شده‌اند.

### 2.3.1 تست واحد یک کلاس در یک زمان

نکته مربوط به جزئیات بهتر به بحث درباره اینکه چه چیزی یک واحد در تست واحد را تشکیل می‌دهد، مربوط می‌شود. سبک لندن یک کلاس را به عنوان چنین واحدی در نظر می‌گیرد. از دیدگاه برنامه‌نویسی شیءگرا، توسعه‌دهندگان معمولاً کلاس‌ها را به عنوان بلوک‌های سازنده اتمی که در اساس هر پایگاه کدی قرار دارند، در نظر می‌گیرند. این به طور طبیعی منجر به برخورد با کلاس‌ها به عنوان واحدهای اتمی که باید در تست‌ها تأیید شوند، نیز می‌شود. این تمایل قابل درک اما گمراه‌کننده است.

نکته: تست‌ها نباید واحدهای کد را تأیید کنند. بلکه باید واحدهای رفتار را تأیید کنند: چیزی که برای حوزه مسئله معنا دارد و ایدئالاً، چیزی که یک فرد تجاری می‌تواند به عنوان مفید تشخیص دهد. تعداد کلاس‌هایی که برای پیاده‌سازی چنین واحد رفتاری نیاز است، بی‌ربط است. واحد می‌تواند چندین کلاس یا فقط یک کلاس را در بر گیرد یا حتی تنها یک متد کوچک را اشغال کند.

بنابراین، هدف قرار دادن جزئیات بهتر کد کمکی نمی‌کند. تا زمانی که تست یک واحد رفتار را بررسی کند، یک تست خوب است. هدف قرار دادن چیزی کمتر از آن می‌تواند در واقع به تست‌های واحد شما آسیب برساند، زیرا فهمیدن دقیق اینکه این تست‌ها چه چیزی را تأیید می‌کنند، دشوارتر می‌شود. تست باید داستانی درباره مسئله‌ای که کد شما به حل آن کمک می‌کند بگوید و این داستان باید منسجم و برای یک غیر برنامه‌نویس معنادار باشد.

برای مثال، این یک مثال از یک داستان منسجم است: وقتی سگم را صدا می‌زنم، مستقیماً به سمت من می‌آید. حالا آن را با داستان زیر مقایسه کنید: وقتی سگم را صدا می‌زنم، ابتدا پای جلوی چپش را حرکت می‌دهد، سپس پای جلوی راست، سرش را می‌چرخاند، دمش شروع به تکان خوردن می‌کند...

داستان دوم خیلی کمتر معنا دارد. هدف همه این حرکات چیست؟ آیا سگ به سمت من می‌آید؟ یا فرار می‌کند؟ نمی‌توانید بگویید. این همان چیزی است که تست‌های شما شروع به شبیه شدن به آن می‌کنند وقتی که کلاس‌های فردی (پاها، سر و دم سگ) را هدف قرار می‌دهید به جای رفتار واقعی (سگ به سمت صاحبش می‌آید). بیشتر درباره این موضوع رفتار قابل مشاهده و چگونگی تفکیک آن از جزئیات پیاده‌سازی داخلی در فصل 5 صحبت می‌کنم.

### 2.3.2 تست واحد یک گراف بزرگ از کلاس‌های متصل

استفاده از mocks به جای وابستگی‌های واقعی می‌تواند تست یک کلاس را آسان‌تر کند - به خصوص زمانی که یک گراف وابستگی پیچیده وجود دارد، جایی که کلاس تحت تست دارای وابستگی‌هایی است که هر یک به وابستگی‌های خود متکی هستند و به همین ترتیب، چندین لایه عمیق. با test double‌ها، می‌توانید وابستگی‌های فوری کلاس را جایگزین کنید و بنابراین گراف را بشکنید، که می‌تواند به طور قابل توجهی مقدار آماده‌سازی‌هایی را که باید در یک تست واحد انجام دهید کاهش دهد. اگر از سبک کلاسیک پیروی کنید، باید گراف شیء کامل را (به جز وابستگی‌های مشترک) فقط برای آماده‌سازی سیستم تحت تست بازسازی کنید، که می‌تواند کار زیادی باشد.

اگرچه همه این‌ها درست است، اما این خط استدلال بر روی مشکل اشتباهی متمرکز است. به جای پیدا کردن راه‌هایی برای تست یک گراف بزرگ و پیچیده از کلاس‌های متصل، باید تمرکز کنید که اصلاً چنین گراف کلاسی نداشته باشید. اغلب اوقات، یک گراف بزرگ کلاس نتیجه یک مشکل در طراحی کد است.

در واقع خوب است که تست‌ها این مشکل را نشان می‌دهند. همانطور که در فصل 1 بحث کردیم، توانایی تست واحد یک قطعه کد یک شاخص منفی خوب است - پیش‌بینی می‌کند که کیفیت کد پایین است با دقت نسبتاً بالایی. اگر ببینید که برای تست واحد یک کلاس نیاز به گسترش مرحله ترتیب تست فراتر از همه محدودیت‌های منطقی دارید، این یک نشانه قطعی از مشکل است. استفاده از mocks فقط این مشکل را پنهان می‌کند؛ به ریشه مشکل نمی‌پردازد. من درباره چگونگی رفع مشکل طراحی کد زیربنایی در بخش 2 صحبت می‌کنم.

### 2.3.3 مشخص کردن محل دقیق باگ

اگر باگی را به سیستمی با تست‌های سبک لندن معرفی کنید، معمولاً تنها تست‌هایی که سیستم تحت تست آن‌ها شامل باگ است، شکست می‌خورند. اما با رویکرد کلاسیک، تست‌هایی که مشتریان کلاس خراب را هدف قرار می‌دهند نیز می‌توانند شکست بخورند. این منجر به یک اثر موجی می‌شود که در آن یک باگ می‌تواند باعث شکست تست‌ها در سراسر سیستم شود. در نتیجه، پیدا کردن ریشه مشکل سخت‌تر می‌شود. ممکن است نیاز به صرف زمان برای دیباگ تست‌ها برای فهمیدن مشکل داشته باشید.

این یک نگرانی معتبر است، اما من آن را به عنوان یک مشکل بزرگ نمی‌بینم. اگر تست‌های خود را به طور منظم اجرا کنید (به طور ایدئال، بعد از هر تغییر در کد منبع)، پس می‌دانید چه چیزی باعث باگ شده است - چیزی که آخرین بار ویرایش کرده‌اید، بنابراین پیدا کردن مشکل چندان سخت نیست. همچنین، نیازی نیست به تمام تست‌های شکست خورده نگاه کنید. رفع یک مشکل به طور خودکار تمام مشکلات دیگر را نیز رفع می‌کند.

علاوه بر این، ارزش خاصی در شکست‌های گسترده در سراسر مجموعه تست وجود دارد. اگر یک باگ منجر به خرابی نه تنها یک تست بلکه تعداد زیادی از آن‌ها شود، نشان می‌دهد که قطعه کدی که خراب کرده‌اید از اهمیت بالایی برخوردار است - کل سیستم به آن وابسته است. این اطلاعات مفیدی است که باید در هنگام کار با کد به خاطر داشته باشید.

### 2.3.4 تفاوت‌های دیگر بین سبک‌های کلاسیک و لندن

دو تفاوت باقی‌مانده بین سبک‌های کلاسیک و لندن عبارتند از:

-   رویکرد آن‌ها به طراحی سیستم با توسعه تست محور (TDD)
-   مسئله بیش از حد مشخص کردن

#### توسعه تست محور (TDD)

توسعه تست محور یک فرآیند توسعه نرم‌افزار است که بر تست‌ها برای هدایت توسعه پروژه تکیه دارد. این فرآیند شامل سه (برخی نویسندگان چهار) مرحله است که برای هر مورد تست تکرار می‌کنید:

1.  نوشتن یک تست شکست خورده برای نشان دادن عملکردی که باید اضافه شود و چگونه باید رفتار کند.
2.  نوشتن فقط به اندازه کافی کد برای عبور از تست. در این مرحله، کد نیازی به زیبا یا تمیز بودن ندارد.
3.  بازسازی کد. تحت حفاظت تست‌های عبوری، می‌توانید به طور ایمن کد را تمیز کنید تا خواناتر و قابل نگهداری‌تر شود.

منابع خوبی در این موضوع دو کتابی هستند که قبلاً توصیه کردم: توسعه تست محور: با مثال نوشته کنت بک، و رشد نرم‌افزار شی‌گرا، هدایت شده توسط تست‌ها نوشته استیو فریمن و نت پرایس.

سبک لندن تست واحد به TDD از بیرون به داخل منجر می‌شود، جایی که از تست‌های سطح بالاتر که انتظارات را برای کل سیستم تنظیم می‌کنند، شروع می‌کنید. با استفاده از mocks، شما مشخص می‌کنید که سیستم باید با کدام همکاران ارتباط برقرار کند تا نتیجه مورد انتظار را به دست آورد. سپس راه خود را از طریق گراف کلاس‌ها طی می‌کنید تا هر یک از آن‌ها را پیاده‌سازی کنید. mocks این فرآیند طراحی را ممکن می‌سازند زیرا می‌توانید بر روی یک کلاس در یک زمان تمرکز کنید. شما می‌توانید تمام وابستگی‌های سیستم تحت تست را در هنگام تست آن جدا کنید و بنابراین پیاده‌سازی آن وابستگی‌ها را به زمان بعد موکول کنید.

سبک کلاسیک راهنمایی مشابهی ارائه نمی‌دهد زیرا باید با اشیای واقعی در تست‌ها سر و کار داشته باشید. در عوض، معمولاً از رویکرد از داخل به خارج استفاده می‌کنید. در این سبک، از مدل دامنه شروع می‌کنید و سپس لایه‌های اضافی را بر روی آن قرار می‌دهید تا نرم‌افزار برای کاربر نهایی قابل استفاده شود.

اما تفاوت اساسی بین سبک‌ها مسئله بیش از حد مشخص کردن است: یعنی، وابسته کردن تست‌ها به جزئیات پیاده‌سازی سیستم تحت تست. سبک لندن تمایل به تولید تست‌هایی دارد که بیشتر از سبک کلاسیک به پیاده‌سازی وابسته می‌شوند. و این مهم‌ترین اعتراض به استفاده گسترده از mocks و سبک لندن به طور کلی است.

موضوع mocking بسیار گسترده‌تر است. از فصل 4 شروع می‌کنم و به تدریج همه چیزهای مربوط به آن را پوشش می‌دهم.

### 2.4 تست‌های یکپارچه در دو سبک

سبک‌های لندن و کلاسیک نیز در تعریف تست یکپارچه اختلاف دارند. این اختلاف به طور طبیعی از تفاوت دیدگاه آن‌ها در مورد مسئله جداسازی ناشی می‌شود.

سبک لندن هر تستی که از یک شیء همکار واقعی استفاده می‌کند را یک تست یکپارچه می‌داند. بیشتر تست‌هایی که در سبک کلاسیک نوشته شده‌اند، توسط حامیان سبک لندن تست یکپارچه در نظر گرفته می‌شوند. برای مثال، به لیست 1.4 نگاه کنید، جایی که برای اولین بار دو تست پوشش دهنده عملکرد خرید مشتری را معرفی کردم. آن کد یک تست واحد معمولی از دیدگاه کلاسیک است، اما از نظر یک پیرو سبک لندن، یک تست یکپارچه است.

در این کتاب، من از تعاریف کلاسیک هر دو تست واحد و تست یکپارچه استفاده می‌کنم. دوباره، یک تست واحد یک تست خودکار است که ویژگی‌های زیر را دارد:

-   یک قطعه کوچک از کد را تأیید می‌کند،
-   این کار را سریع انجام می‌دهد،
-   و این کار را به صورت مجزا انجام می‌دهد.

حالا که توضیح دادم اولین و سومین ویژگی به چه معنا هستند، آن‌ها را از دیدگاه سبک کلاسیک دوباره تعریف می‌کنم. یک تست واحد، تستی است که

-   یک واحد رفتار را تأیید می‌کند،
-   این کار را سریع انجام می‌دهد،
-   و این کار را به صورت مجزا از سایر تست‌ها انجام می‌دهد.

بنابراین، یک تست یکپارچه تستی است که یکی از این معیارها را برآورده نمی‌کند. برای مثال، تستی که به یک وابستگی مشترک متصل می‌شود - مثلاً یک پایگاه داده - نمی‌تواند به صورت مجزا از سایر تست‌ها اجرا شود. تغییری در وضعیت پایگاه داده که توسط یک تست معرفی می‌شود، نتیجه تمام تست‌های دیگر که به همان پایگاه داده وابسته هستند را تغییر می‌دهد اگر به صورت موازی اجرا شوند. باید اقدامات اضافی برای جلوگیری از این تداخل انجام دهید. به طور خاص، باید چنین تست‌هایی را به صورت متوالی اجرا کنید، تا هر تست نوبت خود را برای کار با وابستگی مشترک منتظر بماند.

به طور مشابه، ارتباط با یک وابستگی خارج از فرآیند باعث کندی تست می‌شود. یک فراخوانی به یک پایگاه داده صدها میلی‌ثانیه، احتمالاً تا یک ثانیه، زمان اجرای اضافی اضافه می‌کند. میلی‌ثانیه‌ها در ابتدا ممکن است مسئله بزرگی به نظر نرسند، اما وقتی مجموعه تست شما به اندازه کافی بزرگ شود، هر ثانیه مهم است.

در تئوری، می‌توانید یک تست کند که فقط با اشیای در حافظه کار می‌کند بنویسید، اما این کار به این سادگی نیست. ارتباط بین اشیا در داخل همان فضای حافظه بسیار کمتر از بین فرآیندهای جداگانه هزینه دارد. حتی اگر تست با صدها شیء در حافظه کار کند، ارتباط با آن‌ها هنوز سریع‌تر از یک فراخوانی به یک پایگاه داده اجرا خواهد شد.

در نهایت، یک تست یکپارچه زمانی است که دو یا چند واحد رفتار را تأیید می‌کند. این اغلب نتیجه تلاش برای بهینه‌سازی سرعت اجرای مجموعه تست است. وقتی دو تست کند دارید که مراحل مشابهی را دنبال می‌کنند اما واحدهای رفتار مختلفی را تأیید می‌کنند، ممکن است منطقی باشد که آن‌ها را به یک تست ترکیب کنید: یک تست که دو چیز مشابه را بررسی می‌کند سریع‌تر از دو تست جزئی‌تر اجرا می‌شود. اما باز هم، دو تست اصلی قبلاً تست یکپارچه بوده‌اند (به دلیل کند بودن)، بنابراین این ویژگی معمولاً تعیین‌کننده نیست.

یک تست یکپارچه همچنین می‌تواند تأیید کند که چگونه دو یا چند ماژول که توسط تیم‌های جداگانه توسعه داده شده‌اند، با هم کار می‌کنند. این نیز به سطل سوم تست‌هایی که چندین واحد رفتار را یکجا تأیید می‌کنند می‌افتد. اما باز هم، به دلیل اینکه چنین یکپارچگی معمولاً نیاز به یک وابستگی خارج از فرآیند دارد، تست تمام سه معیار را رعایت نخواهد کرد، نه فقط یکی.

تست یکپارچه نقش مهمی در کمک به کیفیت نرم‌افزار با تأیید سیستم به عنوان یک کل دارد. من در قسمت 3 به تفصیل در مورد تست یکپارچه صحبت می‌کنم.

### 2.4.1 تست‌های End-to-End یک زیر مجموعه از تست‌های یکپارچه هستند

به طور خلاصه، یک تست یکپارچه تستی است که تأیید می‌کند کد شما در ادغام با وابستگی‌های مشترک، وابستگی‌های خارج از فرآیند یا کدی که توسط تیم‌های دیگر در سازمان توسعه داده شده است، کار می‌کند. همچنین مفهوم جداگانه‌ای از تست انتها به انتها وجود دارد. تست‌های انتها به انتها یک زیر مجموعه از تست‌های یکپارچه هستند. آن‌ها نیز بررسی می‌کنند که چگونه کد شما با وابستگی‌های خارج از فرآیند کار می‌کند. تفاوت بین یک تست انتها به انتها و یک تست یکپارچه این است که تست‌های انتها به انتها معمولاً شامل بیشتر این وابستگی‌ها هستند.

خط در اینجا گاهی تار است، اما به طور کلی، یک تست یکپارچه با تنها یک یا دو وابستگی خارج از فرآیند کار می‌کند. از سوی دیگر، یک تست انتها به انتها با همه وابستگی‌های خارج از فرآیند، یا با اکثریت آن‌ها کار می‌کند. بنابراین نام "انتها به انتها"، که به این معنی است که تست سیستم را از دید کاربر نهایی تأیید می‌کند، شامل همه برنامه‌های خارجی که این سیستم با آن‌ها یکپارچه شده است (به شکل 2.6 نگاه کنید).

مردم همچنین از اصطلاحاتی مانند تست‌های UI (UI مخفف رابط کاربری) ، تست‌های GUI (GUI مخفف رابط کاربری گرافیکی) و تست‌های کاربردی استفاده می‌کنند. اصطلاحات به خوبی تعریف نشده‌اند، اما به طور کلی، این اصطلاحات هم‌معنی هستند.

فرض کنید برنامه شما با سه وابستگی خارج از فرآیند کار می‌کند: یک پایگاه داده، سیستم فایل، و یک درگاه پرداخت. یک تست یکپارچه معمولی تنها پایگاه داده و سیستم فایل را در دامنه قرار می‌دهد و از یک test double برای جایگزینی درگاه پرداخت استفاده می‌کند. این به این دلیل است که شما کنترل کامل بر پایگاه داده و سیستم فایل دارید و بنابراین می‌توانید به راحتی آن‌ها را در تست‌ها به وضعیت مورد نیاز برسانید، در حالی که کنترل مشابهی بر درگاه پرداخت ندارید. با درگاه پرداخت، ممکن است نیاز به تماس با سازمان پردازش پرداخت برای تنظیم یک حساب تست خاص داشته باشید. همچنین ممکن است نیاز به بررسی دوره‌ای آن حساب برای پاکسازی دستی تمام هزینه‌های پرداخت باقی‌مانده از اجرای تست‌های گذشته داشته باشید.

از آنجا که تست‌های انتها به انتها از نظر نگهداری پرهزینه‌ترین هستند، بهتر است آن‌ها را در مراحل پایانی فرآیند ساخت اجرا کنید، بعد از اینکه تمام تست‌های واحد و یکپارچه عبور کرده باشند. ممکن است حتی فقط آن‌ها را روی سرور ساخت اجرا کنید، نه روی ماشین‌های توسعه‌دهندگان فردی.

به خاطر داشته باشید که حتی با تست‌های انتها به انتها، ممکن است نتوانید همه وابستگی‌های خارج از فرآیند را پوشش دهید. ممکن است نسخه تستی از برخی وابستگی‌ها وجود نداشته باشد، یا ممکن است نتوانید آن وابستگی‌ها را به وضعیت مورد نیاز به صورت خودکار برسانید. بنابراین ممکن است هنوز هم نیاز به استفاده از یک test double داشته باشید، که این واقعیت را تقویت می‌کند که خط مشخصی بین تست‌های یکپارچه و انتها به انتها وجود ندارد.

<p align="center">
    <img src="../Part 2/Images/figure-2.6.jpeg" />
</p>

</div>
<div dir="rtl" lang="fa">

### فصل 7: بازسازی (Refactor) به سمت Unit Test های ارزشمند

#### در فصل 1، ویژگی‌های یک مجموعه Unit Test خوب را تعریف کردم:

 - در چرخه توسعه یکپارچه شده است
 - تنها بخش‌های مهم کد شما را هدف قرار می‌دهد
 - حداکثر ارزش را با حداقل هزینه نگهداری فراهم می‌کند
 #### برای دستیابی به این ویژگی آخر، شما باید قادر باشید:
- یک تست ارزشمند را تشخیص دهید(و به‌تبع، یک تست کم‌ارزش)
- یک تست ارزشمند بنویسید

فصل 4 به موضوع تشخیص تست ارزشمند با استفاده از چهار ویژگی پرداخت: حفاظت در برابر بازگشت به عقب، مقاومت در برابر بازسازی، بازخورد سریع و نگهداری. و فصل 5 به توضیح در مورد مهم‌ترین یکی از این چهار  ویژگی: "مقاومت در برابر بازسازی" پرداخت   

همانطور که قبلاً اشاره کردم، تنها تشخیص تست‌های ارزشمند کافی نیست، شما باید بتوانید چنین تست‌هایی را نیز بنویسید. مهارت دوم به اولی نیاز دارد، اما همچنین نیاز به آگاهی از تکنیک‌های طراحی کد دارد. تست‌های واحد و کدهای زیرین آن‌ها به شدت به هم وابسته هستند و بدون 
صرف تلاش در کدی که تحت پوشش تست است، نمی‌توان تست‌های ارزشمندی نوشت.

در فصل 6، نمونه‌ای از تبدیل کد پایه را دیدید که در آن سیستم نظارتی را به سمت معماری تابعی (Functional Architecture) تغییر دادیم و در نتیجه توانستیم از تست‌های مبتنی بر خروجی استفاده کنیم. این فصل این رویکرد را به دامنه وسیع‌تری از برنامه‌ها گسترش می‌دهد، از جمله برنامه‌هایی که نمی‌توانند از معماری تابعی استفاده کنند. دستورالعمل‌های عملی برای نوشتن تست‌های ارزشمند در تقریباً هر پروژه نرم‌افزاری را خواهید دید.

### 7.1 شناسایی کد برای بازسازی
به ندرت امکان بهبود قابل‌توجه یک مجموعه تست بدون بازسازی کد(Refactor) وجود دارد. هیچ راهی جز این وجود ندارد—تست و کد به طور ذاتی به هم متصل هستند. در این بخش، خواهید دید که چگونه کد خود را به چهار بخش تقسیم‌بندی کنید تا جهت بازسازی را مشخص کنید. بخش‌های بعدی یک مثال جامع را نشان می‌دهند

#### 7.1.1 چهار نوع کد
در این بخش، چهار بخش کد را که پایه‌گذار بقیه این فصل هستند، توضیح می‌دهم. 

##### تمام کدهای تولید را می‌توان در دو بعد دسته‌بندی کرد:

پیچیدگی یا اهمیت دامین (Complexity or domain significance )

تعداد وابستگی ها (The number of collaborators)

پیچیدگی کد با تعداد نقاط تصمیم‌گیری در کد تعریف می‌شود. هرچه این تعداد بیشتر باشد، پیچیدگی بالاتر است.

![](Images/pic%207.1.png)

> ##### (cyclomatic complexity) نحوه محاسبه پیچیدگی سیکلوماتیک
```
در علم کامپیوتر، یک اصطلاح خاص برای توصیف پیچیدگی کد وجود دارد: پیچیدگی سیکلوماتیک. پیچیدگی سیکلوماتیک نشان‌دهنده تعداد شاخه‌ها در یک برنامه یا متد است. این معیار به صورت زیر محاسبه می‌شود: ۱ + تعداد نقاط انشعاب

بنابراین، یک متد بدون هیچ دستور کنترلی (مانند دستورهای if یا حلقه‌های شرطی) دارای پیچیدگی سیکلوماتیک ۱ + ۰ = ۱ است.

این معیار به معنای دیگری هم اشاره دارد. می‌توانید آن را به تعداد مسیرهای مستقل از ورودی به خروجی در یک متد یا تعداد تست‌های مورد نیاز برای پوشش کامل شاخه‌ها تفسیر کنید.

توجه داشته باشید که تعداد نقاط انشعاب به تعداد ساده‌ترین شرایط درگیر شده شمارش می‌شود. برای مثال، یک عبارت مانند IF condition1 AND condition2 THEN ... معادل با IF condition1 THEN IF condition2 THEN ... است. بنابراین، پیچیدگی آن ۱ + ۲ = ۳ خواهد بود.
```

**اهمیت دامین** نشان می‌دهد که کد چقدر برای مشکل دامین پروژه شما مهم است. معمولاً تمام کدها در لایه دامنه ارتباط مستقیمی با اهداف کاربران نهایی دارند و بنابراین دامین اهمیت  بالایی دارند. از سوی دیگر، کدهای کمکی (utility code) چنین ارتباطی ندارند.

کد پیچیده و کدی که اهمیت دامین دارد از Unit Test بیشترین بهره را می‌برد زیرا تست‌های مربوطه حفاظت خوبی در برابر بازگشت به عقب دارند. توجه داشته باشید که کد دامنه نیازی به پیچیدگی ندارد، و کد پیچیده نیازی به نمایش اهمیت دامین ندارد تا قابل تست باشد. این دو مؤلفه مستقل از یکدیگر هستند. برای مثال، یک روش محاسبه قیمت سفارش ممکن است هیچ شرطی نداشته باشد و بنابراین پیچیدگی سیکلوماتیک 
1 داشته باشد. با این حال، تست چنین روشی مهم است زیرا نمایانگر عملکرد حیاتی کسب و کار است.


بخش دوم, تعداد collaborators های که یک کلاس یا متد . همانطور که ممکن است از فصل 2 به خاطر بیاورید، collaborators یک وابستگی است که یا متغیر است یا خارج از فرآیند (یا هر دو). کدی با تعداد زیادی collaborators هزینه‌های بالایی برای تست دارد. این به دلیل معیار نگهداری است که به اندازه تست بستگی دارد. آماده‌سازی collaborators به یک وضعیت مورد انتظار و سپس بررسی وضعیت یا تعاملات آن‌ها پس از آن فضا می‌برد. و هرچه تعداد collaborators بیشتر باشد، تست بزرگتر می‌شود.

نوع collaborators نیز مهم است. collaborators خارج از فرآیند وقتی به مدل دامنه می‌رسند نباید استفاده شوند. آن‌ها هزینه‌های نگهداری اضافی دارند به دلیل نیاز به نگهداری ماشین‌های تقلید پیچیده در تست‌ها. همچنین باید بسیار محتاط باشید و فقط از تقلیدها برای بررسی تعاملات که مرزهای برنامه را عبور می‌کنند استفاده کنید تا مقاومت صحیح در برابر بازسازی حفظ شود (برای جزئیات بیشتر به فصل 5 مراجعه کنید). بهتر است تمام ارتباطات با وابستگی‌های خارج از فرآیند به کلاس‌هایی خارج از لایه دامنه واگذار شود. سپس کلاس‌های دامنه فقط با وابستگی‌های در فرآیند کار خواهند کرد.

توجه داشته باشید که collaborators ضمنی و صریح هر دو به تعداد collaborators شمارش می‌شوند. اهمیتی ندارد اگر سیستم تحت تست (SUT) collaborators را به عنوان یک آرگومان بپذیرد یا به طور ضمنی از طریق یک روش استاتیک به آن اشاره کند، هنوز باید این همکار را در تست‌ها تنظیم کنید. در مقابل، وابستگی‌های غیرمتغیر (مقادیر یا اشیای ارزش) شمارش نمی‌شوند. تنظیم و بررسی این وابستگی‌ها بسیار آسان‌تر است.

ترکیب پیچیدگی کد، اهمیت دامین آن، و تعداد collaborators چهار نوع کد را به ما می‌دهد.

### 7.2 بازسازی به سمت تست‌های واحد ارزشمند
در این بخش، یک مثال جامع از تقسیم کد پیچیده به الگوریتم‌ها و کنترلرها را نشان می‌دهم. شما یک مثال مشابه در فصل قبلی دیدید، جایی که در مورد تست مبتنی بر خروجی و معماری تابعی صحبت کردیم. این بار، این رویکرد را به همه برنامه‌های سطح سازمانی با کمک الگوی "شیء فروتن"(Human Object Pattern) عمومی‌سازی خواهم کرد.

معرفی یک سیستم مدیریت مشتری
پروژه نمونه یک سیستم مدیریت مشتری (CRM) است که ثبت‌نام کاربران را انجام می‌دهد. تمام کاربران در یک پایگاه داده ذخیره می‌شوند. سیستم در حال حاضر فقط از یک مورد کاربردی پشتیبانی می‌کند: تغییر ایمیل کاربر. در این عملیات سه قانون کسب‌وکار وجود دارد:

اگر ایمیل کاربر به دامنه شرکت تعلق داشته باشد، آن کاربر به عنوان کارمند علامت‌گذاری می‌شود. در غیر این صورت، به عنوان مشتری تلقی می‌شود.
سیستم باید تعداد کارمندان شرکت را دنبال کند. اگر نوع کاربر از کارمند به مشتری تغییر کند، یا بالعکس، این تعداد نیز باید تغییر کند.
وقتی ایمیل تغییر می‌کند، سیستم باید سیستم‌های خارجی را با ارسال یک پیام به یک اتوبوس پیام‌رسان مطلع کند.
فهرست بالا پیاده‌سازی اولیه سیستم CRM را نشان می‌دهد.

<div dir="ltr">

```csharp
public class User
{
    public int UserId { get; private set; }
    public string Email { get; private set; }
    public UserType Type { get; private set; }

    public void ChangeEmail(int userId, string newEmail)
    {
        object[] data = Database.GetUserById(userId);    
        UserId = userId;
        Email = (string)data[1];
        Type = (UserType)data[2];

        if (Email == newEmail)
            return;

        object[] companyData = Database.GetCompany();       
        string companyDomainName = (string)companyData[0];
        int numberOfEmployees = (int)companyData[1];

        string emailDomain = newEmail.Split('@')[1];
        bool isEmailCorporate = emailDomain == companyDomainName;
        UserType newType = isEmailCorporate ? UserType.Employee : UserType.Customer;                        

        if (Type != newType)
        {
            int delta = newType == UserType.Employee ? 1 : -1;
            int newNumber = numberOfEmployees + delta;
            Database.SaveCompany(newNumber);        
        }

        Email = newEmail;
        Type = newType;

        Database.SaveUser(this);              
        MessageBus.SendEmailChangedMessage(UserId, newEmail);       
    }
}

public enum UserType
{
    Customer = 1,
    Employee = 2
}
```

</div>

کلاس User تغییر ایمیل کاربر را انجام می‌دهد. توجه داشته باشید که برای اختصار، اعتبارسنجی‌های ساده مانند بررسی صحت ایمیل و وجود کاربر در پایگاه داده را حذف کردم. اجازه دهید این پیاده‌سازی را از دیدگاه نمودار انواع کد تحلیل کنیم.

پیچیدگی کد چندان بالا نیست. روش ChangeEmail تنها شامل چند نقطه تصمیم‌گیری آشکار است: تعیین اینکه کاربر به عنوان کارمند یا مشتری شناسایی شود و چگونگی به‌روزرسانی تعداد کارمندان شرکت. علیرغم سادگی، این تصمیم‌ها مهم هستند: آن‌ها منطق اصلی کسب‌وکار برنامه را تشکیل می‌دهند. بنابراین، کلاس در بُعد پیچیدگی و اهمیت دامین امتیاز بالایی کسب می‌کند.

از طرف دیگر، کلاس User چهار وابستگی دارد که دو تای آن‌ها صریح و دو تای دیگر ضمنی هستند. وابستگی‌های صریح، آرگومان‌های userId و newEmail هستند. این‌ها مقادیر هستند و بنابراین به تعداد collaborators کلاس محسوب نمی‌شوند. وابستگی‌های ضمنی، Database و MessageBus هستند. این دو collaborators خارج از فرآیند هستند. همانطور که قبلاً اشاره کردم، collaborators خارج از فرآیند نباید در کد با اهمیت دامین بالا وجود داشته باشند. بنابراین، کلاس User در بُعد collaborators امتیاز بالایی کسب می‌کند، که این کلاس را در دسته‌بندی کد پیچیده قرار می‌دهد.

این رویکرد—که در آن یک کلاس دامنه خود را از پایگاه داده بازیابی و ذخیره می‌کند—به الگوی "فعالیت رکورد" معروف است. این رویکرد در پروژه‌های ساده یا کوتاه‌مدت خوب عمل می‌کند اما در صورت افزایش کد پایه به مشکل برمی‌خورد. دلیل آن دقیقاً این عدم تفکیک بین این دو مسئولیت است: منطق کسب‌وکار و ارتباط با وابستگی‌های خارج از فرآیند.

7.2.2 تلاش اول: صریح‌کردن وابستگی‌های ضمنی
رویکرد معمول برای بهبود تست‌پذیری، صریح‌کردن وابستگی‌های ضمنی است: یعنی معرفی رابط‌هایی برای Database و MessageBus، تزریق این رابط‌ها به User، و سپس تقلید آن‌ها در تست‌ها. این رویکرد کمک می‌کند، و این دقیقاً کاری است که در فصل قبلی انجام دادیم وقتی پیاده‌سازی با تقلیدها را برای سیستم حسابرسی معرفی کردیم. اما این کافی نیست.

از دیدگاه نمودار انواع کد، مهم نیست که مدل دامنه مستقیماً به وابستگی‌های خارج از فرآیند اشاره کند یا از طریق یک رابط. چنین وابستگی‌هایی همچنان خارج از فرآیند هستند؛ آن‌ها واسطه‌هایی برای داده‌هایی هستند که هنوز در حافظه نیستند. هنوز نیاز به نگهداری ماشین‌های تقلید پیچیده برای تست چنین کلاس‌هایی دارید، که هزینه نگهداری تست‌ها را افزایش می‌دهد. علاوه بر این، استفاده از تقلیدها برای وابستگی پایگاه داده منجر به شکنندگی تست‌ها می‌شود (در فصل بعد به این موضوع خواهیم پرداخت).

به طور کلی، بهتر است مدل دامنه هیچ وابستگی خارج از فرآیندی نداشته باشد، مستقیم یا غیرمستقیم (از طریق یک رابط). این چیزی است که معماری شش ضلعی نیز توصیه می‌کند—مدل دامنه نباید مسئول ارتباط با سیستم‌های خارجی باشد.

7.2.3 تلاش دوم: معرفی لایه خدمات کاربردی
برای غلبه بر مشکل ارتباط مستقیم مدل دامنه با سیستم‌های خارجی، باید این مسئولیت را به کلاس دیگری منتقل کنیم، یک کنترلر فروتن (یک سرویس کاربردی، در اصطلاح معماری شش ضلعی). به عنوان یک قاعده کلی، کلاس‌های دامنه تنها باید به وابستگی‌های در فرآیند متکی باشند، مانند دیگر کلاس‌های دامنه یا مقادیر ساده. در اینجا نسخه اول آن سرویس کاربردی آمده است.

<div dir="ltr">

```csharp
public class UserController
{
    private readonly Database _database = new Database();
    private readonly MessageBus _messageBus = new MessageBus();

    public void ChangeEmail(int userId, string newEmail)
    {
        object[] data = _database.GetUserById(userId);
        string email = (string)data[1];
        UserType type = (UserType)data[2];
        var user = new User(userId, email, type);

        object[] companyData = _database.GetCompany();
        string companyDomainName = (string)companyData[0];
        int numberOfEmployees = (int)companyData[1];

        int newNumberOfEmployees = user.ChangeEmail(
            newEmail, companyDomainName, numberOfEmployees);

        _database.SaveCompany(newNumberOfEmployees);
        _database.SaveUser(user);
        _messageBus.SendEmailChangedMessage(userId, newEmail);
    }
}
</div>
```
این یک تلاش خوب اول است؛ سرویس کاربردی کمک کرد کار با وابستگی‌های خارج از فرآیند را از کلاس User بردارد. اما برخی مشکلات در این پیاده‌سازی وجود دارد:

وابستگی‌های خارج از فرآیند (Database و MessageBus) مستقیماً نمونه‌سازی شده‌اند، نه تزریق شده‌اند. این برای تست‌های یکپارچه‌ای که برای این کلاس خواهیم نوشت مشکل ایجاد خواهد کرد.
کنترلر یک نمونه User را از داده خامی که از پایگاه داده دریافت می‌کند بازسازی می‌کند. این منطق پیچیده است و بنابراین نباید متعلق به سرویس کاربردی باشد که تنها نقش هماهنگی را دارد، نه منطق پیچیده یا با اهمیت دامین.
همین مورد برای داده‌های شرکت صادق است. مشکل دیگر این داده‌ها این است که User اکنون یک تعداد کارمندان به‌روزشده را باز می‌گرداند، که درست به نظر نمی‌رسد. تعداد کارمندان شرکت هیچ ارتباطی با یک کاربر خاص ندارد. این مسئولیت باید به جای دیگری تعلق داشته باشد.
کنترلر داده‌های تغییر یافته را ذخیره و پیام‌ها را به اتوبوس پیام‌رسان می‌فرستد، بدون توجه به اینکه ایمیل جدید با ایمیل قبلی متفاوت است یا خیر.
کلاس User تست‌پذیرتر شده است زیرا دیگر نیازی به ارتباط با وابستگی‌های خارج از فرآیند ندارد. در واقع، هیچ همکار دیگری ندارد—چه خارج از فرآیند یا نه. در اینجا نسخه جدید روش ChangeEmail آمده است:

<div dir="ltr">

```csharp
public int ChangeEmail(string newEmail,
    string companyDomainName, int numberOfEmployees)
{
    if (Email == newEmail)
        return numberOfEmployees;

    string emailDomain = newEmail.Split('@')[1];
    bool isEmailCorporate = emailDomain == companyDomainName;
    UserType newType = isEmailCorporate ? UserType.Employee : UserType.Customer;

    if (Type != newType)
    {
        int delta = newType == UserType.Employee ? 1 : -1;
        int newNumber = numberOfEmployees + delta;
        numberOfEmployees = newNumber;
    }

    Email = newEmail;
    Type = newType;

    return numberOfEmployees;
}
```
</div>
نمودار 7.8 نشان می‌دهد که User و UserController اکنون در نمودار ما کجا قرار دارند. User به ربع مدل دامنه منتقل شده است، نزدیک به محور عمودی، زیرا دیگر نیازی به کار با collaborators ندارد. UserController مشکل‌سازتر است. اگرچه آن را در ربع کنترلرها قرار داده‌ام، اما تقریباً مرز با کد پیچیده را عبور کرده است زیرا شامل منطق پیچیده‌ای است.

7.2.4 تلاش سوم: حذف پیچیدگی از سرویس کاربردی
برای قرار دادن UserController به طور قاطع در ربع کنترلرها، باید منطق بازسازی را از آن استخراج کنیم. اگر از یک کتابخانه نگاشت شیء رابطه‌ای (ORM) برای نگاشت پایگاه داده به مدل دامنه استفاده کنید، این یک مکان خوب برای نسبت‌دادن منطق بازسازی است. هر کتابخانه ORM مکان مخصوصی دارد که می‌توانید مشخص کنید چگونه جداول پایگاه داده شما باید به کلاس‌های دامنه نگاشت شوند، مانند صفاتی که بر روی این کلاس‌های دامنه قرار می‌گیرند، فایل‌های XML، یا فایل‌های با نگاشت‌های روان.

اگر نمی‌خواهید یا نمی‌توانید از ORM استفاده کنید، یک کارخانه در مدل دامنه ایجاد کنید که کلاس‌های دامنه را با استفاده از داده‌های خام پایگاه داده نمونه‌سازی کند. این کارخانه می‌تواند یک کلاس جداگانه باشد یا برای موارد ساده‌تر، یک روش استاتیک در کلاس‌های دامنه موجود. منطق بازسازی در پروژه نمونه ما چندان پیچیده نیست، اما خوب است چنین چیزهایی را جدا نگه دارید، بنابراین من آن را در یک کلاس UserFactory جداگانه قرار می‌دهم همانطور که در فهرست زیر نشان داده شده است
.
<div dir="ltr">

```csharp
Copy code
public class UserFactory
{
    public static User Create(object[] data)
    {
        Precondition.Requires(data.Length >= 3);

        int id = (int)data[0];
        string email = (string)data[1];
        UserType type = (UserType)data[2];

        return new User(id, email, type);
    }
}
```
</div>
این کد اکنون به طور کامل از همه collaborators جدا شده و بنابراین به راحتی تست‌پذیر است. توجه داشته باشید که من یک محافظت در این روش قرار داده‌ام: الزامی که حداقل سه عنصر در آرایه داده وجود داشته باشد. Precondition یک کلاس ساده سفارشی است که اگر آرگومان بولی نادرست باشد استثنایی پرتاب می‌کند. دلیل این کلاس کد مختصرتر و وارونگی شرط است: اظهارات مثبت خواناتر از اظهارات منفی هستند. در مثال ما، الزامی که data.Length >= 3 بهتری نسبت به
<div dir="ltr">

```csharp
if (data.Length < 3)
    throw new Exception();
```
</div>
است. توجه داشته باشید که در حالی که این منطق بازسازی به نظر پیچیده نیست، اهمیت دامین ندارد: به طور مستقیم با هدف کاربر برای تغییر ایمیل کاربر مرتبط نیست. این یک مثال از کد کمکی است که در فصول قبلی به آن اشاره کردم.

7.2.5 تلاش چهارم: معرفی یک کلاس جدید Company
به این کد در کنترلر دوباره نگاه کنید:

<div dir="ltr">

```csharp
object[] companyData = _database.GetCompany();
string companyDomainName = (string)companyData[0];
int numberOfEmployees = (int)companyData[1];

int newNumberOfEmployees = user.ChangeEmail(
    newEmail, companyDomainName, numberOfEmployees);
```
</div>
اینکه User تعداد کارمندان را باز می‌گرداند یک علامت مسئولیت اشتباه است، که خود یک علامت انتزاع گمشده است. برای رفع این مشکل، باید یک کلاس دامنه دیگر، Company، معرفی کنیم که منطق و داده‌های مربوط به شرکت را با هم باندل می‌کند، همانطور که در فهرست زیر نشان داده شده است.
<div dir="ltr">

```csharp
public class Company
{
    public string DomainName { get; private set; }
    public int NumberOfEmployees { get; private set; }

    public void ChangeNumberOfEmployees(int delta)
    {
        Precondition.Requires(NumberOfEmployees + delta >= 0);
        NumberOfEmployees += delta;
    }

    public bool IsEmailCorporate(string email)
    {
        string emailDomain = email.Split('@')[1];
        return emailDomain == DomainName;
    }
}
```
</div>

کلاس جدید در لایه دامنه
دو روش در این کلاس وجود دارد: ChangeNumberOfEmployees() و IsEmailCorporate(). این روش‌ها به اصل "گفتن-پرسیدن نکنید" که در فصل 5 ذکر کردم کمک می‌کنند. این اصل توصیه می‌کند داده‌ها و عملیات روی آن داده‌ها را با هم باندل کنید. یک نمونه User به شرکت خواهد گفت که تعداد کارمندان خود را تغییر دهد یا تشخیص دهد که آیا یک ایمیل خاص شرکتی است یا نه؛ آن به داده‌های خام نمی‌پرسد و همه چیز را به تنهایی انجام نمی‌دهد.

همچنین یک کلاس CompanyFactory جدید وجود دارد که مسئول بازسازی اشیاء Company است، مشابه UserFactory. اینگونه است که کنترلر اکنون به نظر می‌رسد:

<div dir="ltr">

```csharp
public class UserController
{
    private readonly Database _database = new Database();
    private readonly MessageBus _messageBus = new MessageBus();

    public void ChangeEmail(int userId, string newEmail)
    {
        object[] userData = _database.GetUserById(userId);
        User user = UserFactory.Create(userData);

        object[] companyData = _database.GetCompany();
        Company company = CompanyFactory.Create(companyData);

        user.ChangeEmail(newEmail, company);

        _database.SaveCompany(company);
        _database.SaveUser(user);
        _messageBus.SendEmailChangedMessage(userId, newEmail);
    }
}
```
</div>
و در اینجا کلاس User:

<div dir="ltr">

```csharp
public class User
{
    public int UserId { get; private set; }
    public string Email { get; private set; }
    public UserType Type { get; private set; }

    public void ChangeEmail(string newEmail, Company company)
    {
        if (Email == newEmail)
            return;

        UserType newType = company.IsEmailCorporate(newEmail)
            ? UserType.Employee
            : UserType.Customer;

        if (Type != newType)
        {
            int delta = newType == UserType.Employee ? 1 : -1;
            company.ChangeNumberOfEmployees(delta);
        }

        Email = newEmail;
        Type = newType;
    }
}
```
</div>

توجه داشته باشید که حذف مسئولیت اشتباه User را بسیار تمیزتر کرده است. به جای کار با داده‌های شرکت، یک نمونه Company می‌پذیرد و دو بخش مهم کار را به آن نمونه واگذار می‌کند: تعیین اینکه آیا یک ایمیل شرکتی است و تغییر تعداد کارمندان در شرکت.

نمودار 7.9 نشان می‌دهد که هر کلاس در نمودار ما کجا قرار دارد. CompanyFactory و هر دو کلاس دامنه در ربع مدل دامنه و الگوریتم‌ها قرار دارند. User به سمت راست منتقل شده است زیرا اکنون یک همکار، Company، دارد، در حالی که قبلاً هیچ همکاری نداشت. این User را کمتر تست‌پذیر کرده است، اما نه چندان.

UserController اکنون به طور قاطع در ربع کنترلرها قرار دارد زیرا تمام پیچیدگی‌های آن به CompanyFactory منتقل شده است. تنها چیزی که این کلاس مسئول آن است، چسباندن همه 
طرف‌های همکار است

### 7.3 تحلیل پوشش بهینه تست واحد
اکنون که بازسازی با کمک الگوی شیء فروتن(Humble Object pattern) را به اتمام رساندیم، بیایید تحلیل کنیم که کدام قسمت‌های پروژه به کدام دسته کد تعلق دارند و چگونه باید آن‌ها را تست کنیم. جدول 7.1 تمام کدهای پروژه نمونه را پس از بازسازی با استفاده از الگوی شیء فروتن دسته‌بندی می‌کند.

با تفکیک کامل منطق کسب‌وکار و هماهنگی در دسترس، تصمیم‌گیری درباره کدام قسمت‌های کد پایه برای تست واحد آسان است.

7.3.1 تست لایه دامنه و کد کمکی
تست متدهای موجود در ربع بالا سمت چپ در جدول 7.1 بهترین نتایج را در اصطلاح هزینه-فایده فراهم می‌کند. پیچیدگی بالا یا اهمیت حوزه کد تضمین می‌کند که حفاظت خوبی در برابر بازگشت به عقب فراهم می‌کند، در حالی که داشتن تعداد کمی همکار، هزینه نگهداری تست‌ها را کاهش می‌دهد. این یک مثال از نحوه تست User است:

<div dir="ltr">

```csharp
[Fact]
public void Changing_email_from_non_corporate_to_corporate()
{
    var company = new Company("mycorp.com", 1);
    var sut = new User(1, "user@gmail.com", UserType.Customer);

    sut.ChangeEmail("new@mycorp.com", company);

    Assert.Equal(2, company.NumberOfEmployees);
    Assert.Equal("new@mycorp.com", sut.Email);
    Assert.Equal(UserType.Employee, sut.Type);
}

```
</div>

برای دستیابی به پوشش کامل، شما به سه تست دیگر نیاز دارید:

<div dir="ltr">

```csharp

public void Changing_email_from_corporate_to_non_corporate()
public void Changing_email_without_changing_user_type()
public void Changing_email_to_the_same_one()
تست‌های مربوط به سه کلاس دیگر حتی کوتاه‌تر خواهند بود، و می‌توانید از تست‌های پارامتری برای گروه‌بندی چندین مورد تست با هم استفاده کنید:

csharp
Copy code
[InlineData("mycorp.com", "email@mycorp.com", true)]
[InlineData("mycorp.com", "email@gmail.com", false)]
[Theory]
public void Differentiates_a_corporate_email_from_non_corporate(string domain, string email, bool expectedResult)
{
    var sut = new Company(domain, 0);

    bool isEmailCorporate = sut.IsEmailCorporate(email);

    Assert.Equal(expectedResult, isEmailCorporate);
}

```
</div>

7.3.2 تست کد از سه ربع دیگر
کدی با پیچیدگی کم و تعداد کمی همکار (ربع پایین سمت چپ در جدول 7.1) توسط سازنده‌های User و Company نمایش داده شده است، مانند:

<div dir="ltr">

```csharp
public User(int userId, string email, UserType type)
{
    UserId = userId;
    Email = email;
    Type = type;
}
```
<div>
این سازنده‌ها ساده هستند و ارزش تست را ندارند. تست‌های حاصل حفاظت زیادی در برابر بازگشت به عقب فراهم نمی‌کنند.

بازسازی تمام کد با پیچیدگی بالا و تعداد زیادی همکار (ربع بالا سمت راست در جدول 7.1) را حذف کرده است، بنابراین چیزی برای تست در آنجا نداریم. اما ربع کنترلرها (ربع پایین سمت راست در جدول 7.1) را در فصل بعد بررسی خواهیم کرد.

7.3.3 آیا باید پیش‌شرط‌ها را تست کنید؟
بیایید به یک نوع خاص از نقاط تصمیم‌گیری نگاه کنیم—پیش‌شرط‌ها—و ببینیم آیا باید آن‌ها را تست کنید. برای مثال، به این متد از Company دوباره نگاه کنید:

<div dir="ltr">

```csharp
public void ChangeNumberOfEmployees(int delta)
{
    Precondition.Requires(NumberOfEmployees + delta >= 0);
    NumberOfEmployees += delta;
}
```
</div>
این متد یک پیش‌شرط دارد که می‌گوید تعداد کارمندان در شرکت هرگز نباید منفی شود. این پیش‌شرط یک محافظ است که تنها در موارد استثنایی فعال می‌شود. چنین موارد استثنایی معمولاً نتیجه باگ‌ها هستند. تنها دلیل ممکن برای اینکه تعداد کارمندان زیر صفر برود این است که در کد خطایی وجود داشته باشد. محافظ، مکانیزمی برای نرم‌افزار شما فراهم می‌کند تا سریعاً شکست بخورد و از گسترش خطا و ذخیره آن در پایگاه داده جلوگیری کند، جایی که مدیریت آن بسیار سخت‌تر خواهد بود. آیا باید چنین پیش‌شرط‌هایی را تست کنید؟ به عبارت دیگر، آیا چنین تست‌هایی ارزش کافی برای قرار گرفتن در مجموعه تست دارند؟

قانون مشخصی وجود ندارد، اما دستورالعمل عمومی که من توصیه می‌کنم این است که تمام پیش‌شرط‌هایی که اهمیت حوزه دارند را تست کنید. الزام به تعداد غیرمنفی کارمندان یک چنین پیش‌شرطی است. این بخشی از این‌ورس‌های کلاس Company است: شرایطی که همیشه باید درست باشند. اما برای پیش‌شرط‌هایی که اهمیت حوزه ندارند وقت صرف نکنید. برای مثال، UserFactory محافظ زیر را در متد Create خود دارد:

<div dir="ltr">

```csharp
public static User Create(object[] data)
{
    Precondition.Requires(data.Length >= 3);
    /* Extract id, email, and type out of data */
}
```
</div>
هیچ معنای حوزه‌ای برای این پیش‌شرط وجود ندارد و بنابراین تست آن ارزش چندانی ندارد.

7.4 مدیریت منطق شرطی در کنترلرها
مدیریت منطق شرطی و همزمان حفظ لایه دامنه بدون وابستگی‌های خارج از فرآیند اغلب دشوار است و شامل مصالحه‌هایی می‌شود. در این بخش، نشان خواهم داد که این مصالحه‌ها چیستند و چگونه تصمیم بگیرید که کدام یک را در پروژه خود انتخاب کنید.

تفکیک بین منطق کسب‌وکار و هماهنگی بهترین کار را زمانی دارد که یک عملیات کسب‌وکار سه مرحله متمایز داشته باشد:

بازیابی داده‌ها از ذخیره‌سازی
اجرای منطق کسب‌وکار
ذخیره‌سازی داده‌ها در ذخیره‌سازی (نمودار 7.10)
در بسیاری از موارد، این مراحل به این وضوح نیستند. همانطور که در فصل 6 بحث کردیم، ممکن است نیاز داشته باشید داده‌های اضافی را از یک وابستگی خارج از فرآیند بر اساس نتیجه میانی فرآیند تصمیم‌گیری پرس‌وجو کنید (نمودار 7.11). نوشتن به وابستگی خارج از فرآیند اغلب به آن نتیجه بستگی دارد.

همچنین در فصل قبلی بحث کردیم که شما سه گزینه در چنین موقعیتی دارید:

همه خواندن‌ها و نوشتن‌های خارجی را به لبه‌ها منتقل کنید. این رویکرد ساختار خواندن-تصمیم‌گیری-عمل را حفظ می‌کند اما عملکرد را به خطر می‌اندازد: کنترلر حتی زمانی که نیازی به آن نیست به وابستگی‌های خارج از فرآیند فراخوانی می‌کند.
وابستگی‌های خارج از فرآیند را به مدل دامنه تزریق کنید و به منطق کسب‌وکار اجازه دهید تصمیم بگیرد که چه زمانی به آن وابستگی‌ها فراخوانی کند.
فرآیند تصمیم‌گیری را به مراحل کوچک‌تر تقسیم کنید و کنترلر را وادار کنید که بر اساس هر یک از آن مراحل جداگانه عمل کند.
چالش این است که تعادل بین سه ویژگی زیر را حفظ کنید:

تست‌پذیری مدل دامنه، که تابعی از تعداد و نوع همکاران در کلاس‌های دامنه است.
سادگی کنترلر، که به وجود نقاط تصمیم‌گیری در کنترلر بستگی دارد.
عملکرد، به تعداد فراخوانی‌ها به وابستگی‌های خارج از فرآیند تعریف شده است.
هر گزینه تنها دو تا از این سه ویژگی را فراهم می‌کند (نمودار 7.12):

انتقال همه خواندن‌ها و نوشتن‌های خارجی به لبه‌های یک عملیات کسب‌وکار—سادگی کنترلر را حفظ می‌کند و مدل دامنه را از وابستگی‌های خارج از فرآیند جدا نگه می‌دارد (بنابراین تست‌پذیر می‌ماند) اما عملکرد را به خطر می‌اندازد.
تزریق وابستگی‌های خارج از فرآیند به مدل دامنه—عملکرد و سادگی کنترلر را حفظ می‌کند اما تست‌پذیری مدل دامنه را خراب می‌کند.
تقسیم فرآیند تصمیم‌گیری به مراحل کوچک‌تر—عملکرد و تست‌پذیری مدل دامنه را حفظ می‌کند اما سادگی کنترلر را از بین می‌برد. باید نقاط تصمیم‌گیری را در کنترلر معرفی کنید تا این مراحل کوچک‌تر را مدیریت کنید.
در اکثر پروژه‌های نرم‌افزاری، عملکرد مهم است، بنابراین اولین رویکرد (انتقال همه خواندن‌ها و نوشتن‌های خارجی به لبه‌های یک عملیات کسب‌وکار) از سوال خارج است. گزینه دوم (تزریق وابستگی‌های خارج از فرآیند به مدل دامنه) اکثر کد شما را به ربع کد پیچیده در نمودار انواع کد منتقل می‌کند. این دقیقاً همان چیزی است که پیاده‌سازی اولیه CRM از آن بازسازی کردیم. توصیه می‌کنم از این رویکرد اجتناب کنید: چنین کدی دیگر تفکیک بین منطق کسب‌وکار و ارتباط با وابستگی‌های خارج از فرآیند را حفظ نمی‌کند و بنابراین تست و نگهداری آن بسیار سخت‌تر می‌شود.

این شما را با گزینه سوم باقی می‌گذارد: تقسیم فرآیند تصمیم‌گیری به مراحل کوچک‌تر. با این رویکرد، باید کنترلرهای خود را پیچیده‌تر کنید، که آن‌ها را به ربع کد پیچیده نزدیک می‌کند. اما روش‌هایی برای کاهش این مشکل وجود دارد. اگرچه به ندرت می‌توانید تمام پیچیدگی‌ها را از کنترلرها حذف کنید همانطور که قبلاً در پروژه نمونه انجام دادیم، می‌توانید آن پیچیدگی را مدیریت‌پذیر نگه دارید.

7.4.1 استفاده از الگوی CanExecute/Execute
اولین راه برای کاهش رشد پیچیدگی کنترلرها استفاده از الگوی CanExecute/Execute است، که به جلوگیری از نشت منطق کسب‌وکار از مدل دامنه به کنترلرها کمک می‌کند. این الگو با یک مثال بهترین توضیح داده می‌شود، بنابراین بگذارید پروژه نمونه خود را گسترش دهیم.

فرض کنید که یک کاربر تنها تا زمانی که ایمیل خود را تأیید نکرده است می‌تواند ایمیل خود را تغییر دهد. اگر کاربر پس از تأیید ایمیل تلاش کند آن را تغییر دهد، باید یک پیام خطا نشان داده شود. برای تطبیق با این الزام جدید، یک ویژگی جدید به کلاس User اضافه خواهیم کرد:

<div dir="ltr">

```csharp
public class User
{
    public int UserId { get; private set; }
    public string Email { get; private set; }
    public UserType Type { get; private set; }
    public bool IsEmailConfirmed { get; private set; } // ویژگی جدید

    /* متد ChangeEmail */
}
دو گزینه برای قرار دادن این بررسی وجود دارد. اول، می‌توانید آن را در متد ChangeEmail قرار دهید:

csharp
Copy code
public string ChangeEmail(string newEmail, Company company)
{
    if (IsEmailConfirmed)
        return "Can't change a confirmed email";
    
    /* بقیه متد */
}
```
</div>
سپس می‌توانید کنترلر را به گونه‌ای بسازید که یا یک خطا برگرداند یا همه اثرات جانبی لازم را اعمال کند، بسته به خروجی این متد.

<div dir="ltr">

```csharp
public string ChangeEmail(int userId, string newEmail)
{
    object[] userData = _database.GetUserById(userId);   
    User user = UserFactory.Create(userData);   

    object[] companyData = _database.GetCompany();   
    Company company = CompanyFactory.Create(companyData);   

    string error = user.ChangeEmail(newEmail, company);      
    if (error != null)     
        return error;      

    _database.SaveCompany(company);       
    _database.SaveUser(user);  
    _messageBus.SendEmailChangedMessage(userId, newEmail); 

    return "OK";  
}
```
</div>
این پیاده‌سازی کنترلر را از تصمیم‌گیری آزاد نگه می‌دارد، اما این کار را به هزینه عملکرد انجام می‌دهد. نمونه Company به صورت بی‌قید و شرطی از پایگاه داده بازیابی می‌شود، حتی زمانی که ایمیل تأیید شده است و بنابراین نمی‌تواند تغییر کند. این یک مثال از انتقال همه خواندن‌ها و نوشتن‌های خارجی به لبه‌های یک عملیات کسب‌وکار است.

توجه: من شرط جدید تحلیل خطا را افزایش پیچیدگی نمی‌دانم زیرا متعلق به فاز عملی است؛ بخشی از فرآیند تصمیم‌گیری نیست. تمام تصمیم‌ها توسط کلاس User گرفته شده‌اند، و کنترلر فقط بر اساس آن تصمیم‌ها عمل می‌کند.

گزینه دوم این است که بررسی IsEmailConfirmed را از User به کنترلر منتقل کنید.

<div dir="ltr">

```csharp
public string ChangeEmail(int userId, string newEmail)
{
    object[] userData = _database.GetUserById(userId);
    User user = UserFactory.Create(userData);

    if (user.IsEmailConfirmed)    
        return "Can't change a confirmed email";  

    object[] companyData = _database.GetCompany();
    Company company = CompanyFactory.Create(companyData);

    user.ChangeEmail(newEmail, company);

    _database.SaveCompany(company);
    _database.SaveUser(user);
    _messageBus.SendEmailChangedMessage(userId, newEmail);

    return "OK";
}
```
</div>
این پیاده‌سازی عملکرد را حفظ می‌کند: نمونه Company تنها پس از اطمینان از اینکه ایمیل می‌تواند تغییر کند بازیابی می‌شود. اما اکنون فرآیند تصمیم‌گیری به دو بخش تقسیم شده است:

آیا ادامه با تغییر ایمیل انجام شود (توسط کنترلر انجام می‌شود)
چه کاری باید در طول آن تغییر انجام شود (توسط User انجام می‌شود)
اکنون همچنین ممکن است ایمیل را بدون بررسی پرچم IsEmailConfirmed تغییر دهید، که محصورسازی مدل دامنه را کاهش می‌دهد. چنین تفکیکی تفکیک بین منطق کسب‌وکار و هماهنگی را مختل می‌کند و کنترلر را به منطقه خطرناک پیچیدگی نزدیک می‌کند.

برای جلوگیری از این تفکیک، می‌توانید یک متد جدید در User معرفی کنید، CanChangeEmail()، و اجرای موفق آن را به عنوان پیش‌شرط تغییر ایمیل قرار دهید. نسخه اصلاح شده در فهرست زیر الگوی CanExecute/Execute را دنبال می‌کند.

<div dir="ltr">

```csharp
public string CanChangeEmail()
{
    if (IsEmailConfirmed)
        return "Can't change a confirmed email";

    return null;
}

public void ChangeEmail(string newEmail, Company company)
{
    Precondition.Requires(CanChangeEmail() == null);

    /* بقیه متد */
}
```
</div>
این رویکرد دو فایده مهم دارد:

کنترلر دیگر نیازی به دانستن هیچ چیزی درباره فرآیند تغییر ایمیل ندارد. تنها کاری که باید انجام دهد این است که متد CanChangeEmail() را فراخوانی کند تا ببیند آیا عملیات انجام‌شدنی است. توجه کنید که این متد می‌تواند شامل چندین اعتبارسنجی باشد، همه در برابر کنترلر محصور شده‌اند.
پیش‌شرط اضافی در ChangeEmail() تضمین می‌کند که ایمیل هرگز بدون بررسی اولیه تأیید تغییر نخواهد کرد.
این الگو به شما کمک می‌کند همه تصمیم‌ها را در لایه دامنه مجتمع کنید. کنترلر دیگر گزینه‌ای برای عدم بررسی CanChangeEmail() قبل از ChangeEmail() ندارد، که عملاً نقطه تصمیم‌گیری جدید را از آن کنترلر حذف می‌کند. بنابراین، اگرچه کنترلر همچنان شامل شرط if است که CanChangeEmail() را فراخوانی می‌کند، نیازی به تست آن شرط if ندارید. تست واحد پیش‌شرط در کلاس User کافی است.

توجه: برای سادگی، من از یک رشته برای نشان دادن خطا استفاده می‌کنم. در یک پروژه دنیای واقعی، ممکن است بخواهید یک کلاس نتیجه سفارشی معرفی کنید تا موفقیت یا شکست یک عملیات را نشان دهد.

7.4.2 استفاده از رویدادهای دامنه برای ردیابی تغییرات در مدل دامنه
گاهی اوقات سخت است که تعیین کنید چه مراحلی مدل دامنه را به وضعیت فعلی رسانده‌اند. با این حال، ممکن است مهم باشد که بدانید این مراحل چه بوده‌اند زیرا باید سیستم‌های خارجی را درباره آنچه دقیقاً در برنامه شما اتفاق افتاده مطلع کنید. واگذاری این مسئولیت به کنترلرها آن‌ها را پیچیده‌تر می‌کند. برای جلوگیری از این مشکل، می‌توانید تغییرات مهم را در مدل دامنه ردیابی کنید و سپس آن تغییرات را به فراخوانی‌های وابستگی‌های خارج از فرآیند پس از تکمیل عملیات کسب‌وکار تبدیل کنید. رویدادهای دامنه به شما کمک می‌کنند این ردیابی را پیاده‌سازی کنید.

تعریف: یک رویداد دامنه یک رویداد در برنامه را توصیف می‌کند که برای کارشناسان دامنه معنادار است. معناداری برای کارشناسان دامنه چیزی است که رویدادهای دامنه را از رویدادهای معمولی (مانند کلیک‌های دکمه) متمایز می‌کند. رویدادهای دامنه اغلب برای اطلاع‌رسانی به برنامه‌های خارجی درباره تغییرات مهمی که در سیستم شما اتفاق افتاده‌اند استفاده می‌شوند.

CRM ما نیز یک نیاز به ردیابی دارد: باید سیستم‌های خارجی را درباره تغییر ایمیل کاربر با ارسال پیام‌ها به اتوبوس پیام‌رسان مطلع کند. پیاده‌سازی فعلی یک نقص در عملکرد اطلاع‌رسانی دارد: پیام‌ها حتی زمانی که ایمیل تغییر نمی‌کند ارسال می‌شوند، همانطور که در فهرست زیر نشان داده شده است.

<div dir="ltr">

```csharp
// User
public void ChangeEmail(string newEmail, Company company)
{
    Precondition.Requires(CanChangeEmail() == null);

    if (Email == newEmail)   
        return;

    /* بقیه متد */
}

// Controller
public string ChangeEmail(int userId, string newEmail)
{
    /* آماده‌سازی‌ها */

    user.ChangeEmail(newEmail, company);

    _database.SaveCompany(company);
    _database.SaveUser(user);
    _messageBus.SendEmailChangedMessage(userId, newEmail);

    return "OK";
}
```
</div>
می‌توانید این باگ را با انتقال بررسی یکسانی ایمیل به کنترلر حل کنید، اما سپس دوباره، مشکلاتی با تفکیک منطق کسب‌وکار وجود دارد. و نمی‌توانید این بررسی را به CanChangeEmail() منتقل کنید زیرا برنامه نباید خطا بازگرداند اگر ایمیل جدید همانند ایمیل قبلی باشد


توجه داشته باشید که این بررسی خاص احتمالاً پیچیدگی زیادی به منطق کسب‌وکار اضافه نمی‌کند، بنابراین من شخصاً کنترلر را پیچیده نمی‌دانم اگر این بررسی را در آن قرار دهیم. اما ممکن است خود را در موقعیت پیچیده‌تری بیابید که در آن سخت است جلوگیری کنید از اینکه برنامه شما فراخوانی‌های غیرضروری به وابستگی‌های خارج از فرآیند انجام دهد بدون اینکه این وابستگی‌ها را به مدل دامنه منتقل کنید، که در نتیجه مدل دامنه را پیچیده می‌کند. تنها راه برای جلوگیری از چنین پیچیدگی استفاده از رویدادهای دامنه است.

از دیدگاه پیاده‌سازی، یک رویداد دامنه کلاسی است که داده‌های مورد نیاز برای اطلاع‌رسانی به سیستم‌های خارجی را در خود دارد. در مثال خاص ما، این داده‌ها شامل شناسه کاربر و ایمیل جدید است:

<div dir="ltr">

```csharp
public class EmailChangedEvent
{
    public int UserId { get; }
    public string NewEmail { get; }

    public EmailChangedEvent(int userId, string newEmail)
    {
        UserId = userId;
        NewEmail = newEmail;
    }
}
```
</div>
توجه: رویدادهای دامنه همیشه باید به زمان گذشته نام‌گذاری شوند زیرا آن‌ها چیزهایی را نشان می‌دهند که قبلاً اتفاق افتاده‌اند. رویدادهای دامنه مقادیر هستند - آن‌ها غیرقابل تغییر و قابل تعویض هستند.

کلاس User یک مجموعه از چنین رویدادهایی خواهد داشت که یک عنصر جدید به آن اضافه می‌کند هنگامی که ایمیل تغییر می‌کند. اینگونه است که متد ChangeEmail() پس از بازسازی به نظر می‌رسد:

<div dir="ltr">

```csharp
public class User
{
    // Properties
    public int UserId { get; private set; }
    public string Email { get; private set; }
    public UserType Type { get; private set; }
    public bool IsEmailConfirmed { get; private set; }
    public List<EmailChangedEvent> EmailChangedEvents { get; private set; } = new List<EmailChangedEvent>();

    public void ChangeEmail(string newEmail, Company company)
    {
        Precondition.Requires(CanChangeEmail() == null);

        if (Email == newEmail)
            return;

        UserType newType = company.IsEmailCorporate(newEmail)
            ? UserType.Employee
            : UserType.Customer;

        if (Type != newType)
        {
            int delta = newType == UserType.Employee ? 1 : -1;
            company.ChangeNumberOfEmployees(delta);
        }

        Email = newEmail;
        Type = newType;
        EmailChangedEvents.Add(new EmailChangedEvent(UserId, newEmail));  
    }
}
```
</div>
سپس کنترلر این رویدادها را به پیام‌ها در اتوبوس پیام‌رسان تبدیل خواهد کرد.

<div dir="ltr">

```csharp
public class UserController
{
    private readonly Database _database = new Database();
    private readonly MessageBus _messageBus = new MessageBus();

    public string ChangeEmail(int userId, string newEmail)
    {
        object[] userData = _database.GetUserById(userId);
        User user = UserFactory.Create(userData);

        string error = user.CanChangeEmail();
        if (error != null)
            return error;

        object[] companyData = _database.GetCompany();
        Company company = CompanyFactory.Create(companyData);

        user.ChangeEmail(newEmail, company);

        _database.SaveCompany(company);
        _database.SaveUser(user);
        foreach (var ev in user.EmailChangedEvents)  
        {   
            _messageBus.SendEmailChangedMessage(ev.UserId, ev.NewEmail);   
        }   

        return "OK";
    }
}```
</div>
توجه کنید که نمونه‌های Company و User همچنان به صورت بی‌قید و شرطی در پایگاه داده ذخیره می‌شوند: منطق نگهداری وابسته به رویدادهای دامنه نیست. این به دلیل تفاوت بین تغییرات در پایگاه داده و پیام‌ها در اتوبوس پیام‌رسان است.

فرض کنید که هیچ برنامه‌ای به پایگاه داده دسترسی ندارد به جز CRM، ارتباطات با آن پایگاه داده بخشی از رفتار مشاهده‌شده CRM نیستند - آن‌ها جزئیات پیاده‌سازی هستند. تا زمانی که وضعیت نهایی پایگاه داده درست باشد، اهمیتی ندارد که برنامه شما چند بار به آن پایگاه داده فراخوانی می‌کند. از طرف دیگر، ارتباطات با اتوبوس پیام‌رسان بخشی از رفتار مشاهده‌شده برنامه هستند. برای حفظ قرارداد با سیستم‌های خارجی، CRM باید پیام‌ها را فقط زمانی به اتوبوس پیام‌رسان بفرستد که ایمیل تغییر کند.

پیامدهای عملکردی برای نگهداری داده‌ها در پایگاه داده به صورت بی‌قید و شرطی وجود دارد، اما این‌ها نسبتاً ناچیز هستند. احتمال اینکه پس از همه اعتبارسنجی‌ها ایمیل جدید همان ایمیل قدیمی باشد بسیار کم است. استفاده از ORM نیز می‌تواند کمک کند. اکثر ORMها در صورتی که تغییری در وضعیت شیء وجود نداشته باشد، سفر رفت و برگشتی به پایگاه داده انجام نمی‌دهند.

شما می‌توانید راه‌حل را با رویدادهای دامنه عمومی‌سازی کنید: یک کلاس پایه DomainEvent استخراج کنید و یک کلاس پایه برای همه کلاس‌های دامنه معرفی کنید که شامل یک مجموعه از چنین رویدادهایی است: List<DomainEvent> events. همچنین می‌توانید یک دیسپچر رویداد جداگانه بنویسید به جای اینکه رویدادهای دامنه را به صورت دستی در کنترلرها پردازش کنید. در نهایت، در پروژه‌های بزرگتر، ممکن است به مکانیزمی برای ترکیب رویدادهای دامنه قبل از دیسپچینگ نیاز داشته باشید. این موضوع خارج از محدوده این کتاب است. می‌توانید درباره آن در مقاله من "ترکیب رویدادهای دامنه قبل از دیسپچینگ" در این لینک بخوانید.

رویدادهای دامنه مسئولیت تصمیم‌گیری را از کنترلر حذف می‌کنند و آن را به مدل دامنه منتقل می‌کنند، بنابراین تست واحد ارتباطات با سیستم‌های خارجی را ساده می‌کنند. به جای بررسی مستقیم کنترلر و استفاده از تقلیدها برای جایگزینی وابستگی‌های خارج از فرآیند، می‌توانید ایجاد رویدادهای دامنه را به طور مستقیم در تست‌های واحد بررسی کنید، همانطور که در مثال زیر نشان داده شده است.

<div dir="ltr">

```csharp
[Fact]
public void Changing_email_from_corporate_to_non_corporate()
{
    var company = new Company("mycorp.com", 1);
    var sut = new User(1, "user@mycorp.com", UserType.Employee, false);

    sut.ChangeEmail("new@gmail.com", company);

    company.NumberOfEmployees.Should().Be(0);
    sut.Email.Should().Be("new@gmail.com");
    sut.Type.Should().Be(UserType.Customer);
    sut.EmailChangedEvents.Should().Equal(new EmailChangedEvent(1, "new@gmail.com"));  
}
```
</div>
البته، همچنان نیاز خواهید داشت که کنترلر را تست کنید تا اطمینان حاصل کنید که هماهنگی را به درستی انجام می‌دهد، اما انجام این کار نیاز به مجموعه کوچکتری از تست‌ها دارد. این موضوع فصل بعدی است.

7.5 نتیجه‌گیری
یک تم که در طول این فصل حضور داشت را متوجه شوید: انتزاع کردن اعمال اثرات جانبی به سیستم‌های خارجی. شما این انتزاع را با نگه داشتن آن اثرات جانبی در حافظه تا پایان عملیات کسب‌وکار به دست می‌آورید، به طوری که بتوان آن‌ها را با تست‌های واحد ساده بدون درگیر کردن وابستگی‌های خارج از فرآیند تست کرد. رویدادهای دامنه انتزاع‌هایی بر روی پیام‌های آینده در اتوبوس پیام‌رسان هستند. تغییرات در کلاس‌های دامنه انتزاع‌هایی بر روی اصلاحات آینده در پایگاه داده هستند.

توجه: تست کردن انتزاع‌ها آسان‌تر از چیزهایی است که آن‌ها انتزاع می‌کنند.

اگرچه ما توانستیم به کمک رویدادهای دامنه و الگوی CanExecute/Execute همه تصمیم‌گیری‌ها را در مدل دامنه محصور کنیم، شما همیشه قادر نخواهید بود که این کار را انجام دهید. شرایطی وجود دارد که در آن تفکیک منطق کسب‌وکار اجتناب‌ناپذیر است.

برای مثال، هیچ راهی برای بررسی یکتایی ایمیل خارج از کنترلر بدون معرفی وابستگی‌های خارج از فرآیند به مدل دامنه وجود ندارد. مثال دیگر شکست‌های در وابستگی‌های خارج از فرآیند است که باید مسیر عملیات کسب‌وکار را تغییر دهند. تصمیم درباره اینکه چه راهی برود نمی‌تواند در لایه دامنه قرار گیرد زیرا این لایه دامنه نیست که آن وابستگی‌های خارج از فرآیند را فراخوانی می‌کند. شما باید این منطق را در کنترلرها قرار دهید و سپس آن را با تست‌های یکپارچه پوشش دهید. با این حال، حتی با وجود تفکیک احتمالی، تفکیک منطق کسب‌وکار از هماهنگی ارزش زیادی دارد زیرا این تفکیک فرآیند تست واحد را به شدت ساده می‌کند.

همانطور که نمی‌توانید از داشتن برخی منطق کسب‌وکار در کنترلرها اجتناب کنید، به ندرت قادر خواهید بود که تمام همکاران را از کلاس‌های دامنه حذف کنید. و این اشکالی ندارد. یک، دو، یا حتی سه همکار یک کلاس دامنه را به کد پیچیده تبدیل نمی‌کنند، تا زمانی که این همکاران به وابستگی‌های خارج از فرآیند اشاره نکنند.

از تقلیدها برای بررسی تعاملات با چنین همکارانی استفاده نکنید. این تعاملات هیچ ارتباطی با رفتار مشاهده‌شده مدل دامنه ندارند. تنها فراخوانی اول، که از یک کنترلر به یک کلاس دامنه می‌رود، ارتباط فوری با هدف آن کنترلر دارد. همه فراخوانی‌های بعدی که کلاس دامنه به کلاس‌های همکار خود در همان عملیات می‌کند، جزئیات پیاده‌سازی هستند.

نمودار 7.13 این ایده را نشان می‌دهد. این نمودار ارتباطات بین اجزاء در CRM و ارتباط آن‌ها با رفتار مشاهده‌شده را نشان می‌دهد. همانطور که ممکن است از فصل 5 به خاطر بیاورید، اینکه آیا یک متد بخشی از رفتار مشاهده‌شده کلاس است بستگی به اینکه مشتری کیست و اهداف آن مشتری چیست دارد. برای اینکه بخشی از رفتار مشاهده‌شده باشد، متد باید یکی از دو معیار زیر را برآورده کند:

ارتباط فوری با یکی از اهداف مشتری داشته باشد.
یک اثر جانبی در یک وابستگی خارج از فرآیند ایجاد کند که برای برنامه‌های خارجی قابل مشاهده باشد.
متد ChangeEmail() کنترلر بخشی از رفتار مشاهده‌شده آن است و همینطور فراخوانی که به اتوبوس پیام‌رسان می‌کند. متد اول نقطه ورود برای مشتری خارجی است، بنابراین معیار اول را برآورده می‌کند. فراخوانی به اتوبوس پیام‌رسان پیام‌هایی را به برنامه‌های خارجی می‌فرستد، بنابراین معیار دوم را برآورده می‌کند. باید هر دو این فراخوانی‌ها را بررسی کنید (این موضوع فصل بعدی است). با این حال، فراخوانی بعدی از کنترلر به User ارتباط فوری با اهداف مشتری خارجی ندارد. آن مشتری اهمیتی نمی‌دهد که کنترلر چگونه تصمیم می‌گیرد ایمیل را تغییر دهد تا زمانی که وضعیت نهایی سیستم درست باشد و فراخوانی به اتوبوس پیام‌رسان در جای خود باشد. بنابراین، نباید فراخوانی‌هایی که کنترلر به User می‌کند را هنگام تست رفتار آن کنترلر بررسی کنید.

وقتی یک سطح پایین‌تر از پشته فراخوانی بروید، وضعیت مشابهی خواهید داشت. اکنون کنترلر مشتری است و متد ChangeEmail در User ارتباط فوری با هدف آن مشتری برای تغییر ایمیل کاربر دارد و بنابراین باید تست شود. اما فراخوانی‌های بعدی از User به Company جزئیات پیاده‌سازی از دید کنترلر هستند. بنابراین، تستی که متد ChangeEmail در User را پوشش می‌دهد نباید بررسی کند که چه متدهایی User بر روی Company فراخوانی می‌کند. همین خط استدلال زمانی که یک سطح دیگر پایین بروید و دو متد در Company را از دید User تست کنید اعمال می‌شود.

به رفتار مشاهده‌شده و جزئیات پیاده‌سازی مانند لایه‌های پیاز فکر کنید. هر لایه را از دیدگاه لایه بیرونی تست کنید و نادیده بگیرید که چگونه آن لایه با لایه‌های زیرین صحبت می‌کند. همانطور که این لایه‌ها را یکی یکی جدا می‌کنید، دیدگاه شما تغییر می‌کند: آنچه قبلاً یک جزئیات پیاده‌سازی بود اکنون به رفتار مشاهده‌شده تبدیل می‌شود که سپس با مجموعه دیگری از تست‌ها پوشش می‌دهید.

### خلاصه
پیچیدگی کد با تعداد نقاط تصمیم‌گیری در کد، چه آشکار (توسط خود کد) و چه ضمنی (توسط کتابخانه‌هایی که کد استفاده می‌کند) تعریف می‌شود.
اهمیت حوزه نشان می‌دهد که کد چقدر برای حوزه مشکل پروژه شما مهم است. کد پیچیده اغلب اهمیت حوزه بالایی دارد و بالعکس، اما نه در 100٪ موارد.
کد پیچیده و کدی که اهمیت حوزه دارد از تست واحد بیشترین بهره را می‌برد زیرا تست‌های مربوطه حفاظت بیشتری در برابر بازگشت به عقب دارند.
تست‌های واحدی که کدی با تعداد زیادی همکار را پوشش می‌دهند هزینه‌های نگهداری بالایی دارند. چنین تست‌هایی نیاز به فضای زیادی دارند تا همکاران را به یک وضعیت مورد انتظار برسانند و سپس وضعیت یا تعاملات آن‌ها را بررسی کنند.
تمام کدهای تولید را می‌توان به چهار نوع کد بر اساس پیچیدگی یا اهمیت حوزه و تعداد همکاران دسته‌بندی کرد:
مدل دامنه و الگوریتم‌ها (پیچیدگی یا اهمیت حوزه بالا، تعداد کمی همکار) بهترین بازدهی برای تلاش‌های تست واحد را فراهم می‌کنند.
کد بی‌اهمیت (پیچیدگی و اهمیت حوزه کم، تعداد کمی همکار) ارزش تست کردن ندارند.
کنترلرها (پیچیدگی و اهمیت حوزه کم، تعداد زیادی همکار) باید به صورت مختصر با تست‌های یکپارچه تست شوند.
کد پیچیده (پیچیدگی یا اهمیت حوزه بالا، تعداد زیادی همکار) باید به کنترلرها و کد پیچیده تقسیم شود.
هرچه کد مهم‌تر یا پیچیده‌تر باشد، باید تعداد همکاران کمتری داشته باشد.
الگوی شیء فروتن کمک می‌کند که کد پیچیده را تست‌پذیر کنید با استخراج منطق کسب‌وکار از آن کد به یک کلاس جداگانه. در نتیجه، کد باقی‌مانده به یک کنترلر تبدیل می‌شود - یک پوشش نازک فروتنانه در اطراف منطق کسب‌وکار.
معماری شش ضلعی و معماری تابعی الگوی شیء فروتن را پیاده‌سازی می‌کنند. معماری شش ضلعی تفکیک منطق کسب‌وکار و ارتباطات با وابستگی‌های خارج از فرآیند را توصیه می‌کند. معماری تابعی تفکیک منطق کسب‌وکار از ارتباطات با همه همکاران را توصیه می‌کند، نه فقط خارج از فرآیند.
به مسئولیت‌های منطق کسب‌وکار و هماهنگی به عنوان عمق کد در مقابل عرض کد فکر کنید. کد شما می‌تواند یا عمیق (پیچیده یا مهم) باشد یا پهن (با همکاران زیاد کار کند)، اما هرگز هر دو.
پیش‌شرط‌ها را تست کنید اگر اهمیت حوزه دارند؛ در غیر این صورت آن‌ها را تست نکنید.
سه ویژگی مهم هنگام تفکیک منطق کسب‌وکار از هماهنگی وجود دارد:
تست‌پذیری مدل دامنه—تابعی از تعداد و نوع همکاران در کلاس‌های دامنه.
سادگی کنترلر—بسته به وجود نقاط تصمیم‌گیری در کنترلر.
عملکرد—تعریف شده به تعداد فراخوانی‌ها به وابستگی‌های خارج از فرآیند.
می‌توانید حداکثر دو تا از این سه ویژگی را در هر لحظه داشته باشید:
انتقال همه خواندن‌ها و نوشتن‌های خارجی به لبه‌های یک عملیات کسب‌وکار—سادگی کنترلر و تست‌پذیری مدل دامنه را حفظ می‌کند، اما عملکرد را به خطر می‌اندازد.
تزریق وابستگی‌های خارج از فرآیند به مدل دامنه—عملکرد و سادگی کنترلر را حفظ می‌کند، اما تست‌پذیری مدل دامنه را خراب می‌کند.
تقسیم فرآیند تصمیم‌گیری به مراحل کوچک‌تر—عملکرد و تست‌پذیری مدل دامنه را حفظ می‌کند، اما سادگی کنترلر را از بین می‌برد.
تقسیم فرآیند تصمیم‌گیری به مراحل کوچک‌تر—یک معامله با بهترین مجموعه از مزایا و معایب است. می‌توانید رشد پیچیدگی کنترلر را با استفاده از دو الگوی زیر کاهش دهید:
الگوی CanExecute/Execute یک CanDo() برای هر متد Do() معرفی می‌کند و موفقیت اجرای آن را به عنوان پیش‌شرط Do() می‌سازد. این الگو عملاً نقاط تصمیم‌گیری را از کنترلر حذف می‌کند زیرا گزینه‌ای برای عدم فراخوانی CanDo() قبل از Do() وجود ندارد.
رویدادهای دامنه کمک می‌کنند تغییرات مهم را در مدل دامنه ردیابی کنید و سپس آن تغییرات را به فراخوانی‌های وابستگی‌های خارج از فرآیند تبدیل کنید. این الگو مسئولیت ردیابی را از کنترلر حذف می‌کند.
تست کردن انتزاع‌ها آسان‌تر از چیزهایی است که آن‌ها انتزاع می‌کنند. رویدادهای دامنه انتزاع‌هایی بر روی فراخوانی‌های آینده به وابستگی‌های خارج از فرآیند هستند. تغییرات در کلاس‌های دامنه انتزاع‌هایی بر روی اصلاحات آینده در ذخیره‌سازی داده‌ها هستند.

</div>

<div dir='rtl'>

### ترجمه کتاب Unit Testing: Principles, Practices, and Patterns

# مقدمه
من اولین پروژه‌ای که در آن آزمایش واحد (Unit Testing) را امتحان کردم، به یاد می‌آورم. نسبتاً خوب پیش رفت؛ اما پس از پایان پروژه، به تست‌ها نگاه کردم و فکر کردم که بسیاری از آن‌ها کاملاً بیهوده بودند. بیشتر Unit Testing های من زمان زیادی را صرف تنظیم انتظارات و اتصال یک شبکه پیچیده از وابستگی‌ها می‌کردند - همه این‌ها فقط برای بررسی اینکه سه خط کد در کنترلر من صحیح است. نمی‌توانستم به طور دقیق بگویم چه چیزی در تست‌ها اشتباه است، اما حس تناسب من سیگنال‌های بی‌ابهامی می‌فرستاد که چیزی درست نیست.
خوشبختانه، من Unit Testing را رها نکردم و به استفاده از آن در پروژه‌های بعدی ادامه دادم. با این حال، عدم توافق من با روش‌های رایج Unit Testing در آن زمان، به مرور زمان بیشتر شد. در طول سال‌ها، من زیاد در مورد Unit Testing نوشته‌ام. در آن نوشته‌ها، بالاخره توانستم دقیقاً مشخص کنم که چه چیزی در اولین تست‌های من اشتباه بود و این دانش را به حوزه‌های وسیع‌تری از Unit Testing تعمیم دادم. این کتاب نتیجه تمام تحقیقات، آزمون و خطاهای من در طول آن دوره است - گردآوری شده، تصفیه شده و تقطیر شده.
من از یک پیشینه ریاضی می‌آیم و به شدت معتقدم که راهنماهای برنامه‌نویسی، مانند قضایا در ریاضیات، باید از اصول اولیه استخراج شوند. سعی کرده‌ام این کتاب را به همین شکل ساختاردهی کنم: با یک صفحه سفید شروع کنیم، بدون پرش به نتیجه‌گیری‌ها یا ادعاهای بی‌پایه، و به تدریج استدلال خود را از پایه بسازیم. جالب است که وقتی چنین اصول اولیه‌ای را برقرار می‌کنید، راهنماها و بهترین شیوه‌ها اغلب به صورت طبیعی به عنوان نتایج ساده پدیدار می‌شوند.
من معتقدم که Unit Testing در حال تبدیل شدن به یک نیاز عملی برای پروژه‌های نرم‌افزاری است، و این کتاب همه چیزهایی را که نیاز دارید برای ایجاد تست‌های ارزشمند و بسیار قابل نگهداری، به شما ارائه می‌دهد.

# درباره این کتاب
کتاب "Unit Testing: Principles, Practices, and Patterns" به ارائه بینش‌هایی در مورد بهترین شیوه‌ها و الگوهای نامطلوب معمول در موضوع Unit Testing می‌پردازد. پس از خواندن این کتاب و مسلح شدن به مهارت‌های جدیدتان، دانش لازم برای تبدیل شدن به یک متخصص در تحویل پروژه‌های موفق که به راحتی قابل نگهداری و توسعه هستند را به دست خواهید آورد، به لطف تست‌هایی که در طول مسیر می‌سازید.
###   چه کسانی باید این کتاب را بخوانند
بیشتر منابع آنلاین و چاپی یک مشکل دارند: آن‌ها بر اصول اولیه Unit Testing تمرکز می‌کنند اما خیلی فراتر از آن نمی‌روند. این منابع ارزش زیادی دارند، اما یادگیری در اینجا به پایان نمی‌رسد. یک سطح بعدی وجود دارد: نه فقط نوشتن تست‌ها، بلکه انجام آن به طریقی که بهترین بازدهی را از تلاش‌هایتان به شما بدهد. وقتی به این نقطه در منحنی یادگیری می‌رسید، تقریباً به خودتان واگذار می‌شوید که بفهمید چگونه به سطح بعدی بروید.
این کتاب شما را به آن سطح بعدی می‌برد. یک تعریف علمی و دقیق از تست واحد ایده‌آل را آموزش می‌دهد. آن تعریف یک چارچوب مرجع جهانی ارائه می‌دهد که به شما کمک می‌کند بسیاری از تست‌های خود را از زاویه‌ای جدید ببینید و بفهمید کدامیک از آن‌ها به پروژه کمک می‌کنند و کدامیک باید بازنگری یا حذف شوند.
اگر تجربه زیادی در Unit Testing ندارید، از این کتاب چیزهای زیادی خواهید آموخت. اگر یک برنامه‌نویس با تجربه هستید، احتمالاً برخی از ایده‌های آموزش داده شده در این کتاب را قبلاً می‌دانید. این کتاب به شما کمک می‌کند توضیح دهید چرا تکنیک‌ها و بهترین شیوه‌هایی که همیشه استفاده کرده‌اید بسیار مفید هستند. و این مهارت را دست کم نگیرید: توانایی ارتباط واضح ایده‌های شما با همکارانتان بی‌نهایت ارزشمند است.

# نحوه سازماندهی این کتاب: یک نقشه راه
کتاب در ۱۱ فصل تقسیم شده به ۴ بخش.

**بخش ۱:** معرفی Unit Testing و مرور برخی اصول کلی Unit Testing

فصل ۱: هدف Unit Testing را تعریف کرده و یک مرور کلی بر تمایز بین یک تست خوب و بد ارائه می‌دهد.

فصل ۲: تعریف Unit Test را بررسی کرده و دو مکتب Unit Testing را مورد بحث قرار می‌دهد.

فصل ۳: مرور برخی موضوعات پایه مانند ساختاردهی Unit Testها، استفاده مجدد از تست فیچرها، و پارامتری‌سازی تست‌ها.

بخش ۲: به قلب موضوع می‌پردازد - نشان می‌دهد چه چیزی یک Unit Test خوب را می‌سازد و جزئیاتی درباره‌ی نحوه بازنگری
تست‌های شما به سمت ارزشمندتر بودن ارائه می‌دهد

فصل ۴: چهار ستون اصلی که یک Unit Test خوب را تشکیل می‌دهند و یک چارچوب مرجع مشترک که در سراسر کتاب استفاده می‌شود را تعریف می‌کند.

فصل ۵: برای استفاده از Mocks مورد بحث قرار می‌گیرد و ارتباط آن‌ها با شکنندگی تست‌ها را بررسی می‌کند.

فصل ۶: سه سبک Unit Testing را بررسی کرده و اینکه کدام یک از آن‌ها تست‌های با کیفیت بالا را تولید می‌کند و چرا.

فصل ۷: به شما می‌آموزد که چگونه از تست‌های بیش از حد پیچیده و حجیم دور شوید و تست‌هایی ایجاد کنید که حداکثر ارزش 
را با کمترین هزینه نگهداری ارائه دهند.

بخش ۳: موضوع Integration Testing را بررسی می‌کند

فصل ۸: نگاهی به Integration Testing در کل همراه با مزایا و معایب آن دارد.

فصل ۹: Mocks را بررسی کرده و نحوه استفاده از آن‌ها به گونه‌ای که بیشترین فایده را برای تست‌ها داشته باشد، توضیح می‌دهد.

فصل ۱۰: کار با پایگاه‌های داده رابطه‌ای در تست‌ها را بررسی می‌کند.

بخش ۴: فصل ۱۱ پوشش دهنده الگوهای نامطلوب Unit Testing است که شاید قبلاً با آن‌ها برخورد کرده باشید.

# درباره کد
نمونه کدها به زبان #C نوشته شده‌اند، اما موضوعاتی که این کدها نشان می‌دهند برای هر زبان شیءگرا مانند Java یا ++C نیز قابل استفاده هستند. #C فقط زبانی است که من بیشتر با آن کار می‌کنم. سعی کرده‌ام از ویژگی‌های خاص زبان #C استفاده نکنم و کدهای نمونه را تا حد ممکن ساده نگه دارم، بنابراین نباید در درک آن‌ها مشکلی داشته باشید. شما می‌توانید تمام نمونه کدها را به صورت آنلاین از سایت www.manning.com/books/unit-testing دانلود کنید.

# درباره نویسنده
ولادیمیر خوریکوف (Vladimir Khorikov) یک مهندس نرم‌افزار، Microsoft MVP، و نویسنده Pluralsight است. او بیش از 15 سال در توسعه نرم‌افزار به صورت حرفه‌ای فعالیت داشته است، از جمله راهنمایی تیم‌ها در مورد جزئیات Unit Testing. در سال‌های اخیر، ولادیمیر چندین مجموعه مقالات محبوب در وبلاگ و یک دوره آموزشی آنلاین در زمینه Unit Testing نوشته است. بزرگترین مزیت سبک تدریس او، که دانشجویان اغلب از آن تقدیر می‌کنند، تمایل او به داشتن یک پس‌زمینه قوی تئوریک است که سپس آن را به مثال‌های عملی اعمال می‌کند.

# درباره تصویر روی جلد
شخصیت روی جلد کتاب "Unit Testing: Principles, Practices, and Patterns" با عنوان "Esthinienne" مشخص شده است. این تصویر از مجموعه لباس‌های محلی از کشورهای مختلف توسط ژاک گراسه دو سن-سووور (Jacques Grasset de Saint-Sauveur) (1757–1810) گرفته شده است. این مجموعه با عنوان "Costumes Civils Actuels de Tous les Peuples Connus" در سال 1788 در فرانسه منتشر شد. هر تصویر با دقت و به صورت دستی ترسیم و رنگ‌آمیزی شده است. تنوع غنی مجموعه گراسه دو سن-سووور به ما به وضوح یادآوری می‌کند که چگونه شهرها و مناطق جهان تنها 200 سال پیش از لحاظ فرهنگی جدا از یکدیگر بودند. افراد با لهجه‌ها و زبان‌های مختلف صحبت می‌کردند و در خیابان‌ها یا حومه شهر، به راحتی می‌شد از طریق لباس آن‌ها تشخیص داد که کجا زندگی می‌کنند و شغل یا موقعیت اجتماعی آن‌ها چیست.

نحوه لباس پوشیدن ما از آن زمان تغییر کرده و تنوع منطقه‌ای که در آن زمان بسیار غنی بود، کمرنگ شده است. اکنون سخت است که ساکنان قاره‌های مختلف را از یکدیگر تشخیص دهیم، چه برسد به شهرها، مناطق یا کشورهای مختلف. شاید ما تنوع فرهنگی را با زندگی شخصی متنوع‌تر تعویض کرده‌ایم—قطعاً با زندگی فناوری متنوع‌تر و سریع‌تر.

در زمانی که سخت است که یک کتاب کامپیوتری را از کتاب دیگر تشخیص دهیم، Manning نوآوری و ابتکار عمل در صنعت کامپیوتر را با جلد کتاب‌هایی که بر اساس تنوع غنی زندگی منطقه‌ای دو قرن پیش طراحی شده‌اند، جشن می‌گیرد؛ این تنوع توسط تصاویر گراسه دو سن-سووور دوباره به زندگی بازگردانده شده است.


# بخش اول

###  دید کلی
این بخش از کتاب شما را با وضعیت فعلی Unit Testing آشنا خواهد کرد. در فصل 1، هدف Unit Testing را تعریف خواهم کرد و یک نمای کلی از چگونگی تمایز یک تست خوب از یک تست بد ارائه خواهم داد. درباره معیارهای پوشش (coverage metrics) صحبت خواهیم کرد و ویژگی‌های یک Unit Test خوب را به طور کلی مورد بحث قرار خواهیم داد.

در فصل 2، به تعریف Unit Test خواهیم پرداخت. یک اختلاف نظر ظاهراً جزئی بر سر این تعریف منجر به شکل‌گیری دو مکتب Unit Testing شده است که به آن‌ها نیز خواهیم پرداخت. فصل 3 مرور برخی موضوعات پایه‌ای مانند ساختاردهی Unit Test ها، استفاده مجدد از test fixtures، و پارامتری کردن تست‌ها را فراهم می‌کند.


# فصل اول
###   هدف از Unit Testing
یادگیری Unit Testing تنها به تسلط بر بخش‌های فنی آن، مانند فریمورک تست مورد علاقه‌تان، کتابخانه Mocking و غیره محدود نمی‌شود. Unit Testing بسیار فراتر از نوشتن تست‌ها است. شما همیشه باید تلاش کنید تا بهترین بازده را از زمانی که در Unit Testing سرمایه‌گذاری می‌کنید، به دست آورید، تلاش‌های خود را در تست‌ها به حداقل برسانید و فواید آن‌ها را به حداکثر برسانید. رسیدن به هر دو هدف کار آسانی نیست.

تماشای پروژه‌هایی که به این تعادل دست یافته‌اند شگفت‌انگیز است: این پروژه‌ها بدون دردسر رشد می‌کنند، نیاز به نگهداری زیادی ندارند و می‌توانند به سرعت با نیازهای همیشه در حال تغییر مشتریان خود سازگار شوند. به همان اندازه دیدن پروژه‌هایی که در انجام این کار شکست خورده‌اند ناامیدکننده است. با وجود تمام تلاش‌ها و تعداد چشمگیر Unit Test ها، چنین پروژه‌هایی به آرامی پیش می‌روند، دارای باگ‌های زیادی هستند و هزینه‌های نگهداری بالایی دارند.

این تفاوت بین تکنیک‌های مختلف Unit Testing است. برخی نتایج عالی به همراه دارند و به حفظ کیفیت نرم‌افزار کمک می‌کنند. برخی دیگر اینگونه نیستند: آن‌ها منجر به تست‌هایی می‌شوند که کمک چندانی نمی‌کنند، اغلب خراب می‌شوند و به طور کلی نیاز به نگهداری زیادی دارند.


آنچه در این کتاب یاد می‌گیرید به شما کمک می‌کند تا بین تکنیک‌های خوب و بد Unit Testing تمایز قائل شوید. شما خواهید آموخت که چگونه یک تحلیل cost-benefit از تست‌های خود انجام دهید و تکنیک‌های تست مناسب را در شرایط خاص خود اعمال کنید. همچنین یاد خواهید گرفت که چگونه از الگوهای نامطلوب رایج اجتناب کنید—الگوهایی که در ابتدا منطقی به نظر می‌رسند اما در ادامه مشکلاتی ایجاد می‌کنند.

اما بیایید با اصول اولیه شروع کنیم. این فصل یک مرور سریع از وضعیت Unit Testing در صنعت نرم‌افزار ارائه می‌دهد، هدف از نوشتن و نگهداری تست‌ها را توصیف می‌کند و به شما ایده‌ای از آنچه که یک مجموعه تست موفق را می‌سازد، ارائه می‌دهد.


# وضعیت فعلی Unit Testing
در دو دهه گذشته، یک فشار قابل توجه به سمت پذیرش Unit Testing وجود داشته است. این فشار به قدری موفقیت‌آمیز بوده که اکنون Unit Testing در بیشتر شرکت‌ها ضروری محسوب می‌شود. بیشتر برنامه‌نویسان Unit Testing را انجام می‌دهند و به اهمیت آن واقف هستند. دیگر هیچ بحثی وجود ندارد که آیا باید این کار را انجام داد یا نه. مگر اینکه روی یک پروژه موقتی کار کنید، پاسخ این است که بله، باید انجام دهید.

وقتی صحبت از توسعه برنامه‌های سازمانی می‌شود، تقریباً هر پروژه‌ای حداقل شامل چند Unit Test است. درصد قابل توجهی از این پروژه‌ها فراتر از این می‌روند: آن‌ها به پوشش کد خوب با تعداد زیادی Unit Test و Integration Test دست می‌یابند. نسبت بین کد تولیدی و کد تست می‌تواند از 1:1 تا 1:3 باشد (برای هر خط کد تولیدی، یک تا سه خط کد تست وجود دارد). گاهی اوقات، این نسبت بسیار بالاتر از این می‌رود و به نسبت حیرت‌آور 1:10 می‌رسد.

اما همانند تمام فناوری‌های جدید، Unit Testing نیز همچنان در حال تکامل است. بحث از "آیا باید Unit Test بنویسیم؟" به "نوشتن Unit Test خوب چه معنایی دارد؟" تغییر کرده است. اینجا است که همچنان سردرگمی اصلی وجود دارد.

شما می‌توانید نتایج این سردرگمی را در پروژه‌های نرم‌افزاری مشاهده کنید. بسیاری از پروژه‌ها تست‌های خودکار دارند؛ حتی ممکن است تعداد زیادی از آن‌ها را داشته باشند. اما وجود این تست‌ها اغلب نتایجی که توسعه‌دهندگان امیدوار بودند را فراهم نمی‌کند. برنامه‌نویسان همچنان تلاش زیادی برای پیشرفت در چنین پروژه‌هایی انجام می‌دهند. اضافه کردن ویژگی‌های جدید بسیار طول می‌کشد، باگ‌های جدید به طور مداوم در عملکردهای قبلاً پیاده‌سازی شده و پذیرفته شده ظاهر می‌شوند، و Unit Test هایی که قرار است کمک کنند، به نظر نمی‌رسد که این وضعیت را بهبود ببخشند. حتی ممکن است اوضاع را بدتر کنند.
این یک وضعیت وحشتناک برای هر کسی است و نتیجه داشتن Unit Test هایی است که وظیفه خود را به درستی انجام نمی‌دهند. تفاوت بین تست‌های خوب و بد تنها یک مسئله سلیقه یا ترجیح شخصی نیست، بلکه مسئله موفقیت یا شکست در پروژه مهمی است که روی آن کار می‌کنید.
سخت است که اهمیت بحث در مورد ویژگی‌های یک Unit Test خوب را دست‌کم بگیریم. با این حال، این بحث در صنعت توسعه نرم‌افزار امروز چندان مطرح نمی‌شود. شما می‌توانید چند مقاله و سخنرانی در کنفرانس‌ها را به صورت آنلاین پیدا کنید، اما هنوز هیچ مطلب جامع و کاملی در این موضوع ندیده‌ام.
وضعیت در کتاب‌ها نیز بهتر نیست؛ بیشتر آن‌ها بر اصول اولیه Unit Testing تمرکز دارند و فراتر از آن نمی‌روند. سوء تفاهم نشود، این کتاب‌ها ارزش زیادی دارند، به ویژه وقتی که تازه با Unit Testing شروع کرده‌اید. اما یادگیری با اصول اولیه تمام نمی‌شود. سطح بعدی وجود دارد: نه تنها نوشتن تست‌ها، بلکه انجام Unit Testing به روشی که بهترین بازده را از تلاش‌های شما به ارمغان می‌آورد. وقتی به این نقطه می‌رسید، بیشتر کتاب‌ها شما را به حال خود رها می‌کنند تا بفهمید چگونه به سطح بعدی برسید.
این کتاب شما را به سطح بعدی می‌برد. یک تعریف دقیق و علمی از Unit Test ایده‌آل را به شما آموزش می‌دهد. خواهید دید که چگونه این تعریف می‌تواند در مثال‌های عملی و واقعی اعمال شود. امیدوارم این کتاب به شما کمک کند بفهمید چرا پروژه خاص شما با وجود داشتن تعداد زیادی تست، به بیراهه رفته است و چگونه می‌توانید مسیر آن را بهبود بخشید.
بیشترین ارزش را از این کتاب خواهید برد اگر در توسعه برنامه‌های سازمانی کار می‌کنید، اما ایده‌های اصلی آن برای هر پروژه نرم‌افزاری قابل اعمال هستند.

### برنامه سازمانی چیست؟

یک برنامه سازمانی (Enterprise Application) برنامه‌ای است که هدف آن خودکارسازی یا کمک به فرآیندهای داخلی یک سازمان است. این برنامه‌ها می‌توانند اشکال مختلفی داشته باشند، اما معمولاً دارای ویژگی‌های زیر هستند:

-   پیچیدگی بالای منطق تجاری
-   طول عمر طولانی پروژه
-   مقدار متوسطی از داده‌ها
-   نیازهای عملکردی کم یا متوسط

توضیحات مترجم : 
برنامه‌های سازمانی برنامه‌هایی هستند که توسط شرکت‌ها و سازمان‌های بزرگ استفاده می‌شوند. این برنامه‌ها برای انجام وظایف خاص و حیاتی درون سازمان طراحی می‌شوند. در اینجا چند مثال ساده برای درک بهتر ارائه می‌کنم:

1.  **سیستم‌های مدیریت منابع سازمانی (ERP)**
2. **سیستم‌های مدیریت ارتباط با مشتری (CRM)**
3. **سیستم‌های اتوماسیون اداری (Office Automation Systems)**

# هدف Unit Testing
پیش از آنکه به عمق موضوع Unit Testing بپردازیم، بیایید کمی به عقب برگردیم و هدفی که Unit Testing به شما کمک می‌کند به آن دست یابید را در نظر بگیریم. اغلب گفته می‌شود که تمرین‌های Unit Testing منجر به طراحی بهتر می‌شوند. و این درست است: نیاز به نوشتن Unit Test برای یک پایگاه کد **(code base)** معمولاً به یک طراحی بهتر منجر می‌شود. اما این هدف اصلی Unit Testing نیست؛ بلکه تنها یک اثر جانبی خوشایند است.

### رابطه بین Unit Testing و code design

 قابلیت Unit Test یک قطعه کد به عنوان یک آزمون خوب عمل می‌کند، اما این آزمون تنها در یک جهت کار می‌کند. این یک شاخص منفی خوب است که کد با کیفیت پایین را با دقت نسبتاً بالا نشان می‌دهد. اگر متوجه شدید که کد به سختی قابل Unit Test است، این یک علامت قوی است که کد نیاز به بهبود دارد. کیفیت پایین معمولاً به صورت وابستگی‌های تنگاتنگ ظاهر می‌شود، یعنی قطعات مختلف کد تولید به اندازه کافی از یکدیگر جدا نشده‌اند و آزمایش آن‌ها به صورت جداگانه سخت است.
متأسفانه، قابلیت Unit Test یک قطعه کد یک شاخص مثبت بد است. واقعیت این است که شما می‌توانید به راحتی یک قطعه کد را Unit Test کنید به این معنا نیست که کد با کیفیت است. پروژه ممکن است حتی با وجود سطح بالای جداسازی کدها، همچنان دچار مشکلات جدی باشد.

### پس هدف Unit Testing چیست؟

هدف Unit Testing، امکان رشد پایدار پروژه نرم‌افزاری است. کلمه " پایدار" کلیدی است. شروع و رشد یک پروژه به ویژه زمانی که از ابتدا آغاز می‌کنید، نسبتاً آسان است. اما حفظ این رشد در طول زمان بسیار سخت‌تر است.
شکل ۱.۱ رشد dynamic یک پروژه معمولی بدون تست‌ها را نشان می‌دهد. شما ابتدا به سرعت شروع می‌کنید زیرا چیزی وجود ندارد که شما را به پایین بکشد. هنوز تصمیمات بد معماری اتخاذ نشده‌اند و کدی برای نگرانی وجود ندارد. با گذشت زمان، اما، شما باید ساعات بیشتری را صرف کنید تا همان میزان پیشرفتی را که در ابتدا داشتید، نشان دهید. در نهایت، سرعت توسعه به طور قابل توجهی کاهش می‌یابد، گاهی حتی تا جایی که هیچ پیشرفتی امکان‌پذیر نیست.

<p align="center">
    <img src="https://dll.98share.com/upload/user/storage/2/a/0/la9kf7thviqu2a0a6b899e0f64fdb907d4506bade2dd.png" />
</p>
> شکل ۱.۱: تفاوت در دینامیک رشد بین پروژه‌های با و بدون تست‌ها . پروژه‌ای بدون تست‌ها در ابتدا جلوتر است، اما به سرعت کند می‌شود تا جایی که پیشرفت کردن بسیار سخت می‌شود.

این پدیده کاهش سریع سرعت توسعه به عنوان **انتروپی نرم‌افزار (software entropy)** نیز شناخته می‌شود. انتروپی (میزان بی‌نظمی در یک سیستم) یک مفهوم ریاضی و علمی است که می‌تواند به سیستم‌های نرم‌افزاری نیز اعمال شود. (اگر به ریاضی و علم انتروپی علاقه‌مند هستید، قانون دوم ترمودینامیک را جستجو کنید.)

در نرم‌افزار، انتروپی به صورت کدی که تمایل به خرابی دارد، ظاهر می‌شود. هر بار که چیزی را در یک کد پایه تغییر می‌دهید، میزان بی‌نظمی در آن، یا انتروپی، افزایش می‌یابد. اگر بدون مراقبت مناسب مانند پاک‌سازی مداوم و بازسازی رها شود، سیستم به طور فزاینده‌ای پیچیده و بی‌نظم می‌شود. رفع یک باگ باعث ایجاد باگ‌های بیشتر می‌شود و تغییر در یک بخش از نرم‌افزار چندین بخش دیگر را خراب می‌کند. این مثل اثر دومینو است. در نهایت، کد پایه غیرقابل اعتماد می‌شود و از همه بدتر، بازگرداندن آن به حالت پایدار بسیار سخت است.

تست‌ها به مقابله با این تمایل کمک می‌کنند. آن‌ها مانند یک شبکه ایمنی عمل می‌کنند—ابزاری که در برابر اکثر خرابی‌ها بیمه می‌کند. تست‌ها کمک می‌کنند تا مطمئن شوید که عملکرد موجود حتی پس از اضافه کردن ویژگی‌های جدید یا بازسازی کد برای انطباق بهتر با نیازهای جدید، همچنان کار می‌کند.

> تعریف **Regression**:  زمانی اتفاق می‌افتد که یک ویژگی پس از یک رویداد خاص (معمولاً یک تغییر در کد) به درستی کار نمی‌کند. اصطلاحات **Regression** و **Software Bug** مترادف هستند و می‌توانند به جای یکدیگر استفاده شوند. >

مشکل اینجا این است که تست‌ها نیاز به تلاش اولیه دارند — گاهی اوقات تلاش قابل توجه. اما در بلندمدت این تلاش‌ها با کمک به رشد پروژه در مراحل بعدی خود را جبران می‌کنند. توسعه نرم‌افزار بدون کمک تست‌ها که به صورت مداوم کد پایه را بررسی می‌کنند، به سادگی قابل توسعه نیست.
**پایداری و مقیاس‌پذیری** کلیدهای اصلی هستند. این‌ها به شما امکان می‌دهند که سرعت توسعه را در بلندمدت حفظ کنید.

# چه چیزی یک تست خوب یا بد را مشخص می‌کند؟

اگرچه unit testing به حفظ رشد پروژه کمک می‌کند، اما فقط نوشتن تست‌ها کافی نیست. تست‌های بد نوشته‌شده نیز نتیجه مشابهی دارند.
همانطور که در شکل 1.2 نشان داده شده، تست‌های بد در ابتدا به کاهش سرعت افت کیفیت کد کمک می‌کنند: کاهش سرعت توسعه کمتر برجسته است در مقایسه با وضعیتی که هیچ تستی وجود ندارد. اما در مجموع هیچ چیز واقعاً تغییر نمی‌کند. ممکن است مدت بیشتری طول بکشد تا چنین پروژه‌ای وارد فاز رکود شود، اما رکود همچنان اجتناب‌ناپذیر است.
برای اینکه پروژه بتواند به طور پایدار رشد کند، نیاز به تست‌های خوب دارید. تست‌های بد ممکن است به طور موقت بهبود ایجاد کنند، اما در بلندمدت نمی‌توانند از رکود پروژه جلوگیری کنند.

<p align="center">
    <img src="https://dll.98share.com/upload/user/storage/4/d/b/m2qpyc63x4w54dbb4a1ce13e6020bde321c45dbb6cb0.png" />
</p>

به یاد داشته باشید، همه unit test ها به یک اندازه ارزشمند نیستند. برخی از آن‌ها مفید و موثر در بهبود کیفیت کلی نرم‌افزار هستند، در حالی که برخی دیگر این‌طور نیستند. این تست‌ها ممکن است هشدارهای نادرست ایجاد کنند، در شناسایی خطاهای برگشتی کمک نکنند و نگهداری از آن‌ها زمان‌بر و دشوار باشد. آسان است که در دام نوشتن unit test ها فقط به خاطر unit testing بیفتید بدون اینکه تصویر روشنی از کمک آن به پروژه داشته باشید.

شما نمی‌توانید هدف unit testing را فقط با اضافه کردن unit test های بیشتر به پروژه به دست آورید. باید هم به **ارزش تست** و هم به **هزینه نگهداری**  آن توجه کنید. بخش هزینه به میزان زمانی که صرف فعالیت‌های مختلف می‌شود، بستگی دارد:

-  Refactoring test وقتی که کد پایه را refactor می‌کنید 
-  اجرای تست در هر تغییر کد 
-  مقابله با هشدارهای نادرست ایجاد شده توسط تست 
-  صرف زمان برای خواندن تست وقتی که سعی می‌کنید رفتار کد پایه را بفهمید

ایجاد تست‌هایی که ارزش خالص آن‌ها نزدیک به صفر یا حتی منفی باشد به دلیل هزینه‌های بالای نگهداری آسان است. برای رشد پایدار پروژه، باید به طور انحصاری بر روی تست‌های با کیفیت بالا تمرکز کنید - این تنها نوع تست‌هایی هستند که نگه داشتن آن‌ها در مجموعه تست‌ها ارزش دارد.

> ## کد Production در مقابل کد تست  
> مردم اغلب فکر می‌کنند کد Production و کد تست با هم متفاوت هستند. تصور می‌شود که تست‌ها اضافه‌ای به کد تولیدی هستند و هیچ هزینه مالکیتی ندارند. به همین دلیل، مردم اغلب باور دارند که هر چه تست‌ها بیشتر باشد، بهتر است. این درست نیست. کد یک بدهی است، نه یک دارایی. هر چه کد بیشتری اضافه کنید، سطح بالقوه برای خطاها در نرم‌افزار خود را گسترش می‌دهید و هزینه نگهداری پروژه را افزایش می‌دهید. همیشه بهتر است مشکلات را با کمترین میزان کد ممکن حل کنید.
تست‌ها هم کد هستند. باید آن‌ها را به عنوان بخشی از کد پایه خود ببینید که هدفشان حل یک مشکل خاص است: اطمینان از درستی اپلیکیشن. Unit test ها، درست مانند هر کد دیگری، نیز مستعد خطا هستند و نیاز به نگهداری دارند.

بسیار مهم است که یاد بگیرید چگونه بین unit test های خوب و بد تفاوت قائل شوید. من این موضوع را در فصل ۴ توضیح می‌دهم.

# استفاده از **coverage metrics** برای سنجش کیفیت مجموعه تست‌ها  
در این بخش، من درباره دو **coverage metric** محبوب (**code coverage** - **branch coverage**) صحبت می‌کنم، نحوه محاسبه آن‌ها، نحوه استفاده از آن‌ها و مشکلات مربوط به آن‌ها. من نشان خواهم داد که چرا هدف‌گذاری برای یک عدد خاص در **coverage** برای برنامه‌نویسان مضر است و چرا نمی‌توانید فقط به **coverage metrics** اعتماد کنید تا کیفیت مجموعه تست خود را تعیین کنید.

>  یک **coverage metric** نشان می‌دهد که یک مجموعه تست چقدر از کد منبع را اجرا می‌کند، از هیچ تا 100%.

انواع مختلفی از coverage metric وجود دارد و اغلب برای ارزیابی کیفیت مجموعه تست استفاده می‌شوند. باور عمومی این است که هرچه عدد coverage بالاتر باشد، بهتر است.  
متاسفانه، این موضوع به این سادگی نیست و coverage metric ها، با وجود اینکه بازخورد ارزشمندی ارائه می‌دهند، نمی‌توانند به طور مؤثر کیفیت مجموعه تست را اندازه‌گیری کنند. این وضعیت مشابه با قابلیت unit test کردن کد است: coverage metric ها یک شاخص منفی خوب هستند اما یک شاخص مثبت بد.
اگر یک metric نشان دهد که coverage کد شما خیلی کم است - مثلاً فقط ۱۰٪ ، این یک نشانه خوب است که به اندازه کافی تست نمی‌کنید. اما برعکس این درست نیست: حتی coverage ۱۰۰٪ هم تضمینی برای داشتن یک مجموعه تست با کیفیت خوب نیست. یک مجموعه تست که coverage بالایی دارد، هنوز هم می‌تواند کیفیت پایینی داشته باشد.
من قبلاً اشاره کرده‌ام که چرا اینطور است - شما نمی‌توانید فقط تست‌های تصادفی را به پروژه خود اضافه کنید با این امید که این تست‌ها وضعیت را بهبود می‌بخشند. اما بیایید این مشکل را به طور دقیق‌تر با توجه به code coverage metric بررسی کنیم.

### درک code coverage metric 
اولین و پرکاربردترین code coverage ، coverage metric  یا همان test coverage است؛ به شکل ۱.۳ نگاه کنید. این metric نسبت تعداد خطوط کدی که حداقل توسط یک تست اجرا شده‌اند به تعداد کل خطوط در کد تولیدی را نشان می‌دهد.

<p align="center">
    <img src="https://dll.98share.com/upload/user/storage/5/e/3/psqgvdtefcrz5e37843f1fd0246c3c1fa81d1ea321dd.png" />
</p>
> شکل ۱.۳ **code coverage** یا **test coverage** به صورت نسبت بین تعداد خطوط کدی که توسط مجموعه تست اجرا شده‌اند و تعداد کل خطوط در کد تولیدی محاسبه می‌شود.

بیایید یک مثال را ببینیم تا بهتر بفهمیم که این چگونه کار می‌کند.
 **Listing 1.1** یک متد **IsStringLong** و یک تست که آن را پوشش می‌دهد را نشان می‌دهد. این متد تعیین می‌کند که آیا یک رشته که به عنوان ورودی به آن داده می‌شود، طولانی است یا نه (در اینجا، تعریف طولانی هر رشته‌ای است که طول آن بیشتر از پنج کاراکتر باشد). تست این متد را با استفاده از رشته "abc" اجرا می‌کند و بررسی می‌کند که این رشته به عنوان طولانی در نظر گرفته نمی‌شود.

<p align="center">
    <img src="https://dll.98share.com/upload/user/storage/b/0/3/5h9k6d78mzx2b03b75a9550f574a910878c5eec3dbf8.png" />
</p>

محاسبه **code coverage** در اینجا آسان است. تعداد کل خطوط در متد پنج خط است (آکولادها نیز حساب می‌شوند). تعداد خطوطی که توسط تست اجرا شده‌اند، چهار خط است - تست از تمام خطوط کد به جز دستور `;return true` عبور می‌کند. این به ما 80% = 0.8 = 4.5 می‌دهد.

حالا، اگر متد را تغییر دهم و **if statement** غیرضروری را به این صورت درون‌خطی کنم، چه اتفاقی می‌افتد؟

<div dir='ltr'>
  
```c#
public static bool IsStringLong(string input)
{
    return input.Length > 5;
}
public void Test()
{
    bool result = IsStringLong("abc");
    Assert.Equal(false, result);
}
```

</div>

آیا عدد code coverage تغییر می‌کند؟ بله، تغییر می‌کند. زیرا تست اکنون تمام سه خط کد را اجرا می‌کند (دستور return به علاوه دو آکولاد) ، code coverage به ۱۰۰٪ افزایش می‌یابد.  
اما آیا با این refactoring مجموعه تست‌ها را بهبود داده‌ام؟ البته که نه. من فقط کد داخل متد را جابه‌جا کرده‌ام. تست هنوز همان تعداد نتایج ممکن را بررسی می‌کند.
این مثال ساده نشان می‌دهد که چقدر آسان است که اعداد coverage را دستکاری کنیم. هر چه کد شما فشرده‌تر باشد، test coverage metric بهتر می‌شود، زیرا فقط به تعداد خطوط خام توجه می‌کند. در عین حال، فشرده کردن بیشتر کد در فضای کمتر، ارزش مجموعه تست‌ها یا قابلیت نگهداری کد پایه را تغییر نمی‌دهد (و نباید تغییر دهد).

### درک branch coverage metric  
یکی دیگر از coverage metric ها، **branch coverage** نامیده می‌شود. Branch coverage نتایج دقیق‌تری نسبت به code coverage ارائه می‌دهد زیرا به کاستی‌های code coverage کمک می‌کند. به جای استفاده از تعداد خام خطوط کد، این metric بر ساختارهای کنترلی، مانند دستورات **if** و **switch** تمرکز می‌کند. این نشان می‌دهد که چند مورد از این ساختارهای کنترلی توسط حداقل یک تست در مجموعه تست‌ها طی شده‌اند، همان‌طور که در شکل 1.4 نشان داده شده است.

<p align="center">
    <img src="https://dll.98share.com/upload/user/storage/4/1/3/xi1t523q9mby413a853afc3f5f33472a8dc7f16406b3.png" />
</p>

> شکل ۱.۴ **branch metric** به صورت نسبت بین تعداد code branches که توسط مجموعه تست‌ها اجرا شده‌اند و تعداد کل branches درproduction code base محاسبه می‌شود.

برای محاسبه **branch coverage metric** باید تمام شاخه‌های ممکن در کد خود را جمع کنید و ببینید که چند تا از آن‌ها توسط تست‌ها پیمایش شده‌اند. بیایید دوباره به مثال قبلی خود نگاه کنیم:

<div dir='ltr'>
  
```c#
public static bool IsStringLong(string input)
{
    return input.Length > 5;
}
public void Test()
{
    bool result = IsStringLong("abc");
    Assert.Equal(false, result);
}
```

</div>

در متد **IsStringLong** دو شاخه وجود دارد: یکی برای زمانی که طول رشته ورودی بیشتر از پنج کاراکتر است و دیگری برای زمانی که این‌طور نیست. تست فقط یکی از این شاخه‌ها را پوشش می‌دهد، بنابراین **branch coverage metric** برابر است با **1/2 = 0.5 = 50%**. و مهم نیست که کد تحت تست را چگونه نمایش دهیم - چه از **if statement** استفاده کنیم مانند قبل یا از نوتیشن کوتاه‌تر. Branch coverage metric فقط تعداد شاخه‌ها را در نظر می‌گیرد؛ توجهی به تعداد خطوط کدی که برای پیاده‌سازی آن شاخه‌ها استفاده شده ندارد.

شکل 1.5 یک روش مفید برای تجسم این metric را نشان می‌دهد. می‌توانید تمام مسیرهای ممکن که کد تحت تست می‌تواند طی کند را به صورت یک گراف نمایش دهید و ببینید چند تا از آن‌ها پیمایش شده‌اند. **IsStringLong** دو مسیر دارد و تست فقط یکی از آن‌ها را پیمایش می‌کند.

<p align="center">
    <img src="https://dll.98share.com/upload/user/storage/6/f/e/y2qk9s1uitd56fe32842e94120b9e0969a2a631cb960.png" />
</p>

> شکل 1.5 متد **IsStringLong** را به صورت یک گراف از مسیرهای ممکن کد نمایش می‌دهد. تست فقط یکی از دو مسیر کد را پوشش می‌دهد، بنابراین **branch coverage** برابر با 50٪ است.

## مشکلات **coverage metrics**  
اگرچه branch coverage metric نتایج بهتری نسبت به code coverage ارائه می‌دهد، اما هنوز نمی‌توانید برای تعیین کیفیت مجموعه تست خود به هیچ‌کدام از آن‌ها اعتماد کنید، به دو دلیل:

-  نمی‌توانید تضمین کنید که تست همه نتایج ممکن سیستم تحت تست را بررسی می‌کند.
-  هیچ coverage metric نمی‌تواند مسیرهای کد در کتابخانه‌های خارجی را در نظر بگیرد.

بیایید هر یک از این دلایل را با دقت بیشتری بررسی کنیم:

### 1-  نمی‌توانید تضمین کنید که تست همه نتایج ممکن را بررسی می‌کند

برای اینکه مسیرهای کد به‌طور واقعی تست شوند و نه فقط اجرا شوند، تست‌های واحد شما باید **assertion** های مناسبی داشته باشند. به عبارت دیگر، شما باید بررسی کنید که نتیجه‌ای که سیستم تحت تست تولید می‌کند دقیقاً همان نتیجه‌ای باشد که انتظار دارید. علاوه بر این، این نتیجه ممکن است چندین جزء داشته باشد؛ و برای اینکه coverage metrics معنی‌دار باشند، باید همه آن‌ها را بررسی کنید.

listing بعدی نسخه دیگری از متد IsStringLong را نشان می‌دهد. این متد نتیجه آخر را در یک **property** عمومی به نام **WasLastStringLong** ذخیره می‌کند.

<p align="center">
    <img src="https://dll.98share.com/upload/user/storage/d/f/8/582dar34m6pvdf850f704980c239d4fcb369c983e8b9.png" />
</p>

متد IsStringLong اکنون دو نتیجه دارد: یک نتیجه صریح که توسط مقدار بازگشتی رمزگذاری شده است و یک نتیجه ضمنی که مقدار جدید property است. با وجود اینکه نتیجه دوم و ضمنی بررسی نمی‌شود، coverage metrics همچنان نتایج یکسانی را نشان می‌دهند: ۱۰۰٪ برای **code coverage** و ۵۰٪ برای **branch coverage**. همان‌طور که می‌بینید، coverage metrics تضمین نمی‌کنند که کد زیربنایی تست شده باشد، فقط نشان می‌دهند که در برخی نقاط اجرا شده است.

نسخه‌ای افراطی از این وضعیت با نتایج ناقص تست شده، **assertion-free testing** است، یعنی زمانی که تست‌هایی می‌نویسید که هیچ assertion در آن‌ها وجود ندارد. در اینجا یک مثال از assertion-free testing آورده شده است:

<p align="center">
    <img src="https://dll.98share.com/upload/user/storage/2/3/5/fbzn2yjgrsil23542e77b6c66ae4b72fc25ee1a1d293.png" />
</p>

این تست هم دارای **code coverage** و هم **branch coverage** با درصد ۱۰۰٪ است. اما در عین حال، کاملاً بی‌فایده است زیرا هیچ چیزی را بررسی نمی‌کند.

## یک داستان از میدان نبرد

مفهوم **assertion-free testing** ممکن است به نظر احمقانه بیاید، اما واقعاً در دنیای واقعی هم پیش می‌آید.
سال‌ها پیش، من بر روی پروژه‌ای کار می‌کردم که مدیریت یک الزام سختگیرانه برای داشتن ۱۰۰٪ code coverage برای هر پروژه در حال توسعه وضع کرده بود. این ابتکار نیت‌های نیکوی داشت. در آن زمان، unit testing به اندازه امروز رایج نبود. تعداد کمی از افراد در سازمان به این کار مشغول بودند و حتی کمتر از آن‌ها به طور مداوم unit testing انجام می‌دادند.
گروهی از توسعه‌دهندگان به یک کنفرانس رفته بودند که بسیاری از سخنرانی‌ها به unit testing اختصاص داشت. پس از بازگشت، آن‌ها تصمیم گرفتند دانش جدید خود را به عمل درآورند. مدیریت عالی از آن‌ها حمایت کرد و تبدیل بزرگ به تکنیک‌های برنامه‌نویسی بهتر آغاز شد. ارائه‌های داخلی برگزار شد. ابزارهای جدید نصب شد. و از همه مهم‌تر، یک قانون جدید در سطح شرکت اعمال شد: تمام تیم‌های توسعه باید به طور انحصاری بر نوشتن تست‌ها تمرکز کنند تا به هدف ۱۰۰٪ code coverage دست یابند. پس از رسیدن به این هدف، هر بررسی کدی که coverage metric را کاهش می‌داد باید توسط سیستم‌های ساخت رد می‌شد.
همان‌طور که ممکن است حدس بزنید، این روش نتیجه خوبی نداشت. تحت فشار این محدودیت شدید، توسعه‌دهندگان شروع به یافتن راه‌هایی برای دور زدن سیستم کردند. به طور طبیعی، بسیاری از آن‌ها به این نتیجه رسیدند که اگر همه تست‌ها را در بلوک‌های **try/catch** قرار دهند و هیچ assertion ای در آن‌ها نداشته باشند، این تست‌ها تضمین شده به موفقیت می‌رسند. مردم شروع به ایجاد بی‌فکری تست‌هایی برای برآورده کردن الزامات ۱۰۰٪ coverage کردند.
بدیهی است که این تست‌ها هیچ ارزشی به پروژه‌ها اضافه نکردند. علاوه بر این، آن‌ها به پروژه‌ها آسیب زدند زیرا تمام تلاش و زمانی که باید صرف فعالیت‌های مفید می‌شد، به ایجاد و نگهداری تست‌ها اختصاص یافت و هزینه‌های نگهداری تست‌ها نیز افزایش یافت.
در نهایت، الزامات کاهش یافت و به ۹۰٪ و سپس به ۸۰٪ رسید؛ و پس از مدتی، به طور کلی لغو شد (و این تصمیم به نفع پروژه‌ها بود!).

اما بیایید بگوییم که شما به طور کامل هر نتیجه از کد تحت تست را بررسی می‌کنید. آیا این، به همراه branch coverage metric، مکانیزم قابل اعتمادی را برای تعیین کیفیت مجموعه تست‌ها فراهم می‌کند؟ متأسفانه، خیر.

### هیچ coverage metric ای نمی‌تواند مسیرهای کد در کتابخانه‌های خارجی را در نظر بگیرد
مشکل دوم با تمام **coverage metrics** این است که آن‌ها مسیرهای کدی که کتابخانه‌های خارجی هنگام فراخوانی متدها توسط سیستم تحت تست طی می‌کنند، در نظر نمی‌گیرند. بیایید به مثال زیر نگاه کنیم:

<div dir='ltr'>
  
```c#
public static int Parse(string input)
{
    return int.Parse(input);
}
public void Test()
{
    int result = Parse("5");
    Assert.Equal(5, result);
}
```

</div>

متریک branch coverage نشان می‌دهد که ۱۰۰٪ پوشش را دارد و تست تمام اجزای نتیجه متد را بررسی می‌کند. در هر صورت، این متد فقط یک جزء دارد—مقدار بازگشتی. در عین حال، این تست هیچ‌گونه جامعی ندارد. این تست به مسیرهای کدی که متد **int.Parse** از **.NET Framework** ممکن است از آن‌ها عبور کند، توجه نمی‌کند. و در این متد ساده، مسیرهای کد زیادی وجود دارد، همان‌طور که در شکل 1.6 مشاهده می‌کنید.

<p align="center">
    <img src="https://dll.98share.com/upload/user/storage/5/1/a/sk5bv86fuegx51aefb3118956b270d41a1628564b4d4.png" />
</p>

>شکل 1.6 مسیرهای کد پنهان کتابخانه‌های خارجی. **Coverage metrics** هیچ راهی برای مشاهده تعداد این مسیرها و تعداد مسیری که تست‌های شما به آن‌ها دسترسی پیدا می‌کنند، ندارد.

نوع عدد صحیح پیش‌ساخته دارای شاخه‌های زیادی است که از تست پنهان هستند و ممکن است نتایج متفاوتی به همراه داشته باشند، در صورتی که پارامتر ورودی متد تغییر کند. در اینجا چند نمونه از آرگومان‌هایی که نمی‌توانند به یک عدد صحیح تبدیل شوند، آورده شده است:

-   مقدار null
-   رشته خالی
-   "Not an int"
-   رشته‌ای که بسیار بزرگ است

ممکن است با موارد لبه‌ای زیادی روبه‌رو شوید و راهی برای دیدن اینکه آیا تست‌های شما تمام آن‌ها را در نظر گرفته‌اند، وجود ندارد.
این به این معنی نیست که coverage metrics باید مسیرهای کد در کتابخانه‌های خارجی را در نظر بگیرند (که نباید)، بلکه هدف این است که نشان دهیم نمی‌توانید به این متریک‌ها برای تعیین کیفیت یا کمیت تست‌های واحد خود اعتماد کنید. **Coverage metrics** نمی‌توانند به طور ممکن بگویند که آیا تست‌های شما جامع هستند یا خیر؛ همچنین نمی‌توانند بگویند که آیا تست‌های کافی دارید یا نه.

# هدف‌گذاری بر روی یک عدد پوشش خاص

در این مرحله، امیدوارم متوجه شده باشید که تکیه بر **coverage metrics** برای تعیین کیفیت مجموعه تست‌های شما کافی نیست. همچنین می‌تواند به منطقه خطرناکی منجر شود اگر شروع به هدف‌گذاری بر روی یک عدد پوشش خاص کنید، چه آن عدد ۱۰۰٪، ۹۰٪ یا حتی ۷۰٪ باشد. بهترین روش برای نگاه به **coverage metric** این است که آن را به عنوان یک شاخص ببینید، نه به عنوان یک هدف به خودی خود.

به یک بیمار در بیمارستان فکر کنید. دمای بالای او ممکن است نشان‌دهنده تب باشد و یک مشاهده مفید است. اما بیمارستان نباید دمای مناسب این بیمار را به عنوان هدفی برای رسیدن به آن با هر وسیله‌ای تبدیل کند. در غیر این صورت، بیمارستان ممکن است با راه‌حل سریع و "موثر" نصب یک دستگاه تهویه مطبوع در کنار بیمار و تنظیم دما با تنظیم مقدار هوای سردی که بر روی پوست او می‌وزد، مواجه شود. واضح است که این روش هیچ منطقی ندارد.
به‌ طور مشابه، هدف‌گذاری بر روی یک عدد پوشش خاص انگیزه‌ای معکوس ایجاد می‌کند که برخلاف هدف اصلی unit testing است. به جای تمرکز بر تست کردن مواردی که اهمیت دارند، افراد شروع به جستجوی راه‌هایی برای دستیابی به این هدف مصنوعی می‌کنند. Unit testing به اندازه کافی دشوار است. تعیین یک عدد پوشش اجباری فقط توسعه‌دهندگان را از توجه به آنچه که تست می‌کنند، منحرف می‌کند و دستیابی به unit testing مناسب را سخت‌تر می‌سازد.

> نکته :
خوب است که coverage بالایی در بخش‌های اصلی سیستم خود داشته باشید.  
بد است که این سطح بالای coverage را به عنوان یک الزام قرار دهید. تفاوت بین این دو ظریف اما حیاتی است.

اجازه دهید دوباره تکرار کنم: **coverage metrics** یک شاخص منفی خوب هستند، اما یک شاخص مثبت بد. اعداد پوشش پایین—مثلاً زیر ۶۰٪—نشانه‌ای قطعی از مشکل هستند. این به این معنی است که بخش زیادی از کد شما تست نشده است. اما اعداد بالای پوشش به هیچ چیزی اشاره نمی‌کنند. بنابراین، اندازه‌گیری code coverage تنها باید یک قدم اولیه در راه رسیدن به یک مجموعه تست با کیفیت باشد.

# موفقیت یک مجموعه تست چگونه سنجیده می‌شود؟

در این فصل بیشتر درباره روش‌های نادرست اندازه‌گیری کیفیت مجموعه تست‌ها بحث کردم: استفاده از coverage metrics. حالا روش صحیح چیست؟ چگونه باید کیفیت مجموعه تست‌های خود را ارزیابی کنید؟ تنها راه قابل اعتماد ارزیابی هر تست به صورت فردی، یکی یکی است. البته، لازم نیست تمام تست‌ها را به طور همزمان ارزیابی کنید؛ این می‌تواند کار بزرگی باشد و نیاز به تلاش قابل توجهی داشته باشد.

شما می‌توانید این ارزیابی را به صورت تدریجی انجام دهید. **نکته این است که هیچ راه خودکاری برای دیدن کیفیت مجموعه تست‌های شما وجود ندارد. شما باید از قضاوت شخصی خود استفاده کنید.**

برای داشتن یک دید کلی از اینکه چه چیزی یک مجموعه تست را به طور کلی موفق می‌سازد، به نکات زیر توجه کنید: (ما به جزئیات تفاوت بین تست‌های خوب و بد در فصل ۴ خواهیم پرداخت.)
یک مجموعه تست موفق ویژگی‌های زیر را دارد:

-   **یکپارچه با چرخه توسعه**: تست‌ها به طور منظم و هماهنگ با فرآیند توسعه نرم‌افزار اجرا می‌شوند.
-   **تمرکز بر بخش‌های مهم کد**: تنها بخش‌های کلیدی و مهم کد را هدف قرار می‌دهد.
-   **ارائه حداکثر ارزش با حداقل هزینه نگهداری**: بیشترین ارزش را با کمترین هزینه برای نگهداری فراهم می‌آورد.

### - یکپارچگی با چرخه توسعه

تنها هدف از داشتن تست‌های خودکار این است که به طور مداوم از آن‌ها استفاده کنید. تمام تست‌ها باید در چرخه توسعه یکپارچه شوند. ایده‌آل این است که آن‌ها را در هر تغییر کد، حتی کوچک‌ترین تغییرات، اجرا کنید.

### - تمرکز بر بخش‌های مهم کد

همان‌طور که تمام تست‌ها برابر نیستند، تمام بخش‌های کد شما نیز از نظر تست‌کردن به یک اندازه اهمیت ندارند. ارزش تست‌ها تنها به نحوه ساختار آن‌ها نیست، بلکه به کدی که آن‌ها بررسی می‌کنند نیز بستگی دارد.

مهم است که تلاش‌های تست واحد خود را به مهم‌ترین بخش‌های سیستم معطوف کنید و سایر بخش‌ها را به صورت مختصر یا غیرمستقیم بررسی کنید. در اکثر برنامه‌ها، مهم‌ترین بخش، بخشی است که شامل **domain model - business logic** است. business logic test بهترین بازگشت سرمایه زمانی را به شما می‌دهد. تمام بخش‌های دیگر را می‌توان به سه دسته تقسیم کرد:

-   **کد زیرساخت** (Infrastructure code): کدی که برای پشتیبانی و راه‌اندازی سیستم‌های پایه‌ای و زیرساختی استفاده می‌شود.
-   **خدمات و وابستگی‌های خارجی**: مانند پایگاه داده و سیستم‌های شخص ثالث.
-   **کدی که همه چیز را به هم می‌چسباند**: کدی که مسئول اتصال و هماهنگی اجزای مختلف سیستم است.

برخی از این بخش‌های دیگر ممکن است هنوز نیاز به تست‌های واحد دقیق داشته باشند. به عنوان مثال، **Infrastructure code** ممکن است شامل الگوریتم‌های پیچیده و مهمی باشد، بنابراین منطقی است که آن‌ها را نیز با تعداد زیادی تست پوشش دهید. اما به طور کلی، بیشتر توجه شما باید بر روی **domain model** متمرکز باشد.
برخی از تست‌های شما، مانند **integration tests** می‌توانند فراتر از مدل دامنه بروند و نحوه عملکرد سیستم به طور کلی، از جمله بخش‌های غیرمهم کد، را بررسی کنند. و این اشکالی ندارد. اما تمرکز باید همچنان بر روی مدل دامنه باقی بماند.

توجه داشته باشید که برای پیروی از این راهنما، باید domain model را از بخش‌های غیرضروری کد جدا کنید. شما باید مدل دامنه را از تمام نگرانی‌های دیگر اپلیکیشن جدا نگه دارید تا بتوانید تمام تلاش‌های تست واحد خود را به طور خاص بر روی آن مدل دامنه متمرکز کنید. ما به تفصیل در مورد این موضوعات در بخش ۲ کتاب صحبت خواهیم کرد.

>برای اطلاعات بیشتر در مورد **Domain-Driven Design** به کتاب زیر مراجعه کنید:
**Domain-Driven Design: Tackling Complexity in the Heart of Software**  
نویسنده: **Eric Evans**  
انتشارات: **Addison-Wesley، 2003**
</div>
